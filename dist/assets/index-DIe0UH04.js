;(function () {
    const t = document.createElement('link').relList
    if (t && t.supports && t.supports('modulepreload')) return
    for (const r of document.querySelectorAll('link[rel="modulepreload"]')) i(r)
    new MutationObserver(r => {
        for (const n of r)
            if (n.type === 'childList')
                for (const a of n.addedNodes)
                    a.tagName === 'LINK' && a.rel === 'modulepreload' && i(a)
    }).observe(document, { childList: !0, subtree: !0 })
    function e(r) {
        const n = {}
        return (
            r.integrity && (n.integrity = r.integrity),
            r.referrerPolicy && (n.referrerPolicy = r.referrerPolicy),
            r.crossOrigin === 'use-credentials'
                ? (n.credentials = 'include')
                : r.crossOrigin === 'anonymous'
                  ? (n.credentials = 'omit')
                  : (n.credentials = 'same-origin'),
            n
        )
    }
    function i(r) {
        if (r.ep) return
        r.ep = !0
        const n = e(r)
        fetch(r.href, n)
    }
})()
const sa = {
    atlases: [
        'my-texture-0.json',
        'my-texture-1.json',
        'my-texture-2.json',
        'my-texture-3.json',
    ],
    fonts: ['RobotoCondensed-VariableFont_wght.ttf'],
    images: ['cards_background.jpg', 'cc_background.jpg', 'ui_background.jpg'],
}
var cn =
    typeof globalThis < 'u'
        ? globalThis
        : typeof window < 'u'
          ? window
          : typeof global < 'u'
            ? global
            : typeof self < 'u'
              ? self
              : {}
function Nh(s) {
    return s &&
        s.__esModule &&
        Object.prototype.hasOwnProperty.call(s, 'default')
        ? s.default
        : s
}
function nm(s) {
    if (Object.prototype.hasOwnProperty.call(s, '__esModule')) return s
    var t = s.default
    if (typeof t == 'function') {
        var e = function i() {
            var r = !1
            try {
                r = this instanceof i
            } catch {}
            return r
                ? Reflect.construct(t, arguments, this.constructor)
                : t.apply(this, arguments)
        }
        e.prototype = t.prototype
    } else e = {}
    return (
        Object.defineProperty(e, '__esModule', { value: !0 }),
        Object.keys(s).forEach(function (i) {
            var r = Object.getOwnPropertyDescriptor(s, i)
            Object.defineProperty(
                e,
                i,
                r.get
                    ? r
                    : {
                          enumerable: !0,
                          get: function () {
                              return s[i]
                          },
                      },
            )
        }),
        e
    )
}
var na = { exports: {} },
    Yl
function am() {
    return (
        Yl ||
            ((Yl = 1),
            (function (s) {
                ;(function () {
                    function t(p, g) {
                        document.addEventListener
                            ? p.addEventListener('scroll', g, !1)
                            : p.attachEvent('scroll', g)
                    }
                    function e(p) {
                        document.body
                            ? p()
                            : document.addEventListener
                              ? document.addEventListener(
                                    'DOMContentLoaded',
                                    function g() {
                                        ;(document.removeEventListener(
                                            'DOMContentLoaded',
                                            g,
                                        ),
                                            p())
                                    },
                                )
                              : document.attachEvent(
                                    'onreadystatechange',
                                    function g() {
                                        ;(document.readyState ==
                                            'interactive' ||
                                            document.readyState ==
                                                'complete') &&
                                            (document.detachEvent(
                                                'onreadystatechange',
                                                g,
                                            ),
                                            p())
                                    },
                                )
                    }
                    function i(p) {
                        ;((this.g = document.createElement('div')),
                            this.g.setAttribute('aria-hidden', 'true'),
                            this.g.appendChild(document.createTextNode(p)),
                            (this.h = document.createElement('span')),
                            (this.i = document.createElement('span')),
                            (this.m = document.createElement('span')),
                            (this.j = document.createElement('span')),
                            (this.l = -1),
                            (this.h.style.cssText =
                                'max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;'),
                            (this.i.style.cssText =
                                'max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;'),
                            (this.j.style.cssText =
                                'max-width:none;display:inline-block;position:absolute;height:100%;width:100%;overflow:scroll;font-size:16px;'),
                            (this.m.style.cssText =
                                'display:inline-block;width:200%;height:200%;font-size:16px;max-width:none;'),
                            this.h.appendChild(this.m),
                            this.i.appendChild(this.j),
                            this.g.appendChild(this.h),
                            this.g.appendChild(this.i))
                    }
                    function r(p, g) {
                        p.g.style.cssText =
                            'max-width:none;min-width:20px;min-height:20px;display:inline-block;overflow:hidden;position:absolute;width:auto;margin:0;padding:0;top:-999px;white-space:nowrap;font-synthesis:none;font:' +
                            g +
                            ';'
                    }
                    function n(p) {
                        var g = p.g.offsetWidth,
                            _ = g + 100
                        return (
                            (p.j.style.width = _ + 'px'),
                            (p.i.scrollLeft = _),
                            (p.h.scrollLeft = p.h.scrollWidth + 100),
                            p.l !== g ? ((p.l = g), !0) : !1
                        )
                    }
                    function a(p, g) {
                        function _() {
                            var v = b
                            n(v) && v.g.parentNode !== null && g(v.l)
                        }
                        var b = p
                        ;(t(p.h, _), t(p.i, _), n(p))
                    }
                    function o(p, g, _) {
                        ;((g = g || {}),
                            (_ = _ || window),
                            (this.family = p),
                            (this.style = g.style || 'normal'),
                            (this.weight = g.weight || 'normal'),
                            (this.stretch = g.stretch || 'normal'),
                            (this.context = _))
                    }
                    var h = null,
                        l = null,
                        u = null,
                        c = null
                    function d(p) {
                        return (
                            l === null &&
                                (f(p) && /Apple/.test(window.navigator.vendor)
                                    ? ((p =
                                          /AppleWebKit\/([0-9]+)(?:\.([0-9]+))(?:\.([0-9]+))/.exec(
                                              window.navigator.userAgent,
                                          )),
                                      (l = !!p && 603 > parseInt(p[1], 10)))
                                    : (l = !1)),
                            l
                        )
                    }
                    function f(p) {
                        return (c === null && (c = !!p.document.fonts), c)
                    }
                    function m(p, g) {
                        var _ = p.style,
                            b = p.weight
                        if (u === null) {
                            var v = document.createElement('div')
                            try {
                                v.style.font = 'condensed 100px sans-serif'
                            } catch {}
                            u = v.style.font !== ''
                        }
                        return [_, b, u ? p.stretch : '', '100px', g].join(' ')
                    }
                    ;((o.prototype.load = function (p, g) {
                        var _ = this,
                            b = p || 'BESbswy',
                            v = 0,
                            w = g || 3e3,
                            x = new Date().getTime()
                        return new Promise(function (P, y) {
                            if (f(_.context) && !d(_.context)) {
                                var S = new Promise(function (G, N) {
                                        function I() {
                                            new Date().getTime() - x >= w
                                                ? N(
                                                      Error(
                                                          '' +
                                                              w +
                                                              'ms timeout exceeded',
                                                      ),
                                                  )
                                                : _.context.document.fonts
                                                      .load(
                                                          m(
                                                              _,
                                                              '"' +
                                                                  _.family +
                                                                  '"',
                                                          ),
                                                          b,
                                                      )
                                                      .then(function (O) {
                                                          1 <= O.length
                                                              ? G()
                                                              : setTimeout(
                                                                    I,
                                                                    25,
                                                                )
                                                      }, N)
                                        }
                                        I()
                                    }),
                                    R = new Promise(function (G, N) {
                                        v = setTimeout(function () {
                                            N(
                                                Error(
                                                    '' +
                                                        w +
                                                        'ms timeout exceeded',
                                                ),
                                            )
                                        }, w)
                                    })
                                Promise.race([R, S]).then(function () {
                                    ;(clearTimeout(v), P(_))
                                }, y)
                            } else
                                e(function () {
                                    function G() {
                                        var D
                                        ;((D =
                                            (V != -1 && T != -1) ||
                                            (V != -1 && A != -1) ||
                                            (T != -1 && A != -1)) &&
                                            ((D = V != T && V != A && T != A) ||
                                                (h === null &&
                                                    ((D =
                                                        /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(
                                                            window.navigator
                                                                .userAgent,
                                                        )),
                                                    (h =
                                                        !!D &&
                                                        (536 >
                                                            parseInt(
                                                                D[1],
                                                                10,
                                                            ) ||
                                                            (parseInt(
                                                                D[1],
                                                                10,
                                                            ) === 536 &&
                                                                11 >=
                                                                    parseInt(
                                                                        D[2],
                                                                        10,
                                                                    ))))),
                                                (D =
                                                    h &&
                                                    ((V == E &&
                                                        T == E &&
                                                        A == E) ||
                                                        (V == B &&
                                                            T == B &&
                                                            A == B) ||
                                                        (V == C &&
                                                            T == C &&
                                                            A == C)))),
                                            (D = !D)),
                                            D &&
                                                (M.parentNode !== null &&
                                                    M.parentNode.removeChild(M),
                                                clearTimeout(v),
                                                P(_)))
                                    }
                                    function N() {
                                        if (new Date().getTime() - x >= w)
                                            (M.parentNode !== null &&
                                                M.parentNode.removeChild(M),
                                                y(
                                                    Error(
                                                        '' +
                                                            w +
                                                            'ms timeout exceeded',
                                                    ),
                                                ))
                                        else {
                                            var D = _.context.document.hidden
                                            ;((D === !0 || D === void 0) &&
                                                ((V = I.g.offsetWidth),
                                                (T = O.g.offsetWidth),
                                                (A = L.g.offsetWidth),
                                                G()),
                                                (v = setTimeout(N, 50)))
                                        }
                                    }
                                    var I = new i(b),
                                        O = new i(b),
                                        L = new i(b),
                                        V = -1,
                                        T = -1,
                                        A = -1,
                                        E = -1,
                                        B = -1,
                                        C = -1,
                                        M = document.createElement('div')
                                    ;((M.dir = 'ltr'),
                                        r(I, m(_, 'sans-serif')),
                                        r(O, m(_, 'serif')),
                                        r(L, m(_, 'monospace')),
                                        M.appendChild(I.g),
                                        M.appendChild(O.g),
                                        M.appendChild(L.g),
                                        _.context.document.body.appendChild(M),
                                        (E = I.g.offsetWidth),
                                        (B = O.g.offsetWidth),
                                        (C = L.g.offsetWidth),
                                        N(),
                                        a(I, function (D) {
                                            ;((V = D), G())
                                        }),
                                        r(
                                            I,
                                            m(
                                                _,
                                                '"' + _.family + '",sans-serif',
                                            ),
                                        ),
                                        a(O, function (D) {
                                            ;((T = D), G())
                                        }),
                                        r(O, m(_, '"' + _.family + '",serif')),
                                        a(L, function (D) {
                                            ;((A = D), G())
                                        }),
                                        r(
                                            L,
                                            m(
                                                _,
                                                '"' + _.family + '",monospace',
                                            ),
                                        ))
                                })
                        })
                    }),
                        (s.exports = o))
                })()
            })(na)),
        na.exports
    )
}
var om = am()
const hm = Nh(om)
var tr = (s => (
        (s[(s.WEBGL_LEGACY = 0)] = 'WEBGL_LEGACY'),
        (s[(s.WEBGL = 1)] = 'WEBGL'),
        (s[(s.WEBGL2 = 2)] = 'WEBGL2'),
        s
    ))(tr || {}),
    _d = (s => (
        (s[(s.UNKNOWN = 0)] = 'UNKNOWN'),
        (s[(s.WEBGL = 1)] = 'WEBGL'),
        (s[(s.CANVAS = 2)] = 'CANVAS'),
        s
    ))(_d || {}),
    ko = (s => (
        (s[(s.COLOR = 16384)] = 'COLOR'),
        (s[(s.DEPTH = 256)] = 'DEPTH'),
        (s[(s.STENCIL = 1024)] = 'STENCIL'),
        s
    ))(ko || {}),
    ot = (s => (
        (s[(s.NORMAL = 0)] = 'NORMAL'),
        (s[(s.ADD = 1)] = 'ADD'),
        (s[(s.MULTIPLY = 2)] = 'MULTIPLY'),
        (s[(s.SCREEN = 3)] = 'SCREEN'),
        (s[(s.OVERLAY = 4)] = 'OVERLAY'),
        (s[(s.DARKEN = 5)] = 'DARKEN'),
        (s[(s.LIGHTEN = 6)] = 'LIGHTEN'),
        (s[(s.COLOR_DODGE = 7)] = 'COLOR_DODGE'),
        (s[(s.COLOR_BURN = 8)] = 'COLOR_BURN'),
        (s[(s.HARD_LIGHT = 9)] = 'HARD_LIGHT'),
        (s[(s.SOFT_LIGHT = 10)] = 'SOFT_LIGHT'),
        (s[(s.DIFFERENCE = 11)] = 'DIFFERENCE'),
        (s[(s.EXCLUSION = 12)] = 'EXCLUSION'),
        (s[(s.HUE = 13)] = 'HUE'),
        (s[(s.SATURATION = 14)] = 'SATURATION'),
        (s[(s.COLOR = 15)] = 'COLOR'),
        (s[(s.LUMINOSITY = 16)] = 'LUMINOSITY'),
        (s[(s.NORMAL_NPM = 17)] = 'NORMAL_NPM'),
        (s[(s.ADD_NPM = 18)] = 'ADD_NPM'),
        (s[(s.SCREEN_NPM = 19)] = 'SCREEN_NPM'),
        (s[(s.NONE = 20)] = 'NONE'),
        (s[(s.SRC_OVER = 0)] = 'SRC_OVER'),
        (s[(s.SRC_IN = 21)] = 'SRC_IN'),
        (s[(s.SRC_OUT = 22)] = 'SRC_OUT'),
        (s[(s.SRC_ATOP = 23)] = 'SRC_ATOP'),
        (s[(s.DST_OVER = 24)] = 'DST_OVER'),
        (s[(s.DST_IN = 25)] = 'DST_IN'),
        (s[(s.DST_OUT = 26)] = 'DST_OUT'),
        (s[(s.DST_ATOP = 27)] = 'DST_ATOP'),
        (s[(s.ERASE = 26)] = 'ERASE'),
        (s[(s.SUBTRACT = 28)] = 'SUBTRACT'),
        (s[(s.XOR = 29)] = 'XOR'),
        s
    ))(ot || {}),
    Ue = (s => (
        (s[(s.POINTS = 0)] = 'POINTS'),
        (s[(s.LINES = 1)] = 'LINES'),
        (s[(s.LINE_LOOP = 2)] = 'LINE_LOOP'),
        (s[(s.LINE_STRIP = 3)] = 'LINE_STRIP'),
        (s[(s.TRIANGLES = 4)] = 'TRIANGLES'),
        (s[(s.TRIANGLE_STRIP = 5)] = 'TRIANGLE_STRIP'),
        (s[(s.TRIANGLE_FAN = 6)] = 'TRIANGLE_FAN'),
        s
    ))(Ue || {}),
    X = (s => (
        (s[(s.RGBA = 6408)] = 'RGBA'),
        (s[(s.RGB = 6407)] = 'RGB'),
        (s[(s.RG = 33319)] = 'RG'),
        (s[(s.RED = 6403)] = 'RED'),
        (s[(s.RGBA_INTEGER = 36249)] = 'RGBA_INTEGER'),
        (s[(s.RGB_INTEGER = 36248)] = 'RGB_INTEGER'),
        (s[(s.RG_INTEGER = 33320)] = 'RG_INTEGER'),
        (s[(s.RED_INTEGER = 36244)] = 'RED_INTEGER'),
        (s[(s.ALPHA = 6406)] = 'ALPHA'),
        (s[(s.LUMINANCE = 6409)] = 'LUMINANCE'),
        (s[(s.LUMINANCE_ALPHA = 6410)] = 'LUMINANCE_ALPHA'),
        (s[(s.DEPTH_COMPONENT = 6402)] = 'DEPTH_COMPONENT'),
        (s[(s.DEPTH_STENCIL = 34041)] = 'DEPTH_STENCIL'),
        s
    ))(X || {}),
    Tr = (s => (
        (s[(s.TEXTURE_2D = 3553)] = 'TEXTURE_2D'),
        (s[(s.TEXTURE_CUBE_MAP = 34067)] = 'TEXTURE_CUBE_MAP'),
        (s[(s.TEXTURE_2D_ARRAY = 35866)] = 'TEXTURE_2D_ARRAY'),
        (s[(s.TEXTURE_CUBE_MAP_POSITIVE_X = 34069)] =
            'TEXTURE_CUBE_MAP_POSITIVE_X'),
        (s[(s.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070)] =
            'TEXTURE_CUBE_MAP_NEGATIVE_X'),
        (s[(s.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071)] =
            'TEXTURE_CUBE_MAP_POSITIVE_Y'),
        (s[(s.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072)] =
            'TEXTURE_CUBE_MAP_NEGATIVE_Y'),
        (s[(s.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073)] =
            'TEXTURE_CUBE_MAP_POSITIVE_Z'),
        (s[(s.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074)] =
            'TEXTURE_CUBE_MAP_NEGATIVE_Z'),
        s
    ))(Tr || {}),
    at = (s => (
        (s[(s.UNSIGNED_BYTE = 5121)] = 'UNSIGNED_BYTE'),
        (s[(s.UNSIGNED_SHORT = 5123)] = 'UNSIGNED_SHORT'),
        (s[(s.UNSIGNED_SHORT_5_6_5 = 33635)] = 'UNSIGNED_SHORT_5_6_5'),
        (s[(s.UNSIGNED_SHORT_4_4_4_4 = 32819)] = 'UNSIGNED_SHORT_4_4_4_4'),
        (s[(s.UNSIGNED_SHORT_5_5_5_1 = 32820)] = 'UNSIGNED_SHORT_5_5_5_1'),
        (s[(s.UNSIGNED_INT = 5125)] = 'UNSIGNED_INT'),
        (s[(s.UNSIGNED_INT_10F_11F_11F_REV = 35899)] =
            'UNSIGNED_INT_10F_11F_11F_REV'),
        (s[(s.UNSIGNED_INT_2_10_10_10_REV = 33640)] =
            'UNSIGNED_INT_2_10_10_10_REV'),
        (s[(s.UNSIGNED_INT_24_8 = 34042)] = 'UNSIGNED_INT_24_8'),
        (s[(s.UNSIGNED_INT_5_9_9_9_REV = 35902)] = 'UNSIGNED_INT_5_9_9_9_REV'),
        (s[(s.BYTE = 5120)] = 'BYTE'),
        (s[(s.SHORT = 5122)] = 'SHORT'),
        (s[(s.INT = 5124)] = 'INT'),
        (s[(s.FLOAT = 5126)] = 'FLOAT'),
        (s[(s.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269)] =
            'FLOAT_32_UNSIGNED_INT_24_8_REV'),
        (s[(s.HALF_FLOAT = 36193)] = 'HALF_FLOAT'),
        s
    ))(at || {}),
    q = (s => (
        (s[(s.FLOAT = 0)] = 'FLOAT'),
        (s[(s.INT = 1)] = 'INT'),
        (s[(s.UINT = 2)] = 'UINT'),
        s
    ))(q || {}),
    Ze = (s => (
        (s[(s.NEAREST = 0)] = 'NEAREST'),
        (s[(s.LINEAR = 1)] = 'LINEAR'),
        s
    ))(Ze || {}),
    xi = (s => (
        (s[(s.CLAMP = 33071)] = 'CLAMP'),
        (s[(s.REPEAT = 10497)] = 'REPEAT'),
        (s[(s.MIRRORED_REPEAT = 33648)] = 'MIRRORED_REPEAT'),
        s
    ))(xi || {}),
    Xe = (s => (
        (s[(s.OFF = 0)] = 'OFF'),
        (s[(s.POW2 = 1)] = 'POW2'),
        (s[(s.ON = 2)] = 'ON'),
        (s[(s.ON_MANUAL = 3)] = 'ON_MANUAL'),
        s
    ))(Xe || {}),
    Zt = (s => (
        (s[(s.NPM = 0)] = 'NPM'),
        (s[(s.UNPACK = 1)] = 'UNPACK'),
        (s[(s.PMA = 2)] = 'PMA'),
        (s[(s.NO_PREMULTIPLIED_ALPHA = 0)] = 'NO_PREMULTIPLIED_ALPHA'),
        (s[(s.PREMULTIPLY_ON_UPLOAD = 1)] = 'PREMULTIPLY_ON_UPLOAD'),
        (s[(s.PREMULTIPLIED_ALPHA = 2)] = 'PREMULTIPLIED_ALPHA'),
        s
    ))(Zt || {}),
    Fe = (s => (
        (s[(s.NO = 0)] = 'NO'),
        (s[(s.YES = 1)] = 'YES'),
        (s[(s.AUTO = 2)] = 'AUTO'),
        (s[(s.BLEND = 0)] = 'BLEND'),
        (s[(s.CLEAR = 1)] = 'CLEAR'),
        (s[(s.BLIT = 2)] = 'BLIT'),
        s
    ))(Fe || {}),
    Uh = (s => ((s[(s.AUTO = 0)] = 'AUTO'), (s[(s.MANUAL = 1)] = 'MANUAL'), s))(
        Uh || {},
    ),
    fe = (s => (
        (s.LOW = 'lowp'),
        (s.MEDIUM = 'mediump'),
        (s.HIGH = 'highp'),
        s
    ))(fe || {}),
    Nt = (s => (
        (s[(s.NONE = 0)] = 'NONE'),
        (s[(s.SCISSOR = 1)] = 'SCISSOR'),
        (s[(s.STENCIL = 2)] = 'STENCIL'),
        (s[(s.SPRITE = 3)] = 'SPRITE'),
        (s[(s.COLOR = 4)] = 'COLOR'),
        s
    ))(Nt || {}),
    Ft = (s => (
        (s[(s.NONE = 0)] = 'NONE'),
        (s[(s.LOW = 2)] = 'LOW'),
        (s[(s.MEDIUM = 4)] = 'MEDIUM'),
        (s[(s.HIGH = 8)] = 'HIGH'),
        s
    ))(Ft || {}),
    ze = (s => (
        (s[(s.ELEMENT_ARRAY_BUFFER = 34963)] = 'ELEMENT_ARRAY_BUFFER'),
        (s[(s.ARRAY_BUFFER = 34962)] = 'ARRAY_BUFFER'),
        (s[(s.UNIFORM_BUFFER = 35345)] = 'UNIFORM_BUFFER'),
        s
    ))(ze || {})
const lm = {
        createCanvas: (s, t) => {
            const e = document.createElement('canvas')
            return ((e.width = s), (e.height = t), e)
        },
        getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
        getWebGLRenderingContext: () => WebGLRenderingContext,
        getNavigator: () => navigator,
        getBaseUrl: () => document.baseURI ?? window.location.href,
        getFontFaceSet: () => document.fonts,
        fetch: (s, t) => fetch(s, t),
        parseXML: s => new DOMParser().parseFromString(s, 'text/xml'),
    },
    Y = {
        ADAPTER: lm,
        RESOLUTION: 1,
        CREATE_IMAGE_BITMAP: !1,
        ROUND_PIXELS: !1,
    }
var aa = /iPhone/i,
    Kl = /iPod/i,
    Zl = /iPad/i,
    Ql = /\biOS-universal(?:.+)Mac\b/i,
    oa = /\bAndroid(?:.+)Mobile\b/i,
    Jl = /Android/i,
    lr = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i,
    Ps = /Silk/i,
    je = /Windows Phone/i,
    tu = /\bWindows(?:.+)ARM\b/i,
    eu = /BlackBerry/i,
    iu = /BB10/i,
    ru = /Opera Mini/i,
    su = /\b(CriOS|Chrome)(?:.+)Mobile/i,
    nu = /Mobile(?:.+)Firefox\b/i,
    au = function (s) {
        return (
            typeof s < 'u' &&
            s.platform === 'MacIntel' &&
            typeof s.maxTouchPoints == 'number' &&
            s.maxTouchPoints > 1 &&
            typeof MSStream > 'u'
        )
    }
function um(s) {
    return function (t) {
        return t.test(s)
    }
}
function ou(s) {
    var t = { userAgent: '', platform: '', maxTouchPoints: 0 }
    !s && typeof navigator < 'u'
        ? (t = {
              userAgent: navigator.userAgent,
              platform: navigator.platform,
              maxTouchPoints: navigator.maxTouchPoints || 0,
          })
        : typeof s == 'string'
          ? (t.userAgent = s)
          : s &&
            s.userAgent &&
            (t = {
                userAgent: s.userAgent,
                platform: s.platform,
                maxTouchPoints: s.maxTouchPoints || 0,
            })
    var e = t.userAgent,
        i = e.split('[FBAN')
    ;(typeof i[1] < 'u' && (e = i[0]),
        (i = e.split('Twitter')),
        typeof i[1] < 'u' && (e = i[0]))
    var r = um(e),
        n = {
            apple: {
                phone: r(aa) && !r(je),
                ipod: r(Kl),
                tablet: !r(aa) && (r(Zl) || au(t)) && !r(je),
                universal: r(Ql),
                device: (r(aa) || r(Kl) || r(Zl) || r(Ql) || au(t)) && !r(je),
            },
            amazon: {
                phone: r(lr),
                tablet: !r(lr) && r(Ps),
                device: r(lr) || r(Ps),
            },
            android: {
                phone: (!r(je) && r(lr)) || (!r(je) && r(oa)),
                tablet: !r(je) && !r(lr) && !r(oa) && (r(Ps) || r(Jl)),
                device:
                    (!r(je) && (r(lr) || r(Ps) || r(oa) || r(Jl))) ||
                    r(/\bokhttp\b/i),
            },
            windows: { phone: r(je), tablet: r(tu), device: r(je) || r(tu) },
            other: {
                blackberry: r(eu),
                blackberry10: r(iu),
                opera: r(ru),
                firefox: r(nu),
                chrome: r(su),
                device: r(eu) || r(iu) || r(ru) || r(nu) || r(su),
            },
            any: !1,
            phone: !1,
            tablet: !1,
        }
    return (
        (n.any =
            n.apple.device ||
            n.android.device ||
            n.windows.device ||
            n.other.device),
        (n.phone = n.apple.phone || n.android.phone || n.windows.phone),
        (n.tablet = n.apple.tablet || n.android.tablet || n.windows.tablet),
        n
    )
}
const cm = ou.default ?? ou,
    Qe = cm(globalThis.navigator)
Y.RETINA_PREFIX = /@([0-9\.]+)x/
Y.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1
var ha = { exports: {} },
    hu
function dm() {
    return (
        hu ||
            ((hu = 1),
            (function (s) {
                var t = Object.prototype.hasOwnProperty,
                    e = '~'
                function i() {}
                Object.create &&
                    ((i.prototype = Object.create(null)),
                    new i().__proto__ || (e = !1))
                function r(h, l, u) {
                    ;((this.fn = h), (this.context = l), (this.once = u || !1))
                }
                function n(h, l, u, c, d) {
                    if (typeof u != 'function')
                        throw new TypeError('The listener must be a function')
                    var f = new r(u, c || h, d),
                        m = e ? e + l : l
                    return (
                        h._events[m]
                            ? h._events[m].fn
                                ? (h._events[m] = [h._events[m], f])
                                : h._events[m].push(f)
                            : ((h._events[m] = f), h._eventsCount++),
                        h
                    )
                }
                function a(h, l) {
                    --h._eventsCount === 0
                        ? (h._events = new i())
                        : delete h._events[l]
                }
                function o() {
                    ;((this._events = new i()), (this._eventsCount = 0))
                }
                ;((o.prototype.eventNames = function () {
                    var l = [],
                        u,
                        c
                    if (this._eventsCount === 0) return l
                    for (c in (u = this._events))
                        t.call(u, c) && l.push(e ? c.slice(1) : c)
                    return Object.getOwnPropertySymbols
                        ? l.concat(Object.getOwnPropertySymbols(u))
                        : l
                }),
                    (o.prototype.listeners = function (l) {
                        var u = e ? e + l : l,
                            c = this._events[u]
                        if (!c) return []
                        if (c.fn) return [c.fn]
                        for (
                            var d = 0, f = c.length, m = new Array(f);
                            d < f;
                            d++
                        )
                            m[d] = c[d].fn
                        return m
                    }),
                    (o.prototype.listenerCount = function (l) {
                        var u = e ? e + l : l,
                            c = this._events[u]
                        return c ? (c.fn ? 1 : c.length) : 0
                    }),
                    (o.prototype.emit = function (l, u, c, d, f, m) {
                        var p = e ? e + l : l
                        if (!this._events[p]) return !1
                        var g = this._events[p],
                            _ = arguments.length,
                            b,
                            v
                        if (g.fn) {
                            switch (
                                (g.once &&
                                    this.removeListener(l, g.fn, void 0, !0),
                                _)
                            ) {
                                case 1:
                                    return (g.fn.call(g.context), !0)
                                case 2:
                                    return (g.fn.call(g.context, u), !0)
                                case 3:
                                    return (g.fn.call(g.context, u, c), !0)
                                case 4:
                                    return (g.fn.call(g.context, u, c, d), !0)
                                case 5:
                                    return (
                                        g.fn.call(g.context, u, c, d, f),
                                        !0
                                    )
                                case 6:
                                    return (
                                        g.fn.call(g.context, u, c, d, f, m),
                                        !0
                                    )
                            }
                            for (v = 1, b = new Array(_ - 1); v < _; v++)
                                b[v - 1] = arguments[v]
                            g.fn.apply(g.context, b)
                        } else {
                            var w = g.length,
                                x
                            for (v = 0; v < w; v++)
                                switch (
                                    (g[v].once &&
                                        this.removeListener(
                                            l,
                                            g[v].fn,
                                            void 0,
                                            !0,
                                        ),
                                    _)
                                ) {
                                    case 1:
                                        g[v].fn.call(g[v].context)
                                        break
                                    case 2:
                                        g[v].fn.call(g[v].context, u)
                                        break
                                    case 3:
                                        g[v].fn.call(g[v].context, u, c)
                                        break
                                    case 4:
                                        g[v].fn.call(g[v].context, u, c, d)
                                        break
                                    default:
                                        if (!b)
                                            for (
                                                x = 1, b = new Array(_ - 1);
                                                x < _;
                                                x++
                                            )
                                                b[x - 1] = arguments[x]
                                        g[v].fn.apply(g[v].context, b)
                                }
                        }
                        return !0
                    }),
                    (o.prototype.on = function (l, u, c) {
                        return n(this, l, u, c, !1)
                    }),
                    (o.prototype.once = function (l, u, c) {
                        return n(this, l, u, c, !0)
                    }),
                    (o.prototype.removeListener = function (l, u, c, d) {
                        var f = e ? e + l : l
                        if (!this._events[f]) return this
                        if (!u) return (a(this, f), this)
                        var m = this._events[f]
                        if (m.fn)
                            m.fn === u &&
                                (!d || m.once) &&
                                (!c || m.context === c) &&
                                a(this, f)
                        else {
                            for (var p = 0, g = [], _ = m.length; p < _; p++)
                                (m[p].fn !== u ||
                                    (d && !m[p].once) ||
                                    (c && m[p].context !== c)) &&
                                    g.push(m[p])
                            g.length
                                ? (this._events[f] = g.length === 1 ? g[0] : g)
                                : a(this, f)
                        }
                        return this
                    }),
                    (o.prototype.removeAllListeners = function (l) {
                        var u
                        return (
                            l
                                ? ((u = e ? e + l : l),
                                  this._events[u] && a(this, u))
                                : ((this._events = new i()),
                                  (this._eventsCount = 0)),
                            this
                        )
                    }),
                    (o.prototype.off = o.prototype.removeListener),
                    (o.prototype.addListener = o.prototype.on),
                    (o.prefixed = e),
                    (o.EventEmitter = o),
                    (s.exports = o))
            })(ha)),
        ha.exports
    )
}
var fm = dm()
const vs = Nh(fm)
var Rs = { exports: {} },
    lu
function pm() {
    if (lu) return Rs.exports
    ;((lu = 1), (Rs.exports = s), (Rs.exports.default = s))
    function s(T, A, E) {
        E = E || 2
        var B = A && A.length,
            C = B ? A[0] * E : T.length,
            M = t(T, 0, C, E, !0),
            D = []
        if (!M || M.next === M.prev) return D
        var F, H, z, K, Z, J, rt
        if ((B && (M = h(T, A, M, E)), T.length > 80 * E)) {
            ;((F = z = T[0]), (H = K = T[1]))
            for (var W = E; W < C; W += E)
                ((Z = T[W]),
                    (J = T[W + 1]),
                    Z < F && (F = Z),
                    J < H && (H = J),
                    Z > z && (z = Z),
                    J > K && (K = J))
            ;((rt = Math.max(z - F, K - H)), (rt = rt !== 0 ? 32767 / rt : 0))
        }
        return (i(M, D, E, F, H, rt, 0), D)
    }
    function t(T, A, E, B, C) {
        var M, D
        if (C === V(T, A, E, B) > 0)
            for (M = A; M < E; M += B) D = I(M, T[M], T[M + 1], D)
        else for (M = E - B; M >= A; M -= B) D = I(M, T[M], T[M + 1], D)
        return (D && w(D, D.next) && (O(D), (D = D.next)), D)
    }
    function e(T, A) {
        if (!T) return T
        A || (A = T)
        var E = T,
            B
        do
            if (
                ((B = !1),
                !E.steiner && (w(E, E.next) || v(E.prev, E, E.next) === 0))
            ) {
                if ((O(E), (E = A = E.prev), E === E.next)) break
                B = !0
            } else E = E.next
        while (B || E !== A)
        return A
    }
    function i(T, A, E, B, C, M, D) {
        if (T) {
            !D && M && f(T, B, C, M)
            for (var F = T, H, z; T.prev !== T.next; ) {
                if (((H = T.prev), (z = T.next), M ? n(T, B, C, M) : r(T))) {
                    ;(A.push((H.i / E) | 0),
                        A.push((T.i / E) | 0),
                        A.push((z.i / E) | 0),
                        O(T),
                        (T = z.next),
                        (F = z.next))
                    continue
                }
                if (((T = z), T === F)) {
                    D
                        ? D === 1
                            ? ((T = a(e(T), A, E)), i(T, A, E, B, C, M, 2))
                            : D === 2 && o(T, A, E, B, C, M)
                        : i(e(T), A, E, B, C, M, 1)
                    break
                }
            }
        }
    }
    function r(T) {
        var A = T.prev,
            E = T,
            B = T.next
        if (v(A, E, B) >= 0) return !1
        for (
            var C = A.x,
                M = E.x,
                D = B.x,
                F = A.y,
                H = E.y,
                z = B.y,
                K = C < M ? (C < D ? C : D) : M < D ? M : D,
                Z = F < H ? (F < z ? F : z) : H < z ? H : z,
                J = C > M ? (C > D ? C : D) : M > D ? M : D,
                rt = F > H ? (F > z ? F : z) : H > z ? H : z,
                W = B.next;
            W !== A;

        ) {
            if (
                W.x >= K &&
                W.x <= J &&
                W.y >= Z &&
                W.y <= rt &&
                _(C, F, M, H, D, z, W.x, W.y) &&
                v(W.prev, W, W.next) >= 0
            )
                return !1
            W = W.next
        }
        return !0
    }
    function n(T, A, E, B) {
        var C = T.prev,
            M = T,
            D = T.next
        if (v(C, M, D) >= 0) return !1
        for (
            var F = C.x,
                H = M.x,
                z = D.x,
                K = C.y,
                Z = M.y,
                J = D.y,
                rt = F < H ? (F < z ? F : z) : H < z ? H : z,
                W = K < Z ? (K < J ? K : J) : Z < J ? Z : J,
                et = F > H ? (F > z ? F : z) : H > z ? H : z,
                st = K > Z ? (K > J ? K : J) : Z > J ? Z : J,
                ht = p(rt, W, A, E, B),
                pt = p(et, st, A, E, B),
                it = T.prevZ,
                nt = T.nextZ;
            it && it.z >= ht && nt && nt.z <= pt;

        ) {
            if (
                (it.x >= rt &&
                    it.x <= et &&
                    it.y >= W &&
                    it.y <= st &&
                    it !== C &&
                    it !== D &&
                    _(F, K, H, Z, z, J, it.x, it.y) &&
                    v(it.prev, it, it.next) >= 0) ||
                ((it = it.prevZ),
                nt.x >= rt &&
                    nt.x <= et &&
                    nt.y >= W &&
                    nt.y <= st &&
                    nt !== C &&
                    nt !== D &&
                    _(F, K, H, Z, z, J, nt.x, nt.y) &&
                    v(nt.prev, nt, nt.next) >= 0)
            )
                return !1
            nt = nt.nextZ
        }
        for (; it && it.z >= ht; ) {
            if (
                it.x >= rt &&
                it.x <= et &&
                it.y >= W &&
                it.y <= st &&
                it !== C &&
                it !== D &&
                _(F, K, H, Z, z, J, it.x, it.y) &&
                v(it.prev, it, it.next) >= 0
            )
                return !1
            it = it.prevZ
        }
        for (; nt && nt.z <= pt; ) {
            if (
                nt.x >= rt &&
                nt.x <= et &&
                nt.y >= W &&
                nt.y <= st &&
                nt !== C &&
                nt !== D &&
                _(F, K, H, Z, z, J, nt.x, nt.y) &&
                v(nt.prev, nt, nt.next) >= 0
            )
                return !1
            nt = nt.nextZ
        }
        return !0
    }
    function a(T, A, E) {
        var B = T
        do {
            var C = B.prev,
                M = B.next.next
            ;(!w(C, M) &&
                x(C, B, B.next, M) &&
                R(C, M) &&
                R(M, C) &&
                (A.push((C.i / E) | 0),
                A.push((B.i / E) | 0),
                A.push((M.i / E) | 0),
                O(B),
                O(B.next),
                (B = T = M)),
                (B = B.next))
        } while (B !== T)
        return e(B)
    }
    function o(T, A, E, B, C, M) {
        var D = T
        do {
            for (var F = D.next.next; F !== D.prev; ) {
                if (D.i !== F.i && b(D, F)) {
                    var H = N(D, F)
                    ;((D = e(D, D.next)),
                        (H = e(H, H.next)),
                        i(D, A, E, B, C, M, 0),
                        i(H, A, E, B, C, M, 0))
                    return
                }
                F = F.next
            }
            D = D.next
        } while (D !== T)
    }
    function h(T, A, E, B) {
        var C = [],
            M,
            D,
            F,
            H,
            z
        for (M = 0, D = A.length; M < D; M++)
            ((F = A[M] * B),
                (H = M < D - 1 ? A[M + 1] * B : T.length),
                (z = t(T, F, H, B, !1)),
                z === z.next && (z.steiner = !0),
                C.push(g(z)))
        for (C.sort(l), M = 0; M < C.length; M++) E = u(C[M], E)
        return E
    }
    function l(T, A) {
        return T.x - A.x
    }
    function u(T, A) {
        var E = c(T, A)
        if (!E) return A
        var B = N(E, T)
        return (e(B, B.next), e(E, E.next))
    }
    function c(T, A) {
        var E = A,
            B = T.x,
            C = T.y,
            M = -1 / 0,
            D
        do {
            if (C <= E.y && C >= E.next.y && E.next.y !== E.y) {
                var F = E.x + ((C - E.y) * (E.next.x - E.x)) / (E.next.y - E.y)
                if (
                    F <= B &&
                    F > M &&
                    ((M = F), (D = E.x < E.next.x ? E : E.next), F === B)
                )
                    return D
            }
            E = E.next
        } while (E !== A)
        if (!D) return null
        var H = D,
            z = D.x,
            K = D.y,
            Z = 1 / 0,
            J
        E = D
        do
            (B >= E.x &&
                E.x >= z &&
                B !== E.x &&
                _(C < K ? B : M, C, z, K, C < K ? M : B, C, E.x, E.y) &&
                ((J = Math.abs(C - E.y) / (B - E.x)),
                R(E, T) &&
                    (J < Z ||
                        (J === Z && (E.x > D.x || (E.x === D.x && d(D, E))))) &&
                    ((D = E), (Z = J))),
                (E = E.next))
        while (E !== H)
        return D
    }
    function d(T, A) {
        return v(T.prev, T, A.prev) < 0 && v(A.next, T, T.next) < 0
    }
    function f(T, A, E, B) {
        var C = T
        do
            (C.z === 0 && (C.z = p(C.x, C.y, A, E, B)),
                (C.prevZ = C.prev),
                (C.nextZ = C.next),
                (C = C.next))
        while (C !== T)
        ;((C.prevZ.nextZ = null), (C.prevZ = null), m(C))
    }
    function m(T) {
        var A,
            E,
            B,
            C,
            M,
            D,
            F,
            H,
            z = 1
        do {
            for (E = T, T = null, M = null, D = 0; E; ) {
                for (
                    D++, B = E, F = 0, A = 0;
                    A < z && (F++, (B = B.nextZ), !!B);
                    A++
                );
                for (H = z; F > 0 || (H > 0 && B); )
                    (F !== 0 && (H === 0 || !B || E.z <= B.z)
                        ? ((C = E), (E = E.nextZ), F--)
                        : ((C = B), (B = B.nextZ), H--),
                        M ? (M.nextZ = C) : (T = C),
                        (C.prevZ = M),
                        (M = C))
                E = B
            }
            ;((M.nextZ = null), (z *= 2))
        } while (D > 1)
        return T
    }
    function p(T, A, E, B, C) {
        return (
            (T = ((T - E) * C) | 0),
            (A = ((A - B) * C) | 0),
            (T = (T | (T << 8)) & 16711935),
            (T = (T | (T << 4)) & 252645135),
            (T = (T | (T << 2)) & 858993459),
            (T = (T | (T << 1)) & 1431655765),
            (A = (A | (A << 8)) & 16711935),
            (A = (A | (A << 4)) & 252645135),
            (A = (A | (A << 2)) & 858993459),
            (A = (A | (A << 1)) & 1431655765),
            T | (A << 1)
        )
    }
    function g(T) {
        var A = T,
            E = T
        do ((A.x < E.x || (A.x === E.x && A.y < E.y)) && (E = A), (A = A.next))
        while (A !== T)
        return E
    }
    function _(T, A, E, B, C, M, D, F) {
        return (
            (C - D) * (A - F) >= (T - D) * (M - F) &&
            (T - D) * (B - F) >= (E - D) * (A - F) &&
            (E - D) * (M - F) >= (C - D) * (B - F)
        )
    }
    function b(T, A) {
        return (
            T.next.i !== A.i &&
            T.prev.i !== A.i &&
            !S(T, A) &&
            ((R(T, A) &&
                R(A, T) &&
                G(T, A) &&
                (v(T.prev, T, A.prev) || v(T, A.prev, A))) ||
                (w(T, A) &&
                    v(T.prev, T, T.next) > 0 &&
                    v(A.prev, A, A.next) > 0))
        )
    }
    function v(T, A, E) {
        return (A.y - T.y) * (E.x - A.x) - (A.x - T.x) * (E.y - A.y)
    }
    function w(T, A) {
        return T.x === A.x && T.y === A.y
    }
    function x(T, A, E, B) {
        var C = y(v(T, A, E)),
            M = y(v(T, A, B)),
            D = y(v(E, B, T)),
            F = y(v(E, B, A))
        return !!(
            (C !== M && D !== F) ||
            (C === 0 && P(T, E, A)) ||
            (M === 0 && P(T, B, A)) ||
            (D === 0 && P(E, T, B)) ||
            (F === 0 && P(E, A, B))
        )
    }
    function P(T, A, E) {
        return (
            A.x <= Math.max(T.x, E.x) &&
            A.x >= Math.min(T.x, E.x) &&
            A.y <= Math.max(T.y, E.y) &&
            A.y >= Math.min(T.y, E.y)
        )
    }
    function y(T) {
        return T > 0 ? 1 : T < 0 ? -1 : 0
    }
    function S(T, A) {
        var E = T
        do {
            if (
                E.i !== T.i &&
                E.next.i !== T.i &&
                E.i !== A.i &&
                E.next.i !== A.i &&
                x(E, E.next, T, A)
            )
                return !0
            E = E.next
        } while (E !== T)
        return !1
    }
    function R(T, A) {
        return v(T.prev, T, T.next) < 0
            ? v(T, A, T.next) >= 0 && v(T, T.prev, A) >= 0
            : v(T, A, T.prev) < 0 || v(T, T.next, A) < 0
    }
    function G(T, A) {
        var E = T,
            B = !1,
            C = (T.x + A.x) / 2,
            M = (T.y + A.y) / 2
        do
            (E.y > M != E.next.y > M &&
                E.next.y !== E.y &&
                C < ((E.next.x - E.x) * (M - E.y)) / (E.next.y - E.y) + E.x &&
                (B = !B),
                (E = E.next))
        while (E !== T)
        return B
    }
    function N(T, A) {
        var E = new L(T.i, T.x, T.y),
            B = new L(A.i, A.x, A.y),
            C = T.next,
            M = A.prev
        return (
            (T.next = A),
            (A.prev = T),
            (E.next = C),
            (C.prev = E),
            (B.next = E),
            (E.prev = B),
            (M.next = B),
            (B.prev = M),
            B
        )
    }
    function I(T, A, E, B) {
        var C = new L(T, A, E)
        return (
            B
                ? ((C.next = B.next),
                  (C.prev = B),
                  (B.next.prev = C),
                  (B.next = C))
                : ((C.prev = C), (C.next = C)),
            C
        )
    }
    function O(T) {
        ;((T.next.prev = T.prev),
            (T.prev.next = T.next),
            T.prevZ && (T.prevZ.nextZ = T.nextZ),
            T.nextZ && (T.nextZ.prevZ = T.prevZ))
    }
    function L(T, A, E) {
        ;((this.i = T),
            (this.x = A),
            (this.y = E),
            (this.prev = null),
            (this.next = null),
            (this.z = 0),
            (this.prevZ = null),
            (this.nextZ = null),
            (this.steiner = !1))
    }
    s.deviation = function (T, A, E, B) {
        var C = A && A.length,
            M = C ? A[0] * E : T.length,
            D = Math.abs(V(T, 0, M, E))
        if (C)
            for (var F = 0, H = A.length; F < H; F++) {
                var z = A[F] * E,
                    K = F < H - 1 ? A[F + 1] * E : T.length
                D -= Math.abs(V(T, z, K, E))
            }
        var Z = 0
        for (F = 0; F < B.length; F += 3) {
            var J = B[F] * E,
                rt = B[F + 1] * E,
                W = B[F + 2] * E
            Z += Math.abs(
                (T[J] - T[W]) * (T[rt + 1] - T[J + 1]) -
                    (T[J] - T[rt]) * (T[W + 1] - T[J + 1]),
            )
        }
        return D === 0 && Z === 0 ? 0 : Math.abs((Z - D) / D)
    }
    function V(T, A, E, B) {
        for (var C = 0, M = A, D = E - B; M < E; M += B)
            ((C += (T[D] - T[M]) * (T[M + 1] + T[D + 1])), (D = M))
        return C
    }
    return (
        (s.flatten = function (T) {
            for (
                var A = T[0][0].length,
                    E = { vertices: [], holes: [], dimensions: A },
                    B = 0,
                    C = 0;
                C < T.length;
                C++
            ) {
                for (var M = 0; M < T[C].length; M++)
                    for (var D = 0; D < A; D++) E.vertices.push(T[C][M][D])
                C > 0 && ((B += T[C - 1].length), E.holes.push(B))
            }
            return E
        }),
        Rs.exports
    )
}
var mm = pm()
const gm = Nh(mm)
var Ri = {},
    Yr = { exports: {} }
/*! https://mths.be/punycode v1.4.1 by @mathias */ var _m = Yr.exports,
    uu
function ym() {
    return (
        uu ||
            ((uu = 1),
            (function (s, t) {
                ;(function (e) {
                    var i = t && !t.nodeType && t,
                        r = s && !s.nodeType && s,
                        n = typeof cn == 'object' && cn
                    ;(n.global === n || n.window === n || n.self === n) &&
                        (e = n)
                    var a,
                        o = 2147483647,
                        h = 36,
                        l = 1,
                        u = 26,
                        c = 38,
                        d = 700,
                        f = 72,
                        m = 128,
                        p = '-',
                        g = /^xn--/,
                        _ = /[^\x20-\x7E]/,
                        b = /[\x2E\u3002\uFF0E\uFF61]/g,
                        v = {
                            overflow:
                                'Overflow: input needs wider integers to process',
                            'not-basic':
                                'Illegal input >= 0x80 (not a basic code point)',
                            'invalid-input': 'Invalid input',
                        },
                        w = h - l,
                        x = Math.floor,
                        P = String.fromCharCode,
                        y
                    function S(C) {
                        throw new RangeError(v[C])
                    }
                    function R(C, M) {
                        for (var D = C.length, F = []; D--; ) F[D] = M(C[D])
                        return F
                    }
                    function G(C, M) {
                        var D = C.split('@'),
                            F = ''
                        ;(D.length > 1 && ((F = D[0] + '@'), (C = D[1])),
                            (C = C.replace(b, '.')))
                        var H = C.split('.'),
                            z = R(H, M).join('.')
                        return F + z
                    }
                    function N(C) {
                        for (var M = [], D = 0, F = C.length, H, z; D < F; )
                            ((H = C.charCodeAt(D++)),
                                H >= 55296 && H <= 56319 && D < F
                                    ? ((z = C.charCodeAt(D++)),
                                      (z & 64512) == 56320
                                          ? M.push(
                                                ((H & 1023) << 10) +
                                                    (z & 1023) +
                                                    65536,
                                            )
                                          : (M.push(H), D--))
                                    : M.push(H))
                        return M
                    }
                    function I(C) {
                        return R(C, function (M) {
                            var D = ''
                            return (
                                M > 65535 &&
                                    ((M -= 65536),
                                    (D += P(((M >>> 10) & 1023) | 55296)),
                                    (M = 56320 | (M & 1023))),
                                (D += P(M)),
                                D
                            )
                        }).join('')
                    }
                    function O(C) {
                        return C - 48 < 10
                            ? C - 22
                            : C - 65 < 26
                              ? C - 65
                              : C - 97 < 26
                                ? C - 97
                                : h
                    }
                    function L(C, M) {
                        return C + 22 + 75 * (C < 26) - ((M != 0) << 5)
                    }
                    function V(C, M, D) {
                        var F = 0
                        for (
                            C = D ? x(C / d) : C >> 1, C += x(C / M);
                            C > (w * u) >> 1;
                            F += h
                        )
                            C = x(C / w)
                        return x(F + ((w + 1) * C) / (C + c))
                    }
                    function T(C) {
                        var M = [],
                            D = C.length,
                            F,
                            H = 0,
                            z = m,
                            K = f,
                            Z,
                            J,
                            rt,
                            W,
                            et,
                            st,
                            ht,
                            pt,
                            it
                        for (
                            Z = C.lastIndexOf(p), Z < 0 && (Z = 0), J = 0;
                            J < Z;
                            ++J
                        )
                            (C.charCodeAt(J) >= 128 && S('not-basic'),
                                M.push(C.charCodeAt(J)))
                        for (rt = Z > 0 ? Z + 1 : 0; rt < D; ) {
                            for (
                                W = H, et = 1, st = h;
                                rt >= D && S('invalid-input'),
                                    (ht = O(C.charCodeAt(rt++))),
                                    (ht >= h || ht > x((o - H) / et)) &&
                                        S('overflow'),
                                    (H += ht * et),
                                    (pt =
                                        st <= K ? l : st >= K + u ? u : st - K),
                                    !(ht < pt);
                                st += h
                            )
                                ((it = h - pt),
                                    et > x(o / it) && S('overflow'),
                                    (et *= it))
                            ;((F = M.length + 1),
                                (K = V(H - W, F, W == 0)),
                                x(H / F) > o - z && S('overflow'),
                                (z += x(H / F)),
                                (H %= F),
                                M.splice(H++, 0, z))
                        }
                        return I(M)
                    }
                    function A(C) {
                        var M,
                            D,
                            F,
                            H,
                            z,
                            K,
                            Z,
                            J,
                            rt,
                            W,
                            et,
                            st = [],
                            ht,
                            pt,
                            it,
                            nt
                        for (
                            C = N(C), ht = C.length, M = m, D = 0, z = f, K = 0;
                            K < ht;
                            ++K
                        )
                            ((et = C[K]), et < 128 && st.push(P(et)))
                        for (F = H = st.length, H && st.push(p); F < ht; ) {
                            for (Z = o, K = 0; K < ht; ++K)
                                ((et = C[K]), et >= M && et < Z && (Z = et))
                            for (
                                pt = F + 1,
                                    Z - M > x((o - D) / pt) && S('overflow'),
                                    D += (Z - M) * pt,
                                    M = Z,
                                    K = 0;
                                K < ht;
                                ++K
                            )
                                if (
                                    ((et = C[K]),
                                    et < M && ++D > o && S('overflow'),
                                    et == M)
                                ) {
                                    for (
                                        J = D, rt = h;
                                        (W =
                                            rt <= z
                                                ? l
                                                : rt >= z + u
                                                  ? u
                                                  : rt - z),
                                            !(J < W);
                                        rt += h
                                    )
                                        ((nt = J - W),
                                            (it = h - W),
                                            st.push(P(L(W + (nt % it), 0))),
                                            (J = x(nt / it)))
                                    ;(st.push(P(L(J, 0))),
                                        (z = V(D, pt, F == H)),
                                        (D = 0),
                                        ++F)
                                }
                            ;(++D, ++M)
                        }
                        return st.join('')
                    }
                    function E(C) {
                        return G(C, function (M) {
                            return g.test(M) ? T(M.slice(4).toLowerCase()) : M
                        })
                    }
                    function B(C) {
                        return G(C, function (M) {
                            return _.test(M) ? 'xn--' + A(M) : M
                        })
                    }
                    if (
                        ((a = {
                            version: '1.4.1',
                            ucs2: { decode: N, encode: I },
                            decode: T,
                            encode: A,
                            toASCII: B,
                            toUnicode: E,
                        }),
                        i && r)
                    )
                        if (s.exports == i) r.exports = a
                        else for (y in a) a.hasOwnProperty(y) && (i[y] = a[y])
                    else e.punycode = a
                })(_m)
            })(Yr, Yr.exports)),
        Yr.exports
    )
}
var la, cu
function Ur() {
    return (cu || ((cu = 1), (la = TypeError)), la)
}
const vm = {},
    xm = Object.freeze(
        Object.defineProperty(
            { __proto__: null, default: vm },
            Symbol.toStringTag,
            { value: 'Module' },
        ),
    ),
    bm = nm(xm)
var ua, du
function Bn() {
    if (du) return ua
    du = 1
    var s = typeof Map == 'function' && Map.prototype,
        t =
            Object.getOwnPropertyDescriptor && s
                ? Object.getOwnPropertyDescriptor(Map.prototype, 'size')
                : null,
        e = s && t && typeof t.get == 'function' ? t.get : null,
        i = s && Map.prototype.forEach,
        r = typeof Set == 'function' && Set.prototype,
        n =
            Object.getOwnPropertyDescriptor && r
                ? Object.getOwnPropertyDescriptor(Set.prototype, 'size')
                : null,
        a = r && n && typeof n.get == 'function' ? n.get : null,
        o = r && Set.prototype.forEach,
        h = typeof WeakMap == 'function' && WeakMap.prototype,
        l = h ? WeakMap.prototype.has : null,
        u = typeof WeakSet == 'function' && WeakSet.prototype,
        c = u ? WeakSet.prototype.has : null,
        d = typeof WeakRef == 'function' && WeakRef.prototype,
        f = d ? WeakRef.prototype.deref : null,
        m = Boolean.prototype.valueOf,
        p = Object.prototype.toString,
        g = Function.prototype.toString,
        _ = String.prototype.match,
        b = String.prototype.slice,
        v = String.prototype.replace,
        w = String.prototype.toUpperCase,
        x = String.prototype.toLowerCase,
        P = RegExp.prototype.test,
        y = Array.prototype.concat,
        S = Array.prototype.join,
        R = Array.prototype.slice,
        G = Math.floor,
        N = typeof BigInt == 'function' ? BigInt.prototype.valueOf : null,
        I = Object.getOwnPropertySymbols,
        O =
            typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? Symbol.prototype.toString
                : null,
        L = typeof Symbol == 'function' && typeof Symbol.iterator == 'object',
        V =
            typeof Symbol == 'function' &&
            Symbol.toStringTag &&
            (typeof Symbol.toStringTag === L || !0)
                ? Symbol.toStringTag
                : null,
        T = Object.prototype.propertyIsEnumerable,
        A =
            (typeof Reflect == 'function'
                ? Reflect.getPrototypeOf
                : Object.getPrototypeOf) ||
            ([].__proto__ === Array.prototype
                ? function (k) {
                      return k.__proto__
                  }
                : null)
    function E(k, U) {
        if (
            k === 1 / 0 ||
            k === -1 / 0 ||
            k !== k ||
            (k && k > -1e3 && k < 1e3) ||
            P.call(/e/, U)
        )
            return U
        var gt = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g
        if (typeof k == 'number') {
            var xt = k < 0 ? -G(-k) : G(k)
            if (xt !== k) {
                var wt = String(xt),
                    ct = b.call(U, wt.length + 1)
                return (
                    v.call(wt, gt, '$&_') +
                    '.' +
                    v.call(v.call(ct, /([0-9]{3})/g, '$&_'), /_$/, '')
                )
            }
        }
        return v.call(U, gt, '$&_')
    }
    var B = bm,
        C = B.custom,
        M = pt(C) ? C : null,
        D = { __proto__: null, double: '"', single: "'" },
        F = { __proto__: null, double: /(["\\])/g, single: /(['\\])/g }
    ua = function k(U, gt, xt, wt) {
        var ct = gt || {}
        if (Mt(ct, 'quoteStyle') && !Mt(D, ct.quoteStyle))
            throw new TypeError(
                'option "quoteStyle" must be "single" or "double"',
            )
        if (
            Mt(ct, 'maxStringLength') &&
            (typeof ct.maxStringLength == 'number'
                ? ct.maxStringLength < 0 && ct.maxStringLength !== 1 / 0
                : ct.maxStringLength !== null)
        )
            throw new TypeError(
                'option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`',
            )
        var hi = Mt(ct, 'customInspect') ? ct.customInspect : !0
        if (typeof hi != 'boolean' && hi !== 'symbol')
            throw new TypeError(
                'option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`',
            )
        if (
            Mt(ct, 'indent') &&
            ct.indent !== null &&
            ct.indent !== '	' &&
            !(parseInt(ct.indent, 10) === ct.indent && ct.indent > 0)
        )
            throw new TypeError(
                'option "indent" must be "\\t", an integer > 0, or `null`',
            )
        if (
            Mt(ct, 'numericSeparator') &&
            typeof ct.numericSeparator != 'boolean'
        )
            throw new TypeError(
                'option "numericSeparator", if provided, must be `true` or `false`',
            )
        var Pi = ct.numericSeparator
        if (typeof U > 'u') return 'undefined'
        if (U === null) return 'null'
        if (typeof U == 'boolean') return U ? 'true' : 'false'
        if (typeof U == 'string') return Ul(U, ct)
        if (typeof U == 'number') {
            if (U === 0) return 1 / 0 / U > 0 ? '0' : '-0'
            var re = String(U)
            return Pi ? E(U, re) : re
        }
        if (typeof U == 'bigint') {
            var li = String(U) + 'n'
            return Pi ? E(U, li) : li
        }
        var Zn = typeof ct.depth > 'u' ? 5 : ct.depth
        if (
            (typeof xt > 'u' && (xt = 0),
            xt >= Zn && Zn > 0 && typeof U == 'object')
        )
            return Z(U) ? '[Array]' : '[Object]'
        var or = im(ct, xt)
        if (typeof wt > 'u') wt = []
        else if (oi(wt, U) >= 0) return '[Circular]'
        function ve(hr, Cs, sm) {
            if ((Cs && ((wt = R.call(wt)), wt.push(Cs)), sm)) {
                var ql = { depth: ct.depth }
                return (
                    Mt(ct, 'quoteStyle') && (ql.quoteStyle = ct.quoteStyle),
                    k(hr, ql, xt + 1, wt)
                )
            }
            return k(hr, ct, xt + 1, wt)
        }
        if (typeof U == 'function' && !rt(U)) {
            var Hl = rr(U),
                zl = As(U, ve)
            return (
                '[Function' +
                (Hl ? ': ' + Hl : ' (anonymous)') +
                ']' +
                (zl.length > 0 ? ' { ' + S.call(zl, ', ') + ' }' : '')
            )
        }
        if (pt(U)) {
            var Vl = L
                ? v.call(String(U), /^(Symbol\(.*\))_[^)]*$/, '$1')
                : O.call(U)
            return typeof U == 'object' && !L ? zr(Vl) : Vl
        }
        if (Jp(U)) {
            for (
                var Vr = '<' + x.call(String(U.nodeName)),
                    Qn = U.attributes || [],
                    Ss = 0;
                Ss < Qn.length;
                Ss++
            )
                Vr += ' ' + Qn[Ss].name + '=' + H(z(Qn[Ss].value), 'double', ct)
            return (
                (Vr += '>'),
                U.childNodes && U.childNodes.length && (Vr += '...'),
                (Vr += '</' + x.call(String(U.nodeName)) + '>'),
                Vr
            )
        }
        if (Z(U)) {
            if (U.length === 0) return '[]'
            var Jn = As(U, ve)
            return or && !em(Jn)
                ? '[' + Kn(Jn, or) + ']'
                : '[ ' + S.call(Jn, ', ') + ' ]'
        }
        if (W(U)) {
            var ta = As(U, ve)
            return !('cause' in Error.prototype) &&
                'cause' in U &&
                !T.call(U, 'cause')
                ? '{ [' +
                      String(U) +
                      '] ' +
                      S.call(y.call('[cause]: ' + ve(U.cause), ta), ', ') +
                      ' }'
                : ta.length === 0
                  ? '[' + String(U) + ']'
                  : '{ [' + String(U) + '] ' + S.call(ta, ', ') + ' }'
        }
        if (typeof U == 'object' && hi) {
            if (M && typeof U[M] == 'function' && B)
                return B(U, { depth: Zn - xt })
            if (hi !== 'symbol' && typeof U.inspect == 'function')
                return U.inspect()
        }
        if (ye(U)) {
            var Xl = []
            return (
                i &&
                    i.call(U, function (hr, Cs) {
                        Xl.push(ve(Cs, U, !0) + ' => ' + ve(hr, U))
                    }),
                Gl('Map', e.call(U), Xl, or)
            )
        }
        if (ar(U)) {
            var Wl = []
            return (
                o &&
                    o.call(U, function (hr) {
                        Wl.push(ve(hr, U))
                    }),
                Gl('Set', a.call(U), Wl, or)
            )
        }
        if (sr(U)) return Yn('WeakMap')
        if (Qp(U)) return Yn('WeakSet')
        if (nr(U)) return Yn('WeakRef')
        if (st(U)) return zr(ve(Number(U)))
        if (it(U)) return zr(ve(N.call(U)))
        if (ht(U)) return zr(m.call(U))
        if (et(U)) return zr(ve(String(U)))
        if (typeof window < 'u' && U === window) return '{ [object Window] }'
        if (
            (typeof globalThis < 'u' && U === globalThis) ||
            (typeof cn < 'u' && U === cn)
        )
            return '{ [object globalThis] }'
        if (!J(U) && !rt(U)) {
            var ea = As(U, ve),
                $l = A
                    ? A(U) === Object.prototype
                    : U instanceof Object || U.constructor === Object,
                ia = U instanceof Object ? '' : 'null prototype',
                jl =
                    !$l && V && Object(U) === U && V in U
                        ? b.call(kt(U), 8, -1)
                        : ia
                          ? 'Object'
                          : '',
                rm =
                    $l || typeof U.constructor != 'function'
                        ? ''
                        : U.constructor.name
                          ? U.constructor.name + ' '
                          : '',
                ra =
                    rm +
                    (jl || ia
                        ? '[' +
                          S.call(y.call([], jl || [], ia || []), ': ') +
                          '] '
                        : '')
            return ea.length === 0
                ? ra + '{}'
                : or
                  ? ra + '{' + Kn(ea, or) + '}'
                  : ra + '{ ' + S.call(ea, ', ') + ' }'
        }
        return String(U)
    }
    function H(k, U, gt) {
        var xt = gt.quoteStyle || U,
            wt = D[xt]
        return wt + k + wt
    }
    function z(k) {
        return v.call(String(k), /"/g, '&quot;')
    }
    function K(k) {
        return !V || !(typeof k == 'object' && (V in k || typeof k[V] < 'u'))
    }
    function Z(k) {
        return kt(k) === '[object Array]' && K(k)
    }
    function J(k) {
        return kt(k) === '[object Date]' && K(k)
    }
    function rt(k) {
        return kt(k) === '[object RegExp]' && K(k)
    }
    function W(k) {
        return kt(k) === '[object Error]' && K(k)
    }
    function et(k) {
        return kt(k) === '[object String]' && K(k)
    }
    function st(k) {
        return kt(k) === '[object Number]' && K(k)
    }
    function ht(k) {
        return kt(k) === '[object Boolean]' && K(k)
    }
    function pt(k) {
        if (L) return k && typeof k == 'object' && k instanceof Symbol
        if (typeof k == 'symbol') return !0
        if (!k || typeof k != 'object' || !O) return !1
        try {
            return (O.call(k), !0)
        } catch {}
        return !1
    }
    function it(k) {
        if (!k || typeof k != 'object' || !N) return !1
        try {
            return (N.call(k), !0)
        } catch {}
        return !1
    }
    var nt =
        Object.prototype.hasOwnProperty ||
        function (k) {
            return k in this
        }
    function Mt(k, U) {
        return nt.call(k, U)
    }
    function kt(k) {
        return p.call(k)
    }
    function rr(k) {
        if (k.name) return k.name
        var U = _.call(g.call(k), /^function\s*([\w$]+)/)
        return U ? U[1] : null
    }
    function oi(k, U) {
        if (k.indexOf) return k.indexOf(U)
        for (var gt = 0, xt = k.length; gt < xt; gt++)
            if (k[gt] === U) return gt
        return -1
    }
    function ye(k) {
        if (!e || !k || typeof k != 'object') return !1
        try {
            e.call(k)
            try {
                a.call(k)
            } catch {
                return !0
            }
            return k instanceof Map
        } catch {}
        return !1
    }
    function sr(k) {
        if (!l || !k || typeof k != 'object') return !1
        try {
            l.call(k, l)
            try {
                c.call(k, c)
            } catch {
                return !0
            }
            return k instanceof WeakMap
        } catch {}
        return !1
    }
    function nr(k) {
        if (!f || !k || typeof k != 'object') return !1
        try {
            return (f.call(k), !0)
        } catch {}
        return !1
    }
    function ar(k) {
        if (!a || !k || typeof k != 'object') return !1
        try {
            a.call(k)
            try {
                e.call(k)
            } catch {
                return !0
            }
            return k instanceof Set
        } catch {}
        return !1
    }
    function Qp(k) {
        if (!c || !k || typeof k != 'object') return !1
        try {
            c.call(k, c)
            try {
                l.call(k, l)
            } catch {
                return !0
            }
            return k instanceof WeakSet
        } catch {}
        return !1
    }
    function Jp(k) {
        return !k || typeof k != 'object'
            ? !1
            : typeof HTMLElement < 'u' && k instanceof HTMLElement
              ? !0
              : typeof k.nodeName == 'string' &&
                typeof k.getAttribute == 'function'
    }
    function Ul(k, U) {
        if (k.length > U.maxStringLength) {
            var gt = k.length - U.maxStringLength,
                xt = '... ' + gt + ' more character' + (gt > 1 ? 's' : '')
            return Ul(b.call(k, 0, U.maxStringLength), U) + xt
        }
        var wt = F[U.quoteStyle || 'single']
        wt.lastIndex = 0
        var ct = v.call(v.call(k, wt, '\\$1'), /[\x00-\x1f]/g, tm)
        return H(ct, 'single', U)
    }
    function tm(k) {
        var U = k.charCodeAt(0),
            gt = { 8: 'b', 9: 't', 10: 'n', 12: 'f', 13: 'r' }[U]
        return gt
            ? '\\' + gt
            : '\\x' + (U < 16 ? '0' : '') + w.call(U.toString(16))
    }
    function zr(k) {
        return 'Object(' + k + ')'
    }
    function Yn(k) {
        return k + ' { ? }'
    }
    function Gl(k, U, gt, xt) {
        var wt = xt ? Kn(gt, xt) : S.call(gt, ', ')
        return k + ' (' + U + ') {' + wt + '}'
    }
    function em(k) {
        for (var U = 0; U < k.length; U++)
            if (
                oi(
                    k[U],
                    `
`,
                ) >= 0
            )
                return !1
        return !0
    }
    function im(k, U) {
        var gt
        if (k.indent === '	') gt = '	'
        else if (typeof k.indent == 'number' && k.indent > 0)
            gt = S.call(Array(k.indent + 1), ' ')
        else return null
        return { base: gt, prev: S.call(Array(U + 1), gt) }
    }
    function Kn(k, U) {
        if (k.length === 0) return ''
        var gt =
            `
` +
            U.prev +
            U.base
        return (
            gt +
            S.call(k, ',' + gt) +
            `
` +
            U.prev
        )
    }
    function As(k, U) {
        var gt = Z(k),
            xt = []
        if (gt) {
            xt.length = k.length
            for (var wt = 0; wt < k.length; wt++)
                xt[wt] = Mt(k, wt) ? U(k[wt], k) : ''
        }
        var ct = typeof I == 'function' ? I(k) : [],
            hi
        if (L) {
            hi = {}
            for (var Pi = 0; Pi < ct.length; Pi++) hi['$' + ct[Pi]] = ct[Pi]
        }
        for (var re in k)
            Mt(k, re) &&
                ((gt && String(Number(re)) === re && re < k.length) ||
                    (L && hi['$' + re] instanceof Symbol) ||
                    (P.call(/[^\w$]/, re)
                        ? xt.push(U(re, k) + ': ' + U(k[re], k))
                        : xt.push(re + ': ' + U(k[re], k))))
        if (typeof I == 'function')
            for (var li = 0; li < ct.length; li++)
                T.call(k, ct[li]) &&
                    xt.push('[' + U(ct[li]) + ']: ' + U(k[ct[li]], k))
        return xt
    }
    return ua
}
var ca, fu
function wm() {
    if (fu) return ca
    fu = 1
    var s = Bn(),
        t = Ur(),
        e = function (o, h, l) {
            for (var u = o, c; (c = u.next) != null; u = c)
                if (c.key === h)
                    return (
                        (u.next = c.next),
                        l || ((c.next = o.next), (o.next = c)),
                        c
                    )
        },
        i = function (o, h) {
            if (o) {
                var l = e(o, h)
                return l && l.value
            }
        },
        r = function (o, h, l) {
            var u = e(o, h)
            u ? (u.value = l) : (o.next = { key: h, next: o.next, value: l })
        },
        n = function (o, h) {
            return o ? !!e(o, h) : !1
        },
        a = function (o, h) {
            if (o) return e(o, h, !0)
        }
    return (
        (ca = function () {
            var h,
                l = {
                    assert: function (u) {
                        if (!l.has(u))
                            throw new t('Side channel does not contain ' + s(u))
                    },
                    delete: function (u) {
                        var c = h && h.next,
                            d = a(h, u)
                        return (d && c && c === d && (h = void 0), !!d)
                    },
                    get: function (u) {
                        return i(h, u)
                    },
                    has: function (u) {
                        return n(h, u)
                    },
                    set: function (u, c) {
                        ;(h || (h = { next: void 0 }), r(h, u, c))
                    },
                }
            return l
        }),
        ca
    )
}
var da, pu
function yd() {
    return (pu || ((pu = 1), (da = Object)), da)
}
var fa, mu
function Tm() {
    return (mu || ((mu = 1), (fa = Error)), fa)
}
var pa, gu
function Em() {
    return (gu || ((gu = 1), (pa = EvalError)), pa)
}
var ma, _u
function Am() {
    return (_u || ((_u = 1), (ma = RangeError)), ma)
}
var ga, yu
function Sm() {
    return (yu || ((yu = 1), (ga = ReferenceError)), ga)
}
var _a, vu
function Cm() {
    return (vu || ((vu = 1), (_a = SyntaxError)), _a)
}
var ya, xu
function Pm() {
    return (xu || ((xu = 1), (ya = URIError)), ya)
}
var va, bu
function Rm() {
    return (bu || ((bu = 1), (va = Math.abs)), va)
}
var xa, wu
function Im() {
    return (wu || ((wu = 1), (xa = Math.floor)), xa)
}
var ba, Tu
function Mm() {
    return (Tu || ((Tu = 1), (ba = Math.max)), ba)
}
var wa, Eu
function Dm() {
    return (Eu || ((Eu = 1), (wa = Math.min)), wa)
}
var Ta, Au
function Bm() {
    return (Au || ((Au = 1), (Ta = Math.pow)), Ta)
}
var Ea, Su
function Om() {
    return (Su || ((Su = 1), (Ea = Math.round)), Ea)
}
var Aa, Cu
function Fm() {
    return (
        Cu ||
            ((Cu = 1),
            (Aa =
                Number.isNaN ||
                function (t) {
                    return t !== t
                })),
        Aa
    )
}
var Sa, Pu
function Lm() {
    if (Pu) return Sa
    Pu = 1
    var s = Fm()
    return (
        (Sa = function (e) {
            return s(e) || e === 0 ? e : e < 0 ? -1 : 1
        }),
        Sa
    )
}
var Ca, Ru
function km() {
    return (Ru || ((Ru = 1), (Ca = Object.getOwnPropertyDescriptor)), Ca)
}
var Pa, Iu
function vd() {
    if (Iu) return Pa
    Iu = 1
    var s = km()
    if (s)
        try {
            s([], 'length')
        } catch {
            s = null
        }
    return ((Pa = s), Pa)
}
var Ra, Mu
function Nm() {
    if (Mu) return Ra
    Mu = 1
    var s = Object.defineProperty || !1
    if (s)
        try {
            s({}, 'a', { value: 1 })
        } catch {
            s = !1
        }
    return ((Ra = s), Ra)
}
var Ia, Du
function Um() {
    return (
        Du ||
            ((Du = 1),
            (Ia = function () {
                if (
                    typeof Symbol != 'function' ||
                    typeof Object.getOwnPropertySymbols != 'function'
                )
                    return !1
                if (typeof Symbol.iterator == 'symbol') return !0
                var t = {},
                    e = Symbol('test'),
                    i = Object(e)
                if (
                    typeof e == 'string' ||
                    Object.prototype.toString.call(e) !== '[object Symbol]' ||
                    Object.prototype.toString.call(i) !== '[object Symbol]'
                )
                    return !1
                var r = 42
                t[e] = r
                for (var n in t) return !1
                if (
                    (typeof Object.keys == 'function' &&
                        Object.keys(t).length !== 0) ||
                    (typeof Object.getOwnPropertyNames == 'function' &&
                        Object.getOwnPropertyNames(t).length !== 0)
                )
                    return !1
                var a = Object.getOwnPropertySymbols(t)
                if (
                    a.length !== 1 ||
                    a[0] !== e ||
                    !Object.prototype.propertyIsEnumerable.call(t, e)
                )
                    return !1
                if (typeof Object.getOwnPropertyDescriptor == 'function') {
                    var o = Object.getOwnPropertyDescriptor(t, e)
                    if (o.value !== r || o.enumerable !== !0) return !1
                }
                return !0
            })),
        Ia
    )
}
var Ma, Bu
function Gm() {
    if (Bu) return Ma
    Bu = 1
    var s = typeof Symbol < 'u' && Symbol,
        t = Um()
    return (
        (Ma = function () {
            return typeof s != 'function' ||
                typeof Symbol != 'function' ||
                typeof s('foo') != 'symbol' ||
                typeof Symbol('bar') != 'symbol'
                ? !1
                : t()
        }),
        Ma
    )
}
var Da, Ou
function xd() {
    return (
        Ou ||
            ((Ou = 1),
            (Da = (typeof Reflect < 'u' && Reflect.getPrototypeOf) || null)),
        Da
    )
}
var Ba, Fu
function bd() {
    if (Fu) return Ba
    Fu = 1
    var s = yd()
    return ((Ba = s.getPrototypeOf || null), Ba)
}
var Oa, Lu
function Hm() {
    if (Lu) return Oa
    Lu = 1
    var s = 'Function.prototype.bind called on incompatible ',
        t = Object.prototype.toString,
        e = Math.max,
        i = '[object Function]',
        r = function (h, l) {
            for (var u = [], c = 0; c < h.length; c += 1) u[c] = h[c]
            for (var d = 0; d < l.length; d += 1) u[d + h.length] = l[d]
            return u
        },
        n = function (h, l) {
            for (var u = [], c = l, d = 0; c < h.length; c += 1, d += 1)
                u[d] = h[c]
            return u
        },
        a = function (o, h) {
            for (var l = '', u = 0; u < o.length; u += 1)
                ((l += o[u]), u + 1 < o.length && (l += h))
            return l
        }
    return (
        (Oa = function (h) {
            var l = this
            if (typeof l != 'function' || t.apply(l) !== i)
                throw new TypeError(s + l)
            for (
                var u = n(arguments, 1),
                    c,
                    d = function () {
                        if (this instanceof c) {
                            var _ = l.apply(this, r(u, arguments))
                            return Object(_) === _ ? _ : this
                        }
                        return l.apply(h, r(u, arguments))
                    },
                    f = e(0, l.length - u.length),
                    m = [],
                    p = 0;
                p < f;
                p++
            )
                m[p] = '$' + p
            if (
                ((c = Function(
                    'binder',
                    'return function (' +
                        a(m, ',') +
                        '){ return binder.apply(this,arguments); }',
                )(d)),
                l.prototype)
            ) {
                var g = function () {}
                ;((g.prototype = l.prototype),
                    (c.prototype = new g()),
                    (g.prototype = null))
            }
            return c
        }),
        Oa
    )
}
var Fa, ku
function On() {
    if (ku) return Fa
    ku = 1
    var s = Hm()
    return ((Fa = Function.prototype.bind || s), Fa)
}
var La, Nu
function Gh() {
    return (Nu || ((Nu = 1), (La = Function.prototype.call)), La)
}
var ka, Uu
function wd() {
    return (Uu || ((Uu = 1), (ka = Function.prototype.apply)), ka)
}
var Na, Gu
function zm() {
    return (
        Gu ||
            ((Gu = 1), (Na = typeof Reflect < 'u' && Reflect && Reflect.apply)),
        Na
    )
}
var Ua, Hu
function Vm() {
    if (Hu) return Ua
    Hu = 1
    var s = On(),
        t = wd(),
        e = Gh(),
        i = zm()
    return ((Ua = i || s.call(e, t)), Ua)
}
var Ga, zu
function Td() {
    if (zu) return Ga
    zu = 1
    var s = On(),
        t = Ur(),
        e = Gh(),
        i = Vm()
    return (
        (Ga = function (n) {
            if (n.length < 1 || typeof n[0] != 'function')
                throw new t('a function is required')
            return i(s, e, n)
        }),
        Ga
    )
}
var Ha, Vu
function Xm() {
    if (Vu) return Ha
    Vu = 1
    var s = Td(),
        t = vd(),
        e
    try {
        e = [].__proto__ === Array.prototype
    } catch (a) {
        if (
            !a ||
            typeof a != 'object' ||
            !('code' in a) ||
            a.code !== 'ERR_PROTO_ACCESS'
        )
            throw a
    }
    var i = !!e && t && t(Object.prototype, '__proto__'),
        r = Object,
        n = r.getPrototypeOf
    return (
        (Ha =
            i && typeof i.get == 'function'
                ? s([i.get])
                : typeof n == 'function'
                  ? function (o) {
                        return n(o == null ? o : r(o))
                    }
                  : !1),
        Ha
    )
}
var za, Xu
function Wm() {
    if (Xu) return za
    Xu = 1
    var s = xd(),
        t = bd(),
        e = Xm()
    return (
        (za = s
            ? function (r) {
                  return s(r)
              }
            : t
              ? function (r) {
                    if (!r || (typeof r != 'object' && typeof r != 'function'))
                        throw new TypeError('getProto: not an object')
                    return t(r)
                }
              : e
                ? function (r) {
                      return e(r)
                  }
                : null),
        za
    )
}
var Va, Wu
function $m() {
    if (Wu) return Va
    Wu = 1
    var s = Function.prototype.call,
        t = Object.prototype.hasOwnProperty,
        e = On()
    return ((Va = e.call(s, t)), Va)
}
var Xa, $u
function Hh() {
    if ($u) return Xa
    $u = 1
    var s,
        t = yd(),
        e = Tm(),
        i = Em(),
        r = Am(),
        n = Sm(),
        a = Cm(),
        o = Ur(),
        h = Pm(),
        l = Rm(),
        u = Im(),
        c = Mm(),
        d = Dm(),
        f = Bm(),
        m = Om(),
        p = Lm(),
        g = Function,
        _ = function (rt) {
            try {
                return g('"use strict"; return (' + rt + ').constructor;')()
            } catch {}
        },
        b = vd(),
        v = Nm(),
        w = function () {
            throw new o()
        },
        x = b
            ? (function () {
                  try {
                      return (arguments.callee, w)
                  } catch {
                      try {
                          return b(arguments, 'callee').get
                      } catch {
                          return w
                      }
                  }
              })()
            : w,
        P = Gm()(),
        y = Wm(),
        S = bd(),
        R = xd(),
        G = wd(),
        N = Gh(),
        I = {},
        O = typeof Uint8Array > 'u' || !y ? s : y(Uint8Array),
        L = {
            __proto__: null,
            '%AggregateError%':
                typeof AggregateError > 'u' ? s : AggregateError,
            '%Array%': Array,
            '%ArrayBuffer%': typeof ArrayBuffer > 'u' ? s : ArrayBuffer,
            '%ArrayIteratorPrototype%': P && y ? y([][Symbol.iterator]()) : s,
            '%AsyncFromSyncIteratorPrototype%': s,
            '%AsyncFunction%': I,
            '%AsyncGenerator%': I,
            '%AsyncGeneratorFunction%': I,
            '%AsyncIteratorPrototype%': I,
            '%Atomics%': typeof Atomics > 'u' ? s : Atomics,
            '%BigInt%': typeof BigInt > 'u' ? s : BigInt,
            '%BigInt64Array%': typeof BigInt64Array > 'u' ? s : BigInt64Array,
            '%BigUint64Array%':
                typeof BigUint64Array > 'u' ? s : BigUint64Array,
            '%Boolean%': Boolean,
            '%DataView%': typeof DataView > 'u' ? s : DataView,
            '%Date%': Date,
            '%decodeURI%': decodeURI,
            '%decodeURIComponent%': decodeURIComponent,
            '%encodeURI%': encodeURI,
            '%encodeURIComponent%': encodeURIComponent,
            '%Error%': e,
            '%eval%': eval,
            '%EvalError%': i,
            '%Float16Array%': typeof Float16Array > 'u' ? s : Float16Array,
            '%Float32Array%': typeof Float32Array > 'u' ? s : Float32Array,
            '%Float64Array%': typeof Float64Array > 'u' ? s : Float64Array,
            '%FinalizationRegistry%':
                typeof FinalizationRegistry > 'u' ? s : FinalizationRegistry,
            '%Function%': g,
            '%GeneratorFunction%': I,
            '%Int8Array%': typeof Int8Array > 'u' ? s : Int8Array,
            '%Int16Array%': typeof Int16Array > 'u' ? s : Int16Array,
            '%Int32Array%': typeof Int32Array > 'u' ? s : Int32Array,
            '%isFinite%': isFinite,
            '%isNaN%': isNaN,
            '%IteratorPrototype%': P && y ? y(y([][Symbol.iterator]())) : s,
            '%JSON%': typeof JSON == 'object' ? JSON : s,
            '%Map%': typeof Map > 'u' ? s : Map,
            '%MapIteratorPrototype%':
                typeof Map > 'u' || !P || !y
                    ? s
                    : y(new Map()[Symbol.iterator]()),
            '%Math%': Math,
            '%Number%': Number,
            '%Object%': t,
            '%Object.getOwnPropertyDescriptor%': b,
            '%parseFloat%': parseFloat,
            '%parseInt%': parseInt,
            '%Promise%': typeof Promise > 'u' ? s : Promise,
            '%Proxy%': typeof Proxy > 'u' ? s : Proxy,
            '%RangeError%': r,
            '%ReferenceError%': n,
            '%Reflect%': typeof Reflect > 'u' ? s : Reflect,
            '%RegExp%': RegExp,
            '%Set%': typeof Set > 'u' ? s : Set,
            '%SetIteratorPrototype%':
                typeof Set > 'u' || !P || !y
                    ? s
                    : y(new Set()[Symbol.iterator]()),
            '%SharedArrayBuffer%':
                typeof SharedArrayBuffer > 'u' ? s : SharedArrayBuffer,
            '%String%': String,
            '%StringIteratorPrototype%': P && y ? y(''[Symbol.iterator]()) : s,
            '%Symbol%': P ? Symbol : s,
            '%SyntaxError%': a,
            '%ThrowTypeError%': x,
            '%TypedArray%': O,
            '%TypeError%': o,
            '%Uint8Array%': typeof Uint8Array > 'u' ? s : Uint8Array,
            '%Uint8ClampedArray%':
                typeof Uint8ClampedArray > 'u' ? s : Uint8ClampedArray,
            '%Uint16Array%': typeof Uint16Array > 'u' ? s : Uint16Array,
            '%Uint32Array%': typeof Uint32Array > 'u' ? s : Uint32Array,
            '%URIError%': h,
            '%WeakMap%': typeof WeakMap > 'u' ? s : WeakMap,
            '%WeakRef%': typeof WeakRef > 'u' ? s : WeakRef,
            '%WeakSet%': typeof WeakSet > 'u' ? s : WeakSet,
            '%Function.prototype.call%': N,
            '%Function.prototype.apply%': G,
            '%Object.defineProperty%': v,
            '%Object.getPrototypeOf%': S,
            '%Math.abs%': l,
            '%Math.floor%': u,
            '%Math.max%': c,
            '%Math.min%': d,
            '%Math.pow%': f,
            '%Math.round%': m,
            '%Math.sign%': p,
            '%Reflect.getPrototypeOf%': R,
        }
    if (y)
        try {
            null.error
        } catch (rt) {
            var V = y(y(rt))
            L['%Error.prototype%'] = V
        }
    var T = function rt(W) {
            var et
            if (W === '%AsyncFunction%') et = _('async function () {}')
            else if (W === '%GeneratorFunction%') et = _('function* () {}')
            else if (W === '%AsyncGeneratorFunction%')
                et = _('async function* () {}')
            else if (W === '%AsyncGenerator%') {
                var st = rt('%AsyncGeneratorFunction%')
                st && (et = st.prototype)
            } else if (W === '%AsyncIteratorPrototype%') {
                var ht = rt('%AsyncGenerator%')
                ht && y && (et = y(ht.prototype))
            }
            return ((L[W] = et), et)
        },
        A = {
            __proto__: null,
            '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
            '%ArrayPrototype%': ['Array', 'prototype'],
            '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
            '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
            '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
            '%ArrayProto_values%': ['Array', 'prototype', 'values'],
            '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
            '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
            '%AsyncGeneratorPrototype%': [
                'AsyncGeneratorFunction',
                'prototype',
                'prototype',
            ],
            '%BooleanPrototype%': ['Boolean', 'prototype'],
            '%DataViewPrototype%': ['DataView', 'prototype'],
            '%DatePrototype%': ['Date', 'prototype'],
            '%ErrorPrototype%': ['Error', 'prototype'],
            '%EvalErrorPrototype%': ['EvalError', 'prototype'],
            '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
            '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
            '%FunctionPrototype%': ['Function', 'prototype'],
            '%Generator%': ['GeneratorFunction', 'prototype'],
            '%GeneratorPrototype%': [
                'GeneratorFunction',
                'prototype',
                'prototype',
            ],
            '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
            '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
            '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
            '%JSONParse%': ['JSON', 'parse'],
            '%JSONStringify%': ['JSON', 'stringify'],
            '%MapPrototype%': ['Map', 'prototype'],
            '%NumberPrototype%': ['Number', 'prototype'],
            '%ObjectPrototype%': ['Object', 'prototype'],
            '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
            '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
            '%PromisePrototype%': ['Promise', 'prototype'],
            '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
            '%Promise_all%': ['Promise', 'all'],
            '%Promise_reject%': ['Promise', 'reject'],
            '%Promise_resolve%': ['Promise', 'resolve'],
            '%RangeErrorPrototype%': ['RangeError', 'prototype'],
            '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
            '%RegExpPrototype%': ['RegExp', 'prototype'],
            '%SetPrototype%': ['Set', 'prototype'],
            '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
            '%StringPrototype%': ['String', 'prototype'],
            '%SymbolPrototype%': ['Symbol', 'prototype'],
            '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
            '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
            '%TypeErrorPrototype%': ['TypeError', 'prototype'],
            '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
            '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
            '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
            '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
            '%URIErrorPrototype%': ['URIError', 'prototype'],
            '%WeakMapPrototype%': ['WeakMap', 'prototype'],
            '%WeakSetPrototype%': ['WeakSet', 'prototype'],
        },
        E = On(),
        B = $m(),
        C = E.call(N, Array.prototype.concat),
        M = E.call(G, Array.prototype.splice),
        D = E.call(N, String.prototype.replace),
        F = E.call(N, String.prototype.slice),
        H = E.call(N, RegExp.prototype.exec),
        z =
            /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
        K = /\\(\\)?/g,
        Z = function (W) {
            var et = F(W, 0, 1),
                st = F(W, -1)
            if (et === '%' && st !== '%')
                throw new a('invalid intrinsic syntax, expected closing `%`')
            if (st === '%' && et !== '%')
                throw new a('invalid intrinsic syntax, expected opening `%`')
            var ht = []
            return (
                D(W, z, function (pt, it, nt, Mt) {
                    ht[ht.length] = nt ? D(Mt, K, '$1') : it || pt
                }),
                ht
            )
        },
        J = function (W, et) {
            var st = W,
                ht
            if (
                (B(A, st) && ((ht = A[st]), (st = '%' + ht[0] + '%')), B(L, st))
            ) {
                var pt = L[st]
                if ((pt === I && (pt = T(st)), typeof pt > 'u' && !et))
                    throw new o(
                        'intrinsic ' +
                            W +
                            ' exists, but is not available. Please file an issue!',
                    )
                return { alias: ht, name: st, value: pt }
            }
            throw new a('intrinsic ' + W + ' does not exist!')
        }
    return (
        (Xa = function (W, et) {
            if (typeof W != 'string' || W.length === 0)
                throw new o('intrinsic name must be a non-empty string')
            if (arguments.length > 1 && typeof et != 'boolean')
                throw new o('"allowMissing" argument must be a boolean')
            if (H(/^%?[^%]*%?$/, W) === null)
                throw new a(
                    '`%` may not be present anywhere but at the beginning and end of the intrinsic name',
                )
            var st = Z(W),
                ht = st.length > 0 ? st[0] : '',
                pt = J('%' + ht + '%', et),
                it = pt.name,
                nt = pt.value,
                Mt = !1,
                kt = pt.alias
            kt && ((ht = kt[0]), M(st, C([0, 1], kt)))
            for (var rr = 1, oi = !0; rr < st.length; rr += 1) {
                var ye = st[rr],
                    sr = F(ye, 0, 1),
                    nr = F(ye, -1)
                if (
                    (sr === '"' ||
                        sr === "'" ||
                        sr === '`' ||
                        nr === '"' ||
                        nr === "'" ||
                        nr === '`') &&
                    sr !== nr
                )
                    throw new a(
                        'property names with quotes must have matching quotes',
                    )
                if (
                    ((ye === 'constructor' || !oi) && (Mt = !0),
                    (ht += '.' + ye),
                    (it = '%' + ht + '%'),
                    B(L, it))
                )
                    nt = L[it]
                else if (nt != null) {
                    if (!(ye in nt)) {
                        if (!et)
                            throw new o(
                                'base intrinsic for ' +
                                    W +
                                    ' exists, but the property is not available.',
                            )
                        return
                    }
                    if (b && rr + 1 >= st.length) {
                        var ar = b(nt, ye)
                        ;((oi = !!ar),
                            oi && 'get' in ar && !('originalValue' in ar.get)
                                ? (nt = ar.get)
                                : (nt = nt[ye]))
                    } else ((oi = B(nt, ye)), (nt = nt[ye]))
                    oi && !Mt && (L[it] = nt)
                }
            }
            return nt
        }),
        Xa
    )
}
var Wa, ju
function Ed() {
    if (ju) return Wa
    ju = 1
    var s = Hh(),
        t = Td(),
        e = t([s('%String.prototype.indexOf%')])
    return (
        (Wa = function (r, n) {
            var a = s(r, !!n)
            return typeof a == 'function' && e(r, '.prototype.') > -1
                ? t([a])
                : a
        }),
        Wa
    )
}
var $a, qu
function Ad() {
    if (qu) return $a
    qu = 1
    var s = Hh(),
        t = Ed(),
        e = Bn(),
        i = Ur(),
        r = s('%Map%', !0),
        n = t('Map.prototype.get', !0),
        a = t('Map.prototype.set', !0),
        o = t('Map.prototype.has', !0),
        h = t('Map.prototype.delete', !0),
        l = t('Map.prototype.size', !0)
    return (
        ($a =
            !!r &&
            function () {
                var c,
                    d = {
                        assert: function (f) {
                            if (!d.has(f))
                                throw new i(
                                    'Side channel does not contain ' + e(f),
                                )
                        },
                        delete: function (f) {
                            if (c) {
                                var m = h(c, f)
                                return (l(c) === 0 && (c = void 0), m)
                            }
                            return !1
                        },
                        get: function (f) {
                            if (c) return n(c, f)
                        },
                        has: function (f) {
                            return c ? o(c, f) : !1
                        },
                        set: function (f, m) {
                            ;(c || (c = new r()), a(c, f, m))
                        },
                    }
                return d
            }),
        $a
    )
}
var ja, Yu
function jm() {
    if (Yu) return ja
    Yu = 1
    var s = Hh(),
        t = Ed(),
        e = Bn(),
        i = Ad(),
        r = Ur(),
        n = s('%WeakMap%', !0),
        a = t('WeakMap.prototype.get', !0),
        o = t('WeakMap.prototype.set', !0),
        h = t('WeakMap.prototype.has', !0),
        l = t('WeakMap.prototype.delete', !0)
    return (
        (ja = n
            ? function () {
                  var c,
                      d,
                      f = {
                          assert: function (m) {
                              if (!f.has(m))
                                  throw new r(
                                      'Side channel does not contain ' + e(m),
                                  )
                          },
                          delete: function (m) {
                              if (
                                  n &&
                                  m &&
                                  (typeof m == 'object' ||
                                      typeof m == 'function')
                              ) {
                                  if (c) return l(c, m)
                              } else if (i && d) return d.delete(m)
                              return !1
                          },
                          get: function (m) {
                              return n &&
                                  m &&
                                  (typeof m == 'object' ||
                                      typeof m == 'function') &&
                                  c
                                  ? a(c, m)
                                  : d && d.get(m)
                          },
                          has: function (m) {
                              return n &&
                                  m &&
                                  (typeof m == 'object' ||
                                      typeof m == 'function') &&
                                  c
                                  ? h(c, m)
                                  : !!d && d.has(m)
                          },
                          set: function (m, p) {
                              n &&
                              m &&
                              (typeof m == 'object' || typeof m == 'function')
                                  ? (c || (c = new n()), o(c, m, p))
                                  : i && (d || (d = i()), d.set(m, p))
                          },
                      }
                  return f
              }
            : i),
        ja
    )
}
var qa, Ku
function qm() {
    if (Ku) return qa
    Ku = 1
    var s = Ur(),
        t = Bn(),
        e = wm(),
        i = Ad(),
        r = jm(),
        n = r || i || e
    return (
        (qa = function () {
            var o,
                h = {
                    assert: function (l) {
                        if (!h.has(l))
                            throw new s('Side channel does not contain ' + t(l))
                    },
                    delete: function (l) {
                        return !!o && o.delete(l)
                    },
                    get: function (l) {
                        return o && o.get(l)
                    },
                    has: function (l) {
                        return !!o && o.has(l)
                    },
                    set: function (l, u) {
                        ;(o || (o = n()), o.set(l, u))
                    },
                }
            return h
        }),
        qa
    )
}
var Ya, Zu
function zh() {
    if (Zu) return Ya
    Zu = 1
    var s = String.prototype.replace,
        t = /%20/g,
        e = { RFC1738: 'RFC1738', RFC3986: 'RFC3986' }
    return (
        (Ya = {
            default: e.RFC3986,
            formatters: {
                RFC1738: function (i) {
                    return s.call(i, t, '+')
                },
                RFC3986: function (i) {
                    return String(i)
                },
            },
            RFC1738: e.RFC1738,
            RFC3986: e.RFC3986,
        }),
        Ya
    )
}
var Ka, Qu
function Sd() {
    if (Qu) return Ka
    Qu = 1
    var s = zh(),
        t = Object.prototype.hasOwnProperty,
        e = Array.isArray,
        i = (function () {
            for (var g = [], _ = 0; _ < 256; ++_)
                g.push(
                    '%' + ((_ < 16 ? '0' : '') + _.toString(16)).toUpperCase(),
                )
            return g
        })(),
        r = function (_) {
            for (; _.length > 1; ) {
                var b = _.pop(),
                    v = b.obj[b.prop]
                if (e(v)) {
                    for (var w = [], x = 0; x < v.length; ++x)
                        typeof v[x] < 'u' && w.push(v[x])
                    b.obj[b.prop] = w
                }
            }
        },
        n = function (_, b) {
            for (
                var v = b && b.plainObjects ? { __proto__: null } : {}, w = 0;
                w < _.length;
                ++w
            )
                typeof _[w] < 'u' && (v[w] = _[w])
            return v
        },
        a = function g(_, b, v) {
            if (!b) return _
            if (typeof b != 'object' && typeof b != 'function') {
                if (e(_)) _.push(b)
                else if (_ && typeof _ == 'object')
                    ((v && (v.plainObjects || v.allowPrototypes)) ||
                        !t.call(Object.prototype, b)) &&
                        (_[b] = !0)
                else return [_, b]
                return _
            }
            if (!_ || typeof _ != 'object') return [_].concat(b)
            var w = _
            return (
                e(_) && !e(b) && (w = n(_, v)),
                e(_) && e(b)
                    ? (b.forEach(function (x, P) {
                          if (t.call(_, P)) {
                              var y = _[P]
                              y &&
                              typeof y == 'object' &&
                              x &&
                              typeof x == 'object'
                                  ? (_[P] = g(y, x, v))
                                  : _.push(x)
                          } else _[P] = x
                      }),
                      _)
                    : Object.keys(b).reduce(function (x, P) {
                          var y = b[P]
                          return (
                              t.call(x, P)
                                  ? (x[P] = g(x[P], y, v))
                                  : (x[P] = y),
                              x
                          )
                      }, w)
            )
        },
        o = function (_, b) {
            return Object.keys(b).reduce(function (v, w) {
                return ((v[w] = b[w]), v)
            }, _)
        },
        h = function (g, _, b) {
            var v = g.replace(/\+/g, ' ')
            if (b === 'iso-8859-1') return v.replace(/%[0-9a-f]{2}/gi, unescape)
            try {
                return decodeURIComponent(v)
            } catch {
                return v
            }
        },
        l = 1024,
        u = function (_, b, v, w, x) {
            if (_.length === 0) return _
            var P = _
            if (
                (typeof _ == 'symbol'
                    ? (P = Symbol.prototype.toString.call(_))
                    : typeof _ != 'string' && (P = String(_)),
                v === 'iso-8859-1')
            )
                return escape(P).replace(/%u[0-9a-f]{4}/gi, function (O) {
                    return '%26%23' + parseInt(O.slice(2), 16) + '%3B'
                })
            for (var y = '', S = 0; S < P.length; S += l) {
                for (
                    var R = P.length >= l ? P.slice(S, S + l) : P,
                        G = [],
                        N = 0;
                    N < R.length;
                    ++N
                ) {
                    var I = R.charCodeAt(N)
                    if (
                        I === 45 ||
                        I === 46 ||
                        I === 95 ||
                        I === 126 ||
                        (I >= 48 && I <= 57) ||
                        (I >= 65 && I <= 90) ||
                        (I >= 97 && I <= 122) ||
                        (x === s.RFC1738 && (I === 40 || I === 41))
                    ) {
                        G[G.length] = R.charAt(N)
                        continue
                    }
                    if (I < 128) {
                        G[G.length] = i[I]
                        continue
                    }
                    if (I < 2048) {
                        G[G.length] = i[192 | (I >> 6)] + i[128 | (I & 63)]
                        continue
                    }
                    if (I < 55296 || I >= 57344) {
                        G[G.length] =
                            i[224 | (I >> 12)] +
                            i[128 | ((I >> 6) & 63)] +
                            i[128 | (I & 63)]
                        continue
                    }
                    ;((N += 1),
                        (I =
                            65536 +
                            (((I & 1023) << 10) | (R.charCodeAt(N) & 1023))),
                        (G[G.length] =
                            i[240 | (I >> 18)] +
                            i[128 | ((I >> 12) & 63)] +
                            i[128 | ((I >> 6) & 63)] +
                            i[128 | (I & 63)]))
                }
                y += G.join('')
            }
            return y
        },
        c = function (_) {
            for (
                var b = [{ obj: { o: _ }, prop: 'o' }], v = [], w = 0;
                w < b.length;
                ++w
            )
                for (
                    var x = b[w], P = x.obj[x.prop], y = Object.keys(P), S = 0;
                    S < y.length;
                    ++S
                ) {
                    var R = y[S],
                        G = P[R]
                    typeof G == 'object' &&
                        G !== null &&
                        v.indexOf(G) === -1 &&
                        (b.push({ obj: P, prop: R }), v.push(G))
                }
            return (r(b), _)
        },
        d = function (_) {
            return Object.prototype.toString.call(_) === '[object RegExp]'
        },
        f = function (_) {
            return !_ || typeof _ != 'object'
                ? !1
                : !!(
                      _.constructor &&
                      _.constructor.isBuffer &&
                      _.constructor.isBuffer(_)
                  )
        },
        m = function (_, b) {
            return [].concat(_, b)
        },
        p = function (_, b) {
            if (e(_)) {
                for (var v = [], w = 0; w < _.length; w += 1) v.push(b(_[w]))
                return v
            }
            return b(_)
        }
    return (
        (Ka = {
            arrayToObject: n,
            assign: o,
            combine: m,
            compact: c,
            decode: h,
            encode: u,
            isBuffer: f,
            isRegExp: d,
            maybeMap: p,
            merge: a,
        }),
        Ka
    )
}
var Za, Ju
function Ym() {
    if (Ju) return Za
    Ju = 1
    var s = qm(),
        t = Sd(),
        e = zh(),
        i = Object.prototype.hasOwnProperty,
        r = {
            brackets: function (g) {
                return g + '[]'
            },
            comma: 'comma',
            indices: function (g, _) {
                return g + '[' + _ + ']'
            },
            repeat: function (g) {
                return g
            },
        },
        n = Array.isArray,
        a = Array.prototype.push,
        o = function (p, g) {
            a.apply(p, n(g) ? g : [g])
        },
        h = Date.prototype.toISOString,
        l = e.default,
        u = {
            addQueryPrefix: !1,
            allowDots: !1,
            allowEmptyArrays: !1,
            arrayFormat: 'indices',
            charset: 'utf-8',
            charsetSentinel: !1,
            commaRoundTrip: !1,
            delimiter: '&',
            encode: !0,
            encodeDotInKeys: !1,
            encoder: t.encode,
            encodeValuesOnly: !1,
            filter: void 0,
            format: l,
            formatter: e.formatters[l],
            indices: !1,
            serializeDate: function (g) {
                return h.call(g)
            },
            skipNulls: !1,
            strictNullHandling: !1,
        },
        c = function (g) {
            return (
                typeof g == 'string' ||
                typeof g == 'number' ||
                typeof g == 'boolean' ||
                typeof g == 'symbol' ||
                typeof g == 'bigint'
            )
        },
        d = {},
        f = function p(g, _, b, v, w, x, P, y, S, R, G, N, I, O, L, V, T, A) {
            for (
                var E = g, B = A, C = 0, M = !1;
                (B = B.get(d)) !== void 0 && !M;

            ) {
                var D = B.get(g)
                if (((C += 1), typeof D < 'u')) {
                    if (D === C) throw new RangeError('Cyclic object value')
                    M = !0
                }
                typeof B.get(d) > 'u' && (C = 0)
            }
            if (
                (typeof R == 'function'
                    ? (E = R(_, E))
                    : E instanceof Date
                      ? (E = I(E))
                      : b === 'comma' &&
                        n(E) &&
                        (E = t.maybeMap(E, function (it) {
                            return it instanceof Date ? I(it) : it
                        })),
                E === null)
            ) {
                if (x) return S && !V ? S(_, u.encoder, T, 'key', O) : _
                E = ''
            }
            if (c(E) || t.isBuffer(E)) {
                if (S) {
                    var F = V ? _ : S(_, u.encoder, T, 'key', O)
                    return [L(F) + '=' + L(S(E, u.encoder, T, 'value', O))]
                }
                return [L(_) + '=' + L(String(E))]
            }
            var H = []
            if (typeof E > 'u') return H
            var z
            if (b === 'comma' && n(E))
                (V && S && (E = t.maybeMap(E, S)),
                    (z = [
                        { value: E.length > 0 ? E.join(',') || null : void 0 },
                    ]))
            else if (n(R)) z = R
            else {
                var K = Object.keys(E)
                z = G ? K.sort(G) : K
            }
            var Z = y ? String(_).replace(/\./g, '%2E') : String(_),
                J = v && n(E) && E.length === 1 ? Z + '[]' : Z
            if (w && n(E) && E.length === 0) return J + '[]'
            for (var rt = 0; rt < z.length; ++rt) {
                var W = z[rt],
                    et =
                        typeof W == 'object' && W && typeof W.value < 'u'
                            ? W.value
                            : E[W]
                if (!(P && et === null)) {
                    var st =
                            N && y
                                ? String(W).replace(/\./g, '%2E')
                                : String(W),
                        ht = n(E)
                            ? typeof b == 'function'
                                ? b(J, st)
                                : J
                            : J + (N ? '.' + st : '[' + st + ']')
                    A.set(g, C)
                    var pt = s()
                    ;(pt.set(d, A),
                        o(
                            H,
                            p(
                                et,
                                ht,
                                b,
                                v,
                                w,
                                x,
                                P,
                                y,
                                b === 'comma' && V && n(E) ? null : S,
                                R,
                                G,
                                N,
                                I,
                                O,
                                L,
                                V,
                                T,
                                pt,
                            ),
                        ))
                }
            }
            return H
        },
        m = function (g) {
            if (!g) return u
            if (
                typeof g.allowEmptyArrays < 'u' &&
                typeof g.allowEmptyArrays != 'boolean'
            )
                throw new TypeError(
                    '`allowEmptyArrays` option can only be `true` or `false`, when provided',
                )
            if (
                typeof g.encodeDotInKeys < 'u' &&
                typeof g.encodeDotInKeys != 'boolean'
            )
                throw new TypeError(
                    '`encodeDotInKeys` option can only be `true` or `false`, when provided',
                )
            if (
                g.encoder !== null &&
                typeof g.encoder < 'u' &&
                typeof g.encoder != 'function'
            )
                throw new TypeError('Encoder has to be a function.')
            var _ = g.charset || u.charset
            if (
                typeof g.charset < 'u' &&
                g.charset !== 'utf-8' &&
                g.charset !== 'iso-8859-1'
            )
                throw new TypeError(
                    'The charset option must be either utf-8, iso-8859-1, or undefined',
                )
            var b = e.default
            if (typeof g.format < 'u') {
                if (!i.call(e.formatters, g.format))
                    throw new TypeError('Unknown format option provided.')
                b = g.format
            }
            var v = e.formatters[b],
                w = u.filter
            ;(typeof g.filter == 'function' || n(g.filter)) && (w = g.filter)
            var x
            if (
                (g.arrayFormat in r
                    ? (x = g.arrayFormat)
                    : 'indices' in g
                      ? (x = g.indices ? 'indices' : 'repeat')
                      : (x = u.arrayFormat),
                'commaRoundTrip' in g && typeof g.commaRoundTrip != 'boolean')
            )
                throw new TypeError(
                    '`commaRoundTrip` must be a boolean, or absent',
                )
            var P =
                typeof g.allowDots > 'u'
                    ? g.encodeDotInKeys === !0
                        ? !0
                        : u.allowDots
                    : !!g.allowDots
            return {
                addQueryPrefix:
                    typeof g.addQueryPrefix == 'boolean'
                        ? g.addQueryPrefix
                        : u.addQueryPrefix,
                allowDots: P,
                allowEmptyArrays:
                    typeof g.allowEmptyArrays == 'boolean'
                        ? !!g.allowEmptyArrays
                        : u.allowEmptyArrays,
                arrayFormat: x,
                charset: _,
                charsetSentinel:
                    typeof g.charsetSentinel == 'boolean'
                        ? g.charsetSentinel
                        : u.charsetSentinel,
                commaRoundTrip: !!g.commaRoundTrip,
                delimiter: typeof g.delimiter > 'u' ? u.delimiter : g.delimiter,
                encode: typeof g.encode == 'boolean' ? g.encode : u.encode,
                encodeDotInKeys:
                    typeof g.encodeDotInKeys == 'boolean'
                        ? g.encodeDotInKeys
                        : u.encodeDotInKeys,
                encoder: typeof g.encoder == 'function' ? g.encoder : u.encoder,
                encodeValuesOnly:
                    typeof g.encodeValuesOnly == 'boolean'
                        ? g.encodeValuesOnly
                        : u.encodeValuesOnly,
                filter: w,
                format: b,
                formatter: v,
                serializeDate:
                    typeof g.serializeDate == 'function'
                        ? g.serializeDate
                        : u.serializeDate,
                skipNulls:
                    typeof g.skipNulls == 'boolean' ? g.skipNulls : u.skipNulls,
                sort: typeof g.sort == 'function' ? g.sort : null,
                strictNullHandling:
                    typeof g.strictNullHandling == 'boolean'
                        ? g.strictNullHandling
                        : u.strictNullHandling,
            }
        }
    return (
        (Za = function (p, g) {
            var _ = p,
                b = m(g),
                v,
                w
            typeof b.filter == 'function'
                ? ((w = b.filter), (_ = w('', _)))
                : n(b.filter) && ((w = b.filter), (v = w))
            var x = []
            if (typeof _ != 'object' || _ === null) return ''
            var P = r[b.arrayFormat],
                y = P === 'comma' && b.commaRoundTrip
            ;(v || (v = Object.keys(_)), b.sort && v.sort(b.sort))
            for (var S = s(), R = 0; R < v.length; ++R) {
                var G = v[R],
                    N = _[G]
                ;(b.skipNulls && N === null) ||
                    o(
                        x,
                        f(
                            N,
                            G,
                            P,
                            y,
                            b.allowEmptyArrays,
                            b.strictNullHandling,
                            b.skipNulls,
                            b.encodeDotInKeys,
                            b.encode ? b.encoder : null,
                            b.filter,
                            b.sort,
                            b.allowDots,
                            b.serializeDate,
                            b.format,
                            b.formatter,
                            b.encodeValuesOnly,
                            b.charset,
                            S,
                        ),
                    )
            }
            var I = x.join(b.delimiter),
                O = b.addQueryPrefix === !0 ? '?' : ''
            return (
                b.charsetSentinel &&
                    (b.charset === 'iso-8859-1'
                        ? (O += 'utf8=%26%2310003%3B&')
                        : (O += 'utf8=%E2%9C%93&')),
                I.length > 0 ? O + I : ''
            )
        }),
        Za
    )
}
var Qa, tc
function Km() {
    if (tc) return Qa
    tc = 1
    var s = Sd(),
        t = Object.prototype.hasOwnProperty,
        e = Array.isArray,
        i = {
            allowDots: !1,
            allowEmptyArrays: !1,
            allowPrototypes: !1,
            allowSparse: !1,
            arrayLimit: 20,
            charset: 'utf-8',
            charsetSentinel: !1,
            comma: !1,
            decodeDotInKeys: !1,
            decoder: s.decode,
            delimiter: '&',
            depth: 5,
            duplicates: 'combine',
            ignoreQueryPrefix: !1,
            interpretNumericEntities: !1,
            parameterLimit: 1e3,
            parseArrays: !0,
            plainObjects: !1,
            strictDepth: !1,
            strictNullHandling: !1,
            throwOnLimitExceeded: !1,
        },
        r = function (d) {
            return d.replace(/&#(\d+);/g, function (f, m) {
                return String.fromCharCode(parseInt(m, 10))
            })
        },
        n = function (d, f, m) {
            if (d && typeof d == 'string' && f.comma && d.indexOf(',') > -1)
                return d.split(',')
            if (f.throwOnLimitExceeded && m >= f.arrayLimit)
                throw new RangeError(
                    'Array limit exceeded. Only ' +
                        f.arrayLimit +
                        ' element' +
                        (f.arrayLimit === 1 ? '' : 's') +
                        ' allowed in an array.',
                )
            return d
        },
        a = 'utf8=%26%2310003%3B',
        o = 'utf8=%E2%9C%93',
        h = function (f, m) {
            var p = { __proto__: null },
                g = m.ignoreQueryPrefix ? f.replace(/^\?/, '') : f
            g = g.replace(/%5B/gi, '[').replace(/%5D/gi, ']')
            var _ = m.parameterLimit === 1 / 0 ? void 0 : m.parameterLimit,
                b = g.split(m.delimiter, m.throwOnLimitExceeded ? _ + 1 : _)
            if (m.throwOnLimitExceeded && b.length > _)
                throw new RangeError(
                    'Parameter limit exceeded. Only ' +
                        _ +
                        ' parameter' +
                        (_ === 1 ? '' : 's') +
                        ' allowed.',
                )
            var v = -1,
                w,
                x = m.charset
            if (m.charsetSentinel)
                for (w = 0; w < b.length; ++w)
                    b[w].indexOf('utf8=') === 0 &&
                        (b[w] === o
                            ? (x = 'utf-8')
                            : b[w] === a && (x = 'iso-8859-1'),
                        (v = w),
                        (w = b.length))
            for (w = 0; w < b.length; ++w)
                if (w !== v) {
                    var P = b[w],
                        y = P.indexOf(']='),
                        S = y === -1 ? P.indexOf('=') : y + 1,
                        R,
                        G
                    ;(S === -1
                        ? ((R = m.decoder(P, i.decoder, x, 'key')),
                          (G = m.strictNullHandling ? null : ''))
                        : ((R = m.decoder(P.slice(0, S), i.decoder, x, 'key')),
                          (G = s.maybeMap(
                              n(P.slice(S + 1), m, e(p[R]) ? p[R].length : 0),
                              function (I) {
                                  return m.decoder(I, i.decoder, x, 'value')
                              },
                          ))),
                        G &&
                            m.interpretNumericEntities &&
                            x === 'iso-8859-1' &&
                            (G = r(String(G))),
                        P.indexOf('[]=') > -1 && (G = e(G) ? [G] : G))
                    var N = t.call(p, R)
                    N && m.duplicates === 'combine'
                        ? (p[R] = s.combine(p[R], G))
                        : (!N || m.duplicates === 'last') && (p[R] = G)
                }
            return p
        },
        l = function (d, f, m, p) {
            var g = 0
            if (d.length > 0 && d[d.length - 1] === '[]') {
                var _ = d.slice(0, -1).join('')
                g = Array.isArray(f) && f[_] ? f[_].length : 0
            }
            for (var b = p ? f : n(f, m, g), v = d.length - 1; v >= 0; --v) {
                var w,
                    x = d[v]
                if (x === '[]' && m.parseArrays)
                    w =
                        m.allowEmptyArrays &&
                        (b === '' || (m.strictNullHandling && b === null))
                            ? []
                            : s.combine([], b)
                else {
                    w = m.plainObjects ? { __proto__: null } : {}
                    var P =
                            x.charAt(0) === '[' &&
                            x.charAt(x.length - 1) === ']'
                                ? x.slice(1, -1)
                                : x,
                        y = m.decodeDotInKeys ? P.replace(/%2E/g, '.') : P,
                        S = parseInt(y, 10)
                    !m.parseArrays && y === ''
                        ? (w = { 0: b })
                        : !isNaN(S) &&
                            x !== y &&
                            String(S) === y &&
                            S >= 0 &&
                            m.parseArrays &&
                            S <= m.arrayLimit
                          ? ((w = []), (w[S] = b))
                          : y !== '__proto__' && (w[y] = b)
                }
                b = w
            }
            return b
        },
        u = function (f, m, p, g) {
            if (f) {
                var _ = p.allowDots ? f.replace(/\.([^.[]+)/g, '[$1]') : f,
                    b = /(\[[^[\]]*])/,
                    v = /(\[[^[\]]*])/g,
                    w = p.depth > 0 && b.exec(_),
                    x = w ? _.slice(0, w.index) : _,
                    P = []
                if (x) {
                    if (
                        !p.plainObjects &&
                        t.call(Object.prototype, x) &&
                        !p.allowPrototypes
                    )
                        return
                    P.push(x)
                }
                for (
                    var y = 0;
                    p.depth > 0 && (w = v.exec(_)) !== null && y < p.depth;

                ) {
                    if (
                        ((y += 1),
                        !p.plainObjects &&
                            t.call(Object.prototype, w[1].slice(1, -1)) &&
                            !p.allowPrototypes)
                    )
                        return
                    P.push(w[1])
                }
                if (w) {
                    if (p.strictDepth === !0)
                        throw new RangeError(
                            'Input depth exceeded depth option of ' +
                                p.depth +
                                ' and strictDepth is true',
                        )
                    P.push('[' + _.slice(w.index) + ']')
                }
                return l(P, m, p, g)
            }
        },
        c = function (f) {
            if (!f) return i
            if (
                typeof f.allowEmptyArrays < 'u' &&
                typeof f.allowEmptyArrays != 'boolean'
            )
                throw new TypeError(
                    '`allowEmptyArrays` option can only be `true` or `false`, when provided',
                )
            if (
                typeof f.decodeDotInKeys < 'u' &&
                typeof f.decodeDotInKeys != 'boolean'
            )
                throw new TypeError(
                    '`decodeDotInKeys` option can only be `true` or `false`, when provided',
                )
            if (
                f.decoder !== null &&
                typeof f.decoder < 'u' &&
                typeof f.decoder != 'function'
            )
                throw new TypeError('Decoder has to be a function.')
            if (
                typeof f.charset < 'u' &&
                f.charset !== 'utf-8' &&
                f.charset !== 'iso-8859-1'
            )
                throw new TypeError(
                    'The charset option must be either utf-8, iso-8859-1, or undefined',
                )
            if (
                typeof f.throwOnLimitExceeded < 'u' &&
                typeof f.throwOnLimitExceeded != 'boolean'
            )
                throw new TypeError(
                    '`throwOnLimitExceeded` option must be a boolean',
                )
            var m = typeof f.charset > 'u' ? i.charset : f.charset,
                p = typeof f.duplicates > 'u' ? i.duplicates : f.duplicates
            if (p !== 'combine' && p !== 'first' && p !== 'last')
                throw new TypeError(
                    'The duplicates option must be either combine, first, or last',
                )
            var g =
                typeof f.allowDots > 'u'
                    ? f.decodeDotInKeys === !0
                        ? !0
                        : i.allowDots
                    : !!f.allowDots
            return {
                allowDots: g,
                allowEmptyArrays:
                    typeof f.allowEmptyArrays == 'boolean'
                        ? !!f.allowEmptyArrays
                        : i.allowEmptyArrays,
                allowPrototypes:
                    typeof f.allowPrototypes == 'boolean'
                        ? f.allowPrototypes
                        : i.allowPrototypes,
                allowSparse:
                    typeof f.allowSparse == 'boolean'
                        ? f.allowSparse
                        : i.allowSparse,
                arrayLimit:
                    typeof f.arrayLimit == 'number'
                        ? f.arrayLimit
                        : i.arrayLimit,
                charset: m,
                charsetSentinel:
                    typeof f.charsetSentinel == 'boolean'
                        ? f.charsetSentinel
                        : i.charsetSentinel,
                comma: typeof f.comma == 'boolean' ? f.comma : i.comma,
                decodeDotInKeys:
                    typeof f.decodeDotInKeys == 'boolean'
                        ? f.decodeDotInKeys
                        : i.decodeDotInKeys,
                decoder: typeof f.decoder == 'function' ? f.decoder : i.decoder,
                delimiter:
                    typeof f.delimiter == 'string' || s.isRegExp(f.delimiter)
                        ? f.delimiter
                        : i.delimiter,
                depth:
                    typeof f.depth == 'number' || f.depth === !1
                        ? +f.depth
                        : i.depth,
                duplicates: p,
                ignoreQueryPrefix: f.ignoreQueryPrefix === !0,
                interpretNumericEntities:
                    typeof f.interpretNumericEntities == 'boolean'
                        ? f.interpretNumericEntities
                        : i.interpretNumericEntities,
                parameterLimit:
                    typeof f.parameterLimit == 'number'
                        ? f.parameterLimit
                        : i.parameterLimit,
                parseArrays: f.parseArrays !== !1,
                plainObjects:
                    typeof f.plainObjects == 'boolean'
                        ? f.plainObjects
                        : i.plainObjects,
                strictDepth:
                    typeof f.strictDepth == 'boolean'
                        ? !!f.strictDepth
                        : i.strictDepth,
                strictNullHandling:
                    typeof f.strictNullHandling == 'boolean'
                        ? f.strictNullHandling
                        : i.strictNullHandling,
                throwOnLimitExceeded:
                    typeof f.throwOnLimitExceeded == 'boolean'
                        ? f.throwOnLimitExceeded
                        : !1,
            }
        }
    return (
        (Qa = function (d, f) {
            var m = c(f)
            if (d === '' || d === null || typeof d > 'u')
                return m.plainObjects ? { __proto__: null } : {}
            for (
                var p = typeof d == 'string' ? h(d, m) : d,
                    g = m.plainObjects ? { __proto__: null } : {},
                    _ = Object.keys(p),
                    b = 0;
                b < _.length;
                ++b
            ) {
                var v = _[b],
                    w = u(v, p[v], m, typeof d == 'string')
                g = s.merge(g, w, m)
            }
            return m.allowSparse === !0 ? g : s.compact(g)
        }),
        Qa
    )
}
var Ja, ec
function Zm() {
    if (ec) return Ja
    ec = 1
    var s = Ym(),
        t = Km(),
        e = zh()
    return ((Ja = { formats: e, parse: t, stringify: s }), Ja)
}
var ic
function Qm() {
    if (ic) return Ri
    ic = 1
    var s = ym()
    function t() {
        ;((this.protocol = null),
            (this.slashes = null),
            (this.auth = null),
            (this.host = null),
            (this.port = null),
            (this.hostname = null),
            (this.hash = null),
            (this.search = null),
            (this.query = null),
            (this.pathname = null),
            (this.path = null),
            (this.href = null))
    }
    var e = /^([a-z0-9.+-]+:)/i,
        i = /:[0-9]*$/,
        r = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/,
        n = [
            '<',
            '>',
            '"',
            '`',
            ' ',
            '\r',
            `
`,
            '	',
        ],
        a = ['{', '}', '|', '\\', '^', '`'].concat(n),
        o = ["'"].concat(a),
        h = ['%', '/', '?', ';', '#'].concat(o),
        l = ['/', '?', '#'],
        u = 255,
        c = /^[+a-z0-9A-Z_-]{0,63}$/,
        d = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
        f = { javascript: !0, 'javascript:': !0 },
        m = { javascript: !0, 'javascript:': !0 },
        p = {
            http: !0,
            https: !0,
            ftp: !0,
            gopher: !0,
            file: !0,
            'http:': !0,
            'https:': !0,
            'ftp:': !0,
            'gopher:': !0,
            'file:': !0,
        },
        g = Zm()
    function _(x, P, y) {
        if (x && typeof x == 'object' && x instanceof t) return x
        var S = new t()
        return (S.parse(x, P, y), S)
    }
    t.prototype.parse = function (x, P, y) {
        if (typeof x != 'string')
            throw new TypeError(
                "Parameter 'url' must be a string, not " + typeof x,
            )
        var S = x.indexOf('?'),
            R = S !== -1 && S < x.indexOf('#') ? '?' : '#',
            G = x.split(R),
            N = /\\/g
        ;((G[0] = G[0].replace(N, '/')), (x = G.join(R)))
        var I = x
        if (((I = I.trim()), !y && x.split('#').length === 1)) {
            var O = r.exec(I)
            if (O)
                return (
                    (this.path = I),
                    (this.href = I),
                    (this.pathname = O[1]),
                    O[2]
                        ? ((this.search = O[2]),
                          P
                              ? (this.query = g.parse(this.search.substr(1)))
                              : (this.query = this.search.substr(1)))
                        : P && ((this.search = ''), (this.query = {})),
                    this
                )
        }
        var L = e.exec(I)
        if (L) {
            L = L[0]
            var V = L.toLowerCase()
            ;((this.protocol = V), (I = I.substr(L.length)))
        }
        if (y || L || I.match(/^\/\/[^@/]+@[^@/]+/)) {
            var T = I.substr(0, 2) === '//'
            T && !(L && m[L]) && ((I = I.substr(2)), (this.slashes = !0))
        }
        if (!m[L] && (T || (L && !p[L]))) {
            for (var A = -1, E = 0; E < l.length; E++) {
                var B = I.indexOf(l[E])
                B !== -1 && (A === -1 || B < A) && (A = B)
            }
            var C, M
            ;(A === -1 ? (M = I.lastIndexOf('@')) : (M = I.lastIndexOf('@', A)),
                M !== -1 &&
                    ((C = I.slice(0, M)),
                    (I = I.slice(M + 1)),
                    (this.auth = decodeURIComponent(C))),
                (A = -1))
            for (var E = 0; E < h.length; E++) {
                var B = I.indexOf(h[E])
                B !== -1 && (A === -1 || B < A) && (A = B)
            }
            ;(A === -1 && (A = I.length),
                (this.host = I.slice(0, A)),
                (I = I.slice(A)),
                this.parseHost(),
                (this.hostname = this.hostname || ''))
            var D =
                this.hostname[0] === '[' &&
                this.hostname[this.hostname.length - 1] === ']'
            if (!D)
                for (
                    var F = this.hostname.split(/\./), E = 0, H = F.length;
                    E < H;
                    E++
                ) {
                    var z = F[E]
                    if (z && !z.match(c)) {
                        for (var K = '', Z = 0, J = z.length; Z < J; Z++)
                            z.charCodeAt(Z) > 127 ? (K += 'x') : (K += z[Z])
                        if (!K.match(c)) {
                            var rt = F.slice(0, E),
                                W = F.slice(E + 1),
                                et = z.match(d)
                            ;(et && (rt.push(et[1]), W.unshift(et[2])),
                                W.length && (I = '/' + W.join('.') + I),
                                (this.hostname = rt.join('.')))
                            break
                        }
                    }
                }
            ;(this.hostname.length > u
                ? (this.hostname = '')
                : (this.hostname = this.hostname.toLowerCase()),
                D || (this.hostname = s.toASCII(this.hostname)))
            var st = this.port ? ':' + this.port : '',
                ht = this.hostname || ''
            ;((this.host = ht + st),
                (this.href += this.host),
                D &&
                    ((this.hostname = this.hostname.substr(
                        1,
                        this.hostname.length - 2,
                    )),
                    I[0] !== '/' && (I = '/' + I)))
        }
        if (!f[V])
            for (var E = 0, H = o.length; E < H; E++) {
                var pt = o[E]
                if (I.indexOf(pt) !== -1) {
                    var it = encodeURIComponent(pt)
                    ;(it === pt && (it = escape(pt)),
                        (I = I.split(pt).join(it)))
                }
            }
        var nt = I.indexOf('#')
        nt !== -1 && ((this.hash = I.substr(nt)), (I = I.slice(0, nt)))
        var Mt = I.indexOf('?')
        if (
            (Mt !== -1
                ? ((this.search = I.substr(Mt)),
                  (this.query = I.substr(Mt + 1)),
                  P && (this.query = g.parse(this.query)),
                  (I = I.slice(0, Mt)))
                : P && ((this.search = ''), (this.query = {})),
            I && (this.pathname = I),
            p[V] && this.hostname && !this.pathname && (this.pathname = '/'),
            this.pathname || this.search)
        ) {
            var st = this.pathname || '',
                kt = this.search || ''
            this.path = st + kt
        }
        return ((this.href = this.format()), this)
    }
    function b(x) {
        return (
            typeof x == 'string' && (x = _(x)),
            x instanceof t ? x.format() : t.prototype.format.call(x)
        )
    }
    t.prototype.format = function () {
        var x = this.auth || ''
        x &&
            ((x = encodeURIComponent(x)),
            (x = x.replace(/%3A/i, ':')),
            (x += '@'))
        var P = this.protocol || '',
            y = this.pathname || '',
            S = this.hash || '',
            R = !1,
            G = ''
        ;(this.host
            ? (R = x + this.host)
            : this.hostname &&
              ((R =
                  x +
                  (this.hostname.indexOf(':') === -1
                      ? this.hostname
                      : '[' + this.hostname + ']')),
              this.port && (R += ':' + this.port)),
            this.query &&
                typeof this.query == 'object' &&
                Object.keys(this.query).length &&
                (G = g.stringify(this.query, {
                    arrayFormat: 'repeat',
                    addQueryPrefix: !1,
                })))
        var N = this.search || (G && '?' + G) || ''
        return (
            P && P.substr(-1) !== ':' && (P += ':'),
            this.slashes || ((!P || p[P]) && R !== !1)
                ? ((R = '//' + (R || '')),
                  y && y.charAt(0) !== '/' && (y = '/' + y))
                : R || (R = ''),
            S && S.charAt(0) !== '#' && (S = '#' + S),
            N && N.charAt(0) !== '?' && (N = '?' + N),
            (y = y.replace(/[?#]/g, function (I) {
                return encodeURIComponent(I)
            })),
            (N = N.replace('#', '%23')),
            P + R + y + N + S
        )
    }
    function v(x, P) {
        return _(x, !1, !0).resolve(P)
    }
    t.prototype.resolve = function (x) {
        return this.resolveObject(_(x, !1, !0)).format()
    }
    function w(x, P) {
        return x ? _(x, !1, !0).resolveObject(P) : P
    }
    return (
        (t.prototype.resolveObject = function (x) {
            if (typeof x == 'string') {
                var P = new t()
                ;(P.parse(x, !1, !0), (x = P))
            }
            for (
                var y = new t(), S = Object.keys(this), R = 0;
                R < S.length;
                R++
            ) {
                var G = S[R]
                y[G] = this[G]
            }
            if (((y.hash = x.hash), x.href === ''))
                return ((y.href = y.format()), y)
            if (x.slashes && !x.protocol) {
                for (var N = Object.keys(x), I = 0; I < N.length; I++) {
                    var O = N[I]
                    O !== 'protocol' && (y[O] = x[O])
                }
                return (
                    p[y.protocol] &&
                        y.hostname &&
                        !y.pathname &&
                        ((y.pathname = '/'), (y.path = y.pathname)),
                    (y.href = y.format()),
                    y
                )
            }
            if (x.protocol && x.protocol !== y.protocol) {
                if (!p[x.protocol]) {
                    for (var L = Object.keys(x), V = 0; V < L.length; V++) {
                        var T = L[V]
                        y[T] = x[T]
                    }
                    return ((y.href = y.format()), y)
                }
                if (((y.protocol = x.protocol), !x.host && !m[x.protocol])) {
                    for (
                        var H = (x.pathname || '').split('/');
                        H.length && !(x.host = H.shift());

                    );
                    ;(x.host || (x.host = ''),
                        x.hostname || (x.hostname = ''),
                        H[0] !== '' && H.unshift(''),
                        H.length < 2 && H.unshift(''),
                        (y.pathname = H.join('/')))
                } else y.pathname = x.pathname
                if (
                    ((y.search = x.search),
                    (y.query = x.query),
                    (y.host = x.host || ''),
                    (y.auth = x.auth),
                    (y.hostname = x.hostname || x.host),
                    (y.port = x.port),
                    y.pathname || y.search)
                ) {
                    var A = y.pathname || '',
                        E = y.search || ''
                    y.path = A + E
                }
                return (
                    (y.slashes = y.slashes || x.slashes),
                    (y.href = y.format()),
                    y
                )
            }
            var B = y.pathname && y.pathname.charAt(0) === '/',
                C = x.host || (x.pathname && x.pathname.charAt(0) === '/'),
                M = C || B || (y.host && x.pathname),
                D = M,
                F = (y.pathname && y.pathname.split('/')) || [],
                H = (x.pathname && x.pathname.split('/')) || [],
                z = y.protocol && !p[y.protocol]
            if (
                (z &&
                    ((y.hostname = ''),
                    (y.port = null),
                    y.host &&
                        (F[0] === '' ? (F[0] = y.host) : F.unshift(y.host)),
                    (y.host = ''),
                    x.protocol &&
                        ((x.hostname = null),
                        (x.port = null),
                        x.host &&
                            (H[0] === '' ? (H[0] = x.host) : H.unshift(x.host)),
                        (x.host = null)),
                    (M = M && (H[0] === '' || F[0] === ''))),
                C)
            )
                ((y.host = x.host || x.host === '' ? x.host : y.host),
                    (y.hostname =
                        x.hostname || x.hostname === ''
                            ? x.hostname
                            : y.hostname),
                    (y.search = x.search),
                    (y.query = x.query),
                    (F = H))
            else if (H.length)
                (F || (F = []),
                    F.pop(),
                    (F = F.concat(H)),
                    (y.search = x.search),
                    (y.query = x.query))
            else if (x.search != null) {
                if (z) {
                    ;((y.host = F.shift()), (y.hostname = y.host))
                    var K =
                        y.host && y.host.indexOf('@') > 0
                            ? y.host.split('@')
                            : !1
                    K &&
                        ((y.auth = K.shift()),
                        (y.hostname = K.shift()),
                        (y.host = y.hostname))
                }
                return (
                    (y.search = x.search),
                    (y.query = x.query),
                    (y.pathname !== null || y.search !== null) &&
                        (y.path =
                            (y.pathname ? y.pathname : '') +
                            (y.search ? y.search : '')),
                    (y.href = y.format()),
                    y
                )
            }
            if (!F.length)
                return (
                    (y.pathname = null),
                    y.search ? (y.path = '/' + y.search) : (y.path = null),
                    (y.href = y.format()),
                    y
                )
            for (
                var Z = F.slice(-1)[0],
                    J =
                        ((y.host || x.host || F.length > 1) &&
                            (Z === '.' || Z === '..')) ||
                        Z === '',
                    rt = 0,
                    W = F.length;
                W >= 0;
                W--
            )
                ((Z = F[W]),
                    Z === '.'
                        ? F.splice(W, 1)
                        : Z === '..'
                          ? (F.splice(W, 1), rt++)
                          : rt && (F.splice(W, 1), rt--))
            if (!M && !D) for (; rt--; rt) F.unshift('..')
            ;(M &&
                F[0] !== '' &&
                (!F[0] || F[0].charAt(0) !== '/') &&
                F.unshift(''),
                J && F.join('/').substr(-1) !== '/' && F.push(''))
            var et = F[0] === '' || (F[0] && F[0].charAt(0) === '/')
            if (z) {
                ;((y.hostname = et ? '' : F.length ? F.shift() : ''),
                    (y.host = y.hostname))
                var K =
                    y.host && y.host.indexOf('@') > 0 ? y.host.split('@') : !1
                K &&
                    ((y.auth = K.shift()),
                    (y.hostname = K.shift()),
                    (y.host = y.hostname))
            }
            return (
                (M = M || (y.host && F.length)),
                M && !et && F.unshift(''),
                F.length > 0
                    ? (y.pathname = F.join('/'))
                    : ((y.pathname = null), (y.path = null)),
                (y.pathname !== null || y.search !== null) &&
                    (y.path =
                        (y.pathname ? y.pathname : '') +
                        (y.search ? y.search : '')),
                (y.auth = x.auth || y.auth),
                (y.slashes = y.slashes || x.slashes),
                (y.href = y.format()),
                y
            )
        }),
        (t.prototype.parseHost = function () {
            var x = this.host,
                P = i.exec(x)
            ;(P &&
                ((P = P[0]),
                P !== ':' && (this.port = P.substr(1)),
                (x = x.substr(0, x.length - P.length))),
                x && (this.hostname = x))
        }),
        (Ri.parse = _),
        (Ri.resolve = v),
        (Ri.resolveObject = w),
        (Ri.format = b),
        (Ri.Url = t),
        Ri
    )
}
Qm()
const rc = {}
function ft(s, t, e = 3) {
    if (rc[t]) return
    let i = new Error().stack
    ;(typeof i > 'u'
        ? console.warn(
              'PixiJS Deprecation Warning: ',
              `${t}
Deprecated since v${s}`,
          )
        : ((i = i
              .split(
                  `
`,
              )
              .splice(e).join(`
`)),
          console.groupCollapsed
              ? (console.groupCollapsed(
                    '%cPixiJS Deprecation Warning: %c%s',
                    'color:#614108;background:#fffbe6',
                    'font-weight:normal;color:#614108;background:#fffbe6',
                    `${t}
Deprecated since v${s}`,
                ),
                console.warn(i),
                console.groupEnd())
              : (console.warn(
                    'PixiJS Deprecation Warning: ',
                    `${t}
Deprecated since v${s}`,
                ),
                console.warn(i))),
        (rc[t] = !0))
}
function xe(s) {
    if (typeof s != 'string')
        throw new TypeError(
            `Path must be a string. Received ${JSON.stringify(s)}`,
        )
}
function Xr(s) {
    return s.split('?')[0].split('#')[0]
}
function Jm(s) {
    return s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
}
function tg(s, t, e) {
    return s.replace(new RegExp(Jm(t), 'g'), e)
}
function eg(s, t) {
    let e = '',
        i = 0,
        r = -1,
        n = 0,
        a = -1
    for (let o = 0; o <= s.length; ++o) {
        if (o < s.length) a = s.charCodeAt(o)
        else {
            if (a === 47) break
            a = 47
        }
        if (a === 47) {
            if (!(r === o - 1 || n === 1))
                if (r !== o - 1 && n === 2) {
                    if (
                        e.length < 2 ||
                        i !== 2 ||
                        e.charCodeAt(e.length - 1) !== 46 ||
                        e.charCodeAt(e.length - 2) !== 46
                    ) {
                        if (e.length > 2) {
                            const h = e.lastIndexOf('/')
                            if (h !== e.length - 1) {
                                ;(h === -1
                                    ? ((e = ''), (i = 0))
                                    : ((e = e.slice(0, h)),
                                      (i = e.length - 1 - e.lastIndexOf('/'))),
                                    (r = o),
                                    (n = 0))
                                continue
                            }
                        } else if (e.length === 2 || e.length === 1) {
                            ;((e = ''), (i = 0), (r = o), (n = 0))
                            continue
                        }
                    }
                } else
                    (e.length > 0
                        ? (e += `/${s.slice(r + 1, o)}`)
                        : (e = s.slice(r + 1, o)),
                        (i = o - r - 1))
            ;((r = o), (n = 0))
        } else a === 46 && n !== -1 ? ++n : (n = -1)
    }
    return e
}
const Gt = {
    toPosix(s) {
        return tg(s, '\\', '/')
    },
    isUrl(s) {
        return /^https?:/.test(this.toPosix(s))
    },
    isDataUrl(s) {
        return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(
            s,
        )
    },
    isBlobUrl(s) {
        return s.startsWith('blob:')
    },
    hasProtocol(s) {
        return /^[^/:]+:/.test(this.toPosix(s))
    },
    getProtocol(s) {
        ;(xe(s), (s = this.toPosix(s)))
        const t = /^file:\/\/\//.exec(s)
        if (t) return t[0]
        const e = /^[^/:]+:\/{0,2}/.exec(s)
        return e ? e[0] : ''
    },
    toAbsolute(s, t, e) {
        if ((xe(s), this.isDataUrl(s) || this.isBlobUrl(s))) return s
        const i = Xr(this.toPosix(t ?? Y.ADAPTER.getBaseUrl())),
            r = Xr(this.toPosix(e ?? this.rootname(i)))
        return (
            (s = this.toPosix(s)),
            s.startsWith('/')
                ? Gt.join(r, s.slice(1))
                : this.isAbsolute(s)
                  ? s
                  : this.join(i, s)
        )
    },
    normalize(s) {
        if ((xe(s), s.length === 0)) return '.'
        if (this.isDataUrl(s) || this.isBlobUrl(s)) return s
        s = this.toPosix(s)
        let t = ''
        const e = s.startsWith('/')
        this.hasProtocol(s) && ((t = this.rootname(s)), (s = s.slice(t.length)))
        const i = s.endsWith('/')
        return (
            (s = eg(s)),
            s.length > 0 && i && (s += '/'),
            e ? `/${s}` : t + s
        )
    },
    isAbsolute(s) {
        return (
            xe(s),
            (s = this.toPosix(s)),
            this.hasProtocol(s) ? !0 : s.startsWith('/')
        )
    },
    join(...s) {
        if (s.length === 0) return '.'
        let t
        for (let e = 0; e < s.length; ++e) {
            const i = s[e]
            if ((xe(i), i.length > 0))
                if (t === void 0) t = i
                else {
                    const r = s[e - 1] ?? ''
                    this.joinExtensions.includes(this.extname(r).toLowerCase())
                        ? (t += `/../${i}`)
                        : (t += `/${i}`)
                }
        }
        return t === void 0 ? '.' : this.normalize(t)
    },
    dirname(s) {
        if ((xe(s), s.length === 0)) return '.'
        s = this.toPosix(s)
        let t = s.charCodeAt(0)
        const e = t === 47
        let i = -1,
            r = !0
        const n = this.getProtocol(s),
            a = s
        s = s.slice(n.length)
        for (let o = s.length - 1; o >= 1; --o)
            if (((t = s.charCodeAt(o)), t === 47)) {
                if (!r) {
                    i = o
                    break
                }
            } else r = !1
        return i === -1
            ? e
                ? '/'
                : this.isUrl(a)
                  ? n + s
                  : n
            : e && i === 1
              ? '//'
              : n + s.slice(0, i)
    },
    rootname(s) {
        ;(xe(s), (s = this.toPosix(s)))
        let t = ''
        if (
            (s.startsWith('/') ? (t = '/') : (t = this.getProtocol(s)),
            this.isUrl(s))
        ) {
            const e = s.indexOf('/', t.length)
            ;(e !== -1 ? (t = s.slice(0, e)) : (t = s),
                t.endsWith('/') || (t += '/'))
        }
        return t
    },
    basename(s, t) {
        ;(xe(s), t && xe(t), (s = Xr(this.toPosix(s))))
        let e = 0,
            i = -1,
            r = !0,
            n
        if (t !== void 0 && t.length > 0 && t.length <= s.length) {
            if (t.length === s.length && t === s) return ''
            let a = t.length - 1,
                o = -1
            for (n = s.length - 1; n >= 0; --n) {
                const h = s.charCodeAt(n)
                if (h === 47) {
                    if (!r) {
                        e = n + 1
                        break
                    }
                } else
                    (o === -1 && ((r = !1), (o = n + 1)),
                        a >= 0 &&
                            (h === t.charCodeAt(a)
                                ? --a === -1 && (i = n)
                                : ((a = -1), (i = o))))
            }
            return (
                e === i ? (i = o) : i === -1 && (i = s.length),
                s.slice(e, i)
            )
        }
        for (n = s.length - 1; n >= 0; --n)
            if (s.charCodeAt(n) === 47) {
                if (!r) {
                    e = n + 1
                    break
                }
            } else i === -1 && ((r = !1), (i = n + 1))
        return i === -1 ? '' : s.slice(e, i)
    },
    extname(s) {
        ;(xe(s), (s = Xr(this.toPosix(s))))
        let t = -1,
            e = 0,
            i = -1,
            r = !0,
            n = 0
        for (let a = s.length - 1; a >= 0; --a) {
            const o = s.charCodeAt(a)
            if (o === 47) {
                if (!r) {
                    e = a + 1
                    break
                }
                continue
            }
            ;(i === -1 && ((r = !1), (i = a + 1)),
                o === 46
                    ? t === -1
                        ? (t = a)
                        : n !== 1 && (n = 1)
                    : t !== -1 && (n = -1))
        }
        return t === -1 ||
            i === -1 ||
            n === 0 ||
            (n === 1 && t === i - 1 && t === e + 1)
            ? ''
            : s.slice(t, i)
    },
    parse(s) {
        xe(s)
        const t = { root: '', dir: '', base: '', ext: '', name: '' }
        if (s.length === 0) return t
        s = Xr(this.toPosix(s))
        let e = s.charCodeAt(0)
        const i = this.isAbsolute(s)
        let r
        ;((t.root = this.rootname(s)),
            i || this.hasProtocol(s) ? (r = 1) : (r = 0))
        let n = -1,
            a = 0,
            o = -1,
            h = !0,
            l = s.length - 1,
            u = 0
        for (; l >= r; --l) {
            if (((e = s.charCodeAt(l)), e === 47)) {
                if (!h) {
                    a = l + 1
                    break
                }
                continue
            }
            ;(o === -1 && ((h = !1), (o = l + 1)),
                e === 46
                    ? n === -1
                        ? (n = l)
                        : u !== 1 && (u = 1)
                    : n !== -1 && (u = -1))
        }
        return (
            n === -1 ||
            o === -1 ||
            u === 0 ||
            (u === 1 && n === o - 1 && n === a + 1)
                ? o !== -1 &&
                  (a === 0 && i
                      ? (t.base = t.name = s.slice(1, o))
                      : (t.base = t.name = s.slice(a, o)))
                : (a === 0 && i
                      ? ((t.name = s.slice(1, n)), (t.base = s.slice(1, o)))
                      : ((t.name = s.slice(a, n)), (t.base = s.slice(a, o))),
                  (t.ext = s.slice(n, o))),
            (t.dir = this.dirname(s)),
            t
        )
    },
    sep: '/',
    delimiter: ':',
    joinExtensions: ['.html'],
}
let to
async function ig() {
    return (
        to ??
            (to = (async () => {
                const s = document.createElement('canvas').getContext('webgl')
                if (!s) return Zt.UNPACK
                const t = await new Promise(n => {
                    const a = document.createElement('video')
                    ;((a.onloadeddata = () => n(a)),
                        (a.onerror = () => n(null)),
                        (a.autoplay = !1),
                        (a.crossOrigin = 'anonymous'),
                        (a.preload = 'auto'),
                        (a.src =
                            'data:video/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQJChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmoCrXsYMPQkBNgIRMYXZmV0GETGF2ZkSJiEBEAAAAAAAAFlSua8yuAQAAAAAAAEPXgQFzxYgAAAAAAAAAAZyBACK1nIN1bmSIgQCGhVZfVlA5g4EBI+ODhAJiWgDglLCBArqBApqBAlPAgQFVsIRVuYEBElTDZ9Vzc9JjwItjxYgAAAAAAAAAAWfInEWjh0VOQ09ERVJEh49MYXZjIGxpYnZweC12cDlnyKJFo4hEVVJBVElPTkSHlDAwOjAwOjAwLjA0MDAwMDAwMAAAH0O2dcfngQCgwqGggQAAAIJJg0IAABAAFgA4JBwYSgAAICAAEb///4r+AAB1oZ2mm+6BAaWWgkmDQgAAEAAWADgkHBhKAAAgIABIQBxTu2uRu4+zgQC3iveBAfGCAXHwgQM='),
                        a.load())
                })
                if (!t) return Zt.UNPACK
                const e = s.createTexture()
                s.bindTexture(s.TEXTURE_2D, e)
                const i = s.createFramebuffer()
                ;(s.bindFramebuffer(s.FRAMEBUFFER, i),
                    s.framebufferTexture2D(
                        s.FRAMEBUFFER,
                        s.COLOR_ATTACHMENT0,
                        s.TEXTURE_2D,
                        e,
                        0,
                    ),
                    s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1),
                    s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, s.NONE),
                    s.texImage2D(
                        s.TEXTURE_2D,
                        0,
                        s.RGBA,
                        s.RGBA,
                        s.UNSIGNED_BYTE,
                        t,
                    ))
                const r = new Uint8Array(4)
                return (
                    s.readPixels(0, 0, 1, 1, s.RGBA, s.UNSIGNED_BYTE, r),
                    s.deleteFramebuffer(i),
                    s.deleteTexture(e),
                    s.getExtension('WEBGL_lose_context')?.loseContext(),
                    r[0] <= r[3] ? Zt.PMA : Zt.UNPACK
                )
            })()),
        to
    )
}
let eo
function rg() {
    return (
        typeof eo > 'u' &&
            (eo = (function () {
                const s = {
                    stencil: !0,
                    failIfMajorPerformanceCaveat:
                        Y.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT,
                }
                try {
                    if (!Y.ADAPTER.getWebGLRenderingContext()) return !1
                    const t = Y.ADAPTER.createCanvas()
                    let e =
                        t.getContext('webgl', s) ||
                        t.getContext('experimental-webgl', s)
                    const i = !!e?.getContextAttributes()?.stencil
                    if (e) {
                        const r = e.getExtension('WEBGL_lose_context')
                        r && r.loseContext()
                    }
                    return ((e = null), i)
                } catch {
                    return !1
                }
            })()),
        eo
    )
}
var sg = { grad: 0.9, turn: 360, rad: 360 / (2 * Math.PI) },
    qe = function (s) {
        return typeof s == 'string' ? s.length > 0 : typeof s == 'number'
    },
    Ut = function (s, t, e) {
        return (
            t === void 0 && (t = 0),
            e === void 0 && (e = Math.pow(10, t)),
            Math.round(e * s) / e + 0
        )
    },
    pe = function (s, t, e) {
        return (
            t === void 0 && (t = 0),
            e === void 0 && (e = 1),
            s > e ? e : s > t ? s : t
        )
    },
    Cd = function (s) {
        return (s = isFinite(s) ? s % 360 : 0) > 0 ? s : s + 360
    },
    sc = function (s) {
        return {
            r: pe(s.r, 0, 255),
            g: pe(s.g, 0, 255),
            b: pe(s.b, 0, 255),
            a: pe(s.a),
        }
    },
    io = function (s) {
        return { r: Ut(s.r), g: Ut(s.g), b: Ut(s.b), a: Ut(s.a, 3) }
    },
    ng = /^#([0-9a-f]{3,8})$/i,
    Is = function (s) {
        var t = s.toString(16)
        return t.length < 2 ? '0' + t : t
    },
    Pd = function (s) {
        var t = s.r,
            e = s.g,
            i = s.b,
            r = s.a,
            n = Math.max(t, e, i),
            a = n - Math.min(t, e, i),
            o = a
                ? n === t
                    ? (e - i) / a
                    : n === e
                      ? 2 + (i - t) / a
                      : 4 + (t - e) / a
                : 0
        return {
            h: 60 * (o < 0 ? o + 6 : o),
            s: n ? (a / n) * 100 : 0,
            v: (n / 255) * 100,
            a: r,
        }
    },
    Rd = function (s) {
        var t = s.h,
            e = s.s,
            i = s.v,
            r = s.a
        ;((t = (t / 360) * 6), (e /= 100), (i /= 100))
        var n = Math.floor(t),
            a = i * (1 - e),
            o = i * (1 - (t - n) * e),
            h = i * (1 - (1 - t + n) * e),
            l = n % 6
        return {
            r: 255 * [i, o, a, a, h, i][l],
            g: 255 * [h, i, i, o, a, a][l],
            b: 255 * [a, a, h, i, i, o][l],
            a: r,
        }
    },
    nc = function (s) {
        return {
            h: Cd(s.h),
            s: pe(s.s, 0, 100),
            l: pe(s.l, 0, 100),
            a: pe(s.a),
        }
    },
    ac = function (s) {
        return { h: Ut(s.h), s: Ut(s.s), l: Ut(s.l), a: Ut(s.a, 3) }
    },
    oc = function (s) {
        return Rd(
            ((e = (t = s).s),
            {
                h: t.h,
                s:
                    (e *= ((i = t.l) < 50 ? i : 100 - i) / 100) > 0
                        ? ((2 * e) / (i + e)) * 100
                        : 0,
                v: i + e,
                a: t.a,
            }),
        )
        var t, e, i
    },
    ns = function (s) {
        return {
            h: (t = Pd(s)).h,
            s:
                (r = ((200 - (e = t.s)) * (i = t.v)) / 100) > 0 && r < 200
                    ? ((e * i) / 100 / (r <= 100 ? r : 200 - r)) * 100
                    : 0,
            l: r / 2,
            a: t.a,
        }
        var t, e, i, r
    },
    ag =
        /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s*,\s*([+-]?\d*\.?\d+)%\s*,\s*([+-]?\d*\.?\d+)%\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
    og =
        /^hsla?\(\s*([+-]?\d*\.?\d+)(deg|rad|grad|turn)?\s+([+-]?\d*\.?\d+)%\s+([+-]?\d*\.?\d+)%\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
    hg =
        /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*,\s*([+-]?\d*\.?\d+)(%)?\s*(?:,\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
    lg =
        /^rgba?\(\s*([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s+([+-]?\d*\.?\d+)(%)?\s*(?:\/\s*([+-]?\d*\.?\d+)(%)?\s*)?\)$/i,
    No = {
        string: [
            [
                function (s) {
                    var t = ng.exec(s)
                    return t
                        ? (s = t[1]).length <= 4
                            ? {
                                  r: parseInt(s[0] + s[0], 16),
                                  g: parseInt(s[1] + s[1], 16),
                                  b: parseInt(s[2] + s[2], 16),
                                  a:
                                      s.length === 4
                                          ? Ut(
                                                parseInt(s[3] + s[3], 16) / 255,
                                                2,
                                            )
                                          : 1,
                              }
                            : s.length === 6 || s.length === 8
                              ? {
                                    r: parseInt(s.substr(0, 2), 16),
                                    g: parseInt(s.substr(2, 2), 16),
                                    b: parseInt(s.substr(4, 2), 16),
                                    a:
                                        s.length === 8
                                            ? Ut(
                                                  parseInt(s.substr(6, 2), 16) /
                                                      255,
                                                  2,
                                              )
                                            : 1,
                                }
                              : null
                        : null
                },
                'hex',
            ],
            [
                function (s) {
                    var t = hg.exec(s) || lg.exec(s)
                    return t
                        ? t[2] !== t[4] || t[4] !== t[6]
                            ? null
                            : sc({
                                  r: Number(t[1]) / (t[2] ? 100 / 255 : 1),
                                  g: Number(t[3]) / (t[4] ? 100 / 255 : 1),
                                  b: Number(t[5]) / (t[6] ? 100 / 255 : 1),
                                  a:
                                      t[7] === void 0
                                          ? 1
                                          : Number(t[7]) / (t[8] ? 100 : 1),
                              })
                        : null
                },
                'rgb',
            ],
            [
                function (s) {
                    var t = ag.exec(s) || og.exec(s)
                    if (!t) return null
                    var e,
                        i,
                        r = nc({
                            h:
                                ((e = t[1]),
                                (i = t[2]),
                                i === void 0 && (i = 'deg'),
                                Number(e) * (sg[i] || 1)),
                            s: Number(t[3]),
                            l: Number(t[4]),
                            a:
                                t[5] === void 0
                                    ? 1
                                    : Number(t[5]) / (t[6] ? 100 : 1),
                        })
                    return oc(r)
                },
                'hsl',
            ],
        ],
        object: [
            [
                function (s) {
                    var t = s.r,
                        e = s.g,
                        i = s.b,
                        r = s.a,
                        n = r === void 0 ? 1 : r
                    return qe(t) && qe(e) && qe(i)
                        ? sc({
                              r: Number(t),
                              g: Number(e),
                              b: Number(i),
                              a: Number(n),
                          })
                        : null
                },
                'rgb',
            ],
            [
                function (s) {
                    var t = s.h,
                        e = s.s,
                        i = s.l,
                        r = s.a,
                        n = r === void 0 ? 1 : r
                    if (!qe(t) || !qe(e) || !qe(i)) return null
                    var a = nc({
                        h: Number(t),
                        s: Number(e),
                        l: Number(i),
                        a: Number(n),
                    })
                    return oc(a)
                },
                'hsl',
            ],
            [
                function (s) {
                    var t = s.h,
                        e = s.s,
                        i = s.v,
                        r = s.a,
                        n = r === void 0 ? 1 : r
                    if (!qe(t) || !qe(e) || !qe(i)) return null
                    var a = (function (o) {
                        return {
                            h: Cd(o.h),
                            s: pe(o.s, 0, 100),
                            v: pe(o.v, 0, 100),
                            a: pe(o.a),
                        }
                    })({
                        h: Number(t),
                        s: Number(e),
                        v: Number(i),
                        a: Number(n),
                    })
                    return Rd(a)
                },
                'hsv',
            ],
        ],
    },
    hc = function (s, t) {
        for (var e = 0; e < t.length; e++) {
            var i = t[e][0](s)
            if (i) return [i, t[e][1]]
        }
        return [null, void 0]
    },
    ug = function (s) {
        return typeof s == 'string'
            ? hc(s.trim(), No.string)
            : typeof s == 'object' && s !== null
              ? hc(s, No.object)
              : [null, void 0]
    },
    ro = function (s, t) {
        var e = ns(s)
        return { h: e.h, s: pe(e.s + 100 * t, 0, 100), l: e.l, a: e.a }
    },
    so = function (s) {
        return (299 * s.r + 587 * s.g + 114 * s.b) / 1e3 / 255
    },
    lc = function (s, t) {
        var e = ns(s)
        return { h: e.h, s: e.s, l: pe(e.l + 100 * t, 0, 100), a: e.a }
    },
    Uo = (function () {
        function s(t) {
            ;((this.parsed = ug(t)[0]),
                (this.rgba = this.parsed || { r: 0, g: 0, b: 0, a: 1 }))
        }
        return (
            (s.prototype.isValid = function () {
                return this.parsed !== null
            }),
            (s.prototype.brightness = function () {
                return Ut(so(this.rgba), 2)
            }),
            (s.prototype.isDark = function () {
                return so(this.rgba) < 0.5
            }),
            (s.prototype.isLight = function () {
                return so(this.rgba) >= 0.5
            }),
            (s.prototype.toHex = function () {
                return (
                    (t = io(this.rgba)),
                    (e = t.r),
                    (i = t.g),
                    (r = t.b),
                    (a = (n = t.a) < 1 ? Is(Ut(255 * n)) : ''),
                    '#' + Is(e) + Is(i) + Is(r) + a
                )
                var t, e, i, r, n, a
            }),
            (s.prototype.toRgb = function () {
                return io(this.rgba)
            }),
            (s.prototype.toRgbString = function () {
                return (
                    (t = io(this.rgba)),
                    (e = t.r),
                    (i = t.g),
                    (r = t.b),
                    (n = t.a) < 1
                        ? 'rgba(' + e + ', ' + i + ', ' + r + ', ' + n + ')'
                        : 'rgb(' + e + ', ' + i + ', ' + r + ')'
                )
                var t, e, i, r, n
            }),
            (s.prototype.toHsl = function () {
                return ac(ns(this.rgba))
            }),
            (s.prototype.toHslString = function () {
                return (
                    (t = ac(ns(this.rgba))),
                    (e = t.h),
                    (i = t.s),
                    (r = t.l),
                    (n = t.a) < 1
                        ? 'hsla(' + e + ', ' + i + '%, ' + r + '%, ' + n + ')'
                        : 'hsl(' + e + ', ' + i + '%, ' + r + '%)'
                )
                var t, e, i, r, n
            }),
            (s.prototype.toHsv = function () {
                return (
                    (t = Pd(this.rgba)),
                    { h: Ut(t.h), s: Ut(t.s), v: Ut(t.v), a: Ut(t.a, 3) }
                )
                var t
            }),
            (s.prototype.invert = function () {
                return Re({
                    r: 255 - (t = this.rgba).r,
                    g: 255 - t.g,
                    b: 255 - t.b,
                    a: t.a,
                })
                var t
            }),
            (s.prototype.saturate = function (t) {
                return (t === void 0 && (t = 0.1), Re(ro(this.rgba, t)))
            }),
            (s.prototype.desaturate = function (t) {
                return (t === void 0 && (t = 0.1), Re(ro(this.rgba, -t)))
            }),
            (s.prototype.grayscale = function () {
                return Re(ro(this.rgba, -1))
            }),
            (s.prototype.lighten = function (t) {
                return (t === void 0 && (t = 0.1), Re(lc(this.rgba, t)))
            }),
            (s.prototype.darken = function (t) {
                return (t === void 0 && (t = 0.1), Re(lc(this.rgba, -t)))
            }),
            (s.prototype.rotate = function (t) {
                return (t === void 0 && (t = 15), this.hue(this.hue() + t))
            }),
            (s.prototype.alpha = function (t) {
                return typeof t == 'number'
                    ? Re({ r: (e = this.rgba).r, g: e.g, b: e.b, a: t })
                    : Ut(this.rgba.a, 3)
                var e
            }),
            (s.prototype.hue = function (t) {
                var e = ns(this.rgba)
                return typeof t == 'number'
                    ? Re({ h: t, s: e.s, l: e.l, a: e.a })
                    : Ut(e.h)
            }),
            (s.prototype.isEqual = function (t) {
                return this.toHex() === Re(t).toHex()
            }),
            s
        )
    })(),
    Re = function (s) {
        return s instanceof Uo ? s : new Uo(s)
    },
    uc = [],
    cg = function (s) {
        s.forEach(function (t) {
            uc.indexOf(t) < 0 && (t(Uo, No), uc.push(t))
        })
    }
function dg(s, t) {
    var e = {
            white: '#ffffff',
            bisque: '#ffe4c4',
            blue: '#0000ff',
            cadetblue: '#5f9ea0',
            chartreuse: '#7fff00',
            chocolate: '#d2691e',
            coral: '#ff7f50',
            antiquewhite: '#faebd7',
            aqua: '#00ffff',
            azure: '#f0ffff',
            whitesmoke: '#f5f5f5',
            papayawhip: '#ffefd5',
            plum: '#dda0dd',
            blanchedalmond: '#ffebcd',
            black: '#000000',
            gold: '#ffd700',
            goldenrod: '#daa520',
            gainsboro: '#dcdcdc',
            cornsilk: '#fff8dc',
            cornflowerblue: '#6495ed',
            burlywood: '#deb887',
            aquamarine: '#7fffd4',
            beige: '#f5f5dc',
            crimson: '#dc143c',
            cyan: '#00ffff',
            darkblue: '#00008b',
            darkcyan: '#008b8b',
            darkgoldenrod: '#b8860b',
            darkkhaki: '#bdb76b',
            darkgray: '#a9a9a9',
            darkgreen: '#006400',
            darkgrey: '#a9a9a9',
            peachpuff: '#ffdab9',
            darkmagenta: '#8b008b',
            darkred: '#8b0000',
            darkorchid: '#9932cc',
            darkorange: '#ff8c00',
            darkslateblue: '#483d8b',
            gray: '#808080',
            darkslategray: '#2f4f4f',
            darkslategrey: '#2f4f4f',
            deeppink: '#ff1493',
            deepskyblue: '#00bfff',
            wheat: '#f5deb3',
            firebrick: '#b22222',
            floralwhite: '#fffaf0',
            ghostwhite: '#f8f8ff',
            darkviolet: '#9400d3',
            magenta: '#ff00ff',
            green: '#008000',
            dodgerblue: '#1e90ff',
            grey: '#808080',
            honeydew: '#f0fff0',
            hotpink: '#ff69b4',
            blueviolet: '#8a2be2',
            forestgreen: '#228b22',
            lawngreen: '#7cfc00',
            indianred: '#cd5c5c',
            indigo: '#4b0082',
            fuchsia: '#ff00ff',
            brown: '#a52a2a',
            maroon: '#800000',
            mediumblue: '#0000cd',
            lightcoral: '#f08080',
            darkturquoise: '#00ced1',
            lightcyan: '#e0ffff',
            ivory: '#fffff0',
            lightyellow: '#ffffe0',
            lightsalmon: '#ffa07a',
            lightseagreen: '#20b2aa',
            linen: '#faf0e6',
            mediumaquamarine: '#66cdaa',
            lemonchiffon: '#fffacd',
            lime: '#00ff00',
            khaki: '#f0e68c',
            mediumseagreen: '#3cb371',
            limegreen: '#32cd32',
            mediumspringgreen: '#00fa9a',
            lightskyblue: '#87cefa',
            lightblue: '#add8e6',
            midnightblue: '#191970',
            lightpink: '#ffb6c1',
            mistyrose: '#ffe4e1',
            moccasin: '#ffe4b5',
            mintcream: '#f5fffa',
            lightslategray: '#778899',
            lightslategrey: '#778899',
            navajowhite: '#ffdead',
            navy: '#000080',
            mediumvioletred: '#c71585',
            powderblue: '#b0e0e6',
            palegoldenrod: '#eee8aa',
            oldlace: '#fdf5e6',
            paleturquoise: '#afeeee',
            mediumturquoise: '#48d1cc',
            mediumorchid: '#ba55d3',
            rebeccapurple: '#663399',
            lightsteelblue: '#b0c4de',
            mediumslateblue: '#7b68ee',
            thistle: '#d8bfd8',
            tan: '#d2b48c',
            orchid: '#da70d6',
            mediumpurple: '#9370db',
            purple: '#800080',
            pink: '#ffc0cb',
            skyblue: '#87ceeb',
            springgreen: '#00ff7f',
            palegreen: '#98fb98',
            red: '#ff0000',
            yellow: '#ffff00',
            slateblue: '#6a5acd',
            lavenderblush: '#fff0f5',
            peru: '#cd853f',
            palevioletred: '#db7093',
            violet: '#ee82ee',
            teal: '#008080',
            slategray: '#708090',
            slategrey: '#708090',
            aliceblue: '#f0f8ff',
            darkseagreen: '#8fbc8f',
            darkolivegreen: '#556b2f',
            greenyellow: '#adff2f',
            seagreen: '#2e8b57',
            seashell: '#fff5ee',
            tomato: '#ff6347',
            silver: '#c0c0c0',
            sienna: '#a0522d',
            lavender: '#e6e6fa',
            lightgreen: '#90ee90',
            orange: '#ffa500',
            orangered: '#ff4500',
            steelblue: '#4682b4',
            royalblue: '#4169e1',
            turquoise: '#40e0d0',
            yellowgreen: '#9acd32',
            salmon: '#fa8072',
            saddlebrown: '#8b4513',
            sandybrown: '#f4a460',
            rosybrown: '#bc8f8f',
            darksalmon: '#e9967a',
            lightgoldenrodyellow: '#fafad2',
            snow: '#fffafa',
            lightgrey: '#d3d3d3',
            lightgray: '#d3d3d3',
            dimgray: '#696969',
            dimgrey: '#696969',
            olivedrab: '#6b8e23',
            olive: '#808000',
        },
        i = {}
    for (var r in e) i[e[r]] = r
    var n = {}
    ;((s.prototype.toName = function (a) {
        if (!(this.rgba.a || this.rgba.r || this.rgba.g || this.rgba.b))
            return 'transparent'
        var o,
            h,
            l = i[this.toHex()]
        if (l) return l
        if (a?.closest) {
            var u = this.toRgb(),
                c = 1 / 0,
                d = 'black'
            if (!n.length) for (var f in e) n[f] = new s(e[f]).toRgb()
            for (var m in e) {
                var p =
                    ((o = u),
                    (h = n[m]),
                    Math.pow(o.r - h.r, 2) +
                        Math.pow(o.g - h.g, 2) +
                        Math.pow(o.b - h.b, 2))
                p < c && ((c = p), (d = m))
            }
            return d
        }
    }),
        t.string.push([
            function (a) {
                var o = a.toLowerCase(),
                    h = o === 'transparent' ? '#0000' : e[o]
                return h ? new s(h).toRgb() : null
            },
            'name',
        ]))
}
cg([dg])
const fr = class Js {
    constructor(t = 16777215) {
        ;((this._value = null),
            (this._components = new Float32Array(4)),
            this._components.fill(1),
            (this._int = 16777215),
            (this.value = t))
    }
    get red() {
        return this._components[0]
    }
    get green() {
        return this._components[1]
    }
    get blue() {
        return this._components[2]
    }
    get alpha() {
        return this._components[3]
    }
    setValue(t) {
        return ((this.value = t), this)
    }
    set value(t) {
        if (t instanceof Js)
            ((this._value = this.cloneSource(t._value)),
                (this._int = t._int),
                this._components.set(t._components))
        else {
            if (t === null)
                throw new Error('Cannot set PIXI.Color#value to null')
            ;(this._value === null || !this.isSourceEqual(this._value, t)) &&
                (this.normalize(t), (this._value = this.cloneSource(t)))
        }
    }
    get value() {
        return this._value
    }
    cloneSource(t) {
        return typeof t == 'string' ||
            typeof t == 'number' ||
            t instanceof Number ||
            t === null
            ? t
            : Array.isArray(t) || ArrayBuffer.isView(t)
              ? t.slice(0)
              : typeof t == 'object' && t !== null
                ? { ...t }
                : t
    }
    isSourceEqual(t, e) {
        const i = typeof t
        if (i !== typeof e) return !1
        if (i === 'number' || i === 'string' || t instanceof Number)
            return t === e
        if (
            (Array.isArray(t) && Array.isArray(e)) ||
            (ArrayBuffer.isView(t) && ArrayBuffer.isView(e))
        )
            return t.length !== e.length ? !1 : t.every((r, n) => r === e[n])
        if (t !== null && e !== null) {
            const r = Object.keys(t),
                n = Object.keys(e)
            return r.length !== n.length ? !1 : r.every(a => t[a] === e[a])
        }
        return t === e
    }
    toRgba() {
        const [t, e, i, r] = this._components
        return { r: t, g: e, b: i, a: r }
    }
    toRgb() {
        const [t, e, i] = this._components
        return { r: t, g: e, b: i }
    }
    toRgbaString() {
        const [t, e, i] = this.toUint8RgbArray()
        return `rgba(${t},${e},${i},${this.alpha})`
    }
    toUint8RgbArray(t) {
        const [e, i, r] = this._components
        return (
            (t = t ?? []),
            (t[0] = Math.round(e * 255)),
            (t[1] = Math.round(i * 255)),
            (t[2] = Math.round(r * 255)),
            t
        )
    }
    toRgbArray(t) {
        t = t ?? []
        const [e, i, r] = this._components
        return ((t[0] = e), (t[1] = i), (t[2] = r), t)
    }
    toNumber() {
        return this._int
    }
    toLittleEndianNumber() {
        const t = this._int
        return (t >> 16) + (t & 65280) + ((t & 255) << 16)
    }
    multiply(t) {
        const [e, i, r, n] = Js.temp.setValue(t)._components
        return (
            (this._components[0] *= e),
            (this._components[1] *= i),
            (this._components[2] *= r),
            (this._components[3] *= n),
            this.refreshInt(),
            (this._value = null),
            this
        )
    }
    premultiply(t, e = !0) {
        return (
            e &&
                ((this._components[0] *= t),
                (this._components[1] *= t),
                (this._components[2] *= t)),
            (this._components[3] = t),
            this.refreshInt(),
            (this._value = null),
            this
        )
    }
    toPremultiplied(t, e = !0) {
        if (t === 1) return (255 << 24) + this._int
        if (t === 0) return e ? 0 : this._int
        let i = (this._int >> 16) & 255,
            r = (this._int >> 8) & 255,
            n = this._int & 255
        return (
            e &&
                ((i = (i * t + 0.5) | 0),
                (r = (r * t + 0.5) | 0),
                (n = (n * t + 0.5) | 0)),
            ((t * 255) << 24) + (i << 16) + (r << 8) + n
        )
    }
    toHex() {
        const t = this._int.toString(16)
        return `#${'000000'.substring(0, 6 - t.length) + t}`
    }
    toHexa() {
        const t = Math.round(this._components[3] * 255).toString(16)
        return this.toHex() + '00'.substring(0, 2 - t.length) + t
    }
    setAlpha(t) {
        return ((this._components[3] = this._clamp(t)), this)
    }
    round(t) {
        const [e, i, r] = this._components
        return (
            (this._components[0] = Math.round(e * t) / t),
            (this._components[1] = Math.round(i * t) / t),
            (this._components[2] = Math.round(r * t) / t),
            this.refreshInt(),
            (this._value = null),
            this
        )
    }
    toArray(t) {
        t = t ?? []
        const [e, i, r, n] = this._components
        return ((t[0] = e), (t[1] = i), (t[2] = r), (t[3] = n), t)
    }
    normalize(t) {
        let e, i, r, n
        if (
            (typeof t == 'number' || t instanceof Number) &&
            t >= 0 &&
            t <= 16777215
        ) {
            const a = t
            ;((e = ((a >> 16) & 255) / 255),
                (i = ((a >> 8) & 255) / 255),
                (r = (a & 255) / 255),
                (n = 1))
        } else if (
            (Array.isArray(t) || t instanceof Float32Array) &&
            t.length >= 3 &&
            t.length <= 4
        )
            ((t = this._clamp(t)), ([e, i, r, n = 1] = t))
        else if (
            (t instanceof Uint8Array || t instanceof Uint8ClampedArray) &&
            t.length >= 3 &&
            t.length <= 4
        )
            ((t = this._clamp(t, 0, 255)),
                ([e, i, r, n = 255] = t),
                (e /= 255),
                (i /= 255),
                (r /= 255),
                (n /= 255))
        else if (typeof t == 'string' || typeof t == 'object') {
            if (typeof t == 'string') {
                const o = Js.HEX_PATTERN.exec(t)
                o && (t = `#${o[2]}`)
            }
            const a = Re(t)
            a.isValid() &&
                (({ r: e, g: i, b: r, a: n } = a.rgba),
                (e /= 255),
                (i /= 255),
                (r /= 255))
        }
        if (e !== void 0)
            ((this._components[0] = e),
                (this._components[1] = i),
                (this._components[2] = r),
                (this._components[3] = n),
                this.refreshInt())
        else throw new Error(`Unable to convert color ${t}`)
    }
    refreshInt() {
        this._clamp(this._components)
        const [t, e, i] = this._components
        this._int = ((t * 255) << 16) + ((e * 255) << 8) + ((i * 255) | 0)
    }
    _clamp(t, e = 0, i = 1) {
        return typeof t == 'number'
            ? Math.min(Math.max(t, e), i)
            : (t.forEach((r, n) => {
                  t[n] = Math.min(Math.max(r, e), i)
              }),
              t)
    }
}
;((fr.shared = new fr()),
    (fr.temp = new fr()),
    (fr.HEX_PATTERN = /^(#|0x)?(([a-f0-9]{3}){1,2}([a-f0-9]{2})?)$/i))
let Tt = fr
function fg(s) {
    return (
        ft('7.2.0', 'utils.hex2string is deprecated, use Color#toHex instead'),
        Tt.shared.setValue(s).toHex()
    )
}
function pg(s) {
    return (
        ft('7.2.0', 'utils.rgb2hex is deprecated, use Color#toNumber instead'),
        Tt.shared.setValue(s).toNumber()
    )
}
function mg() {
    const s = [],
        t = []
    for (let i = 0; i < 32; i++) ((s[i] = i), (t[i] = i))
    ;((s[ot.NORMAL_NPM] = ot.NORMAL),
        (s[ot.ADD_NPM] = ot.ADD),
        (s[ot.SCREEN_NPM] = ot.SCREEN),
        (t[ot.NORMAL] = ot.NORMAL_NPM),
        (t[ot.ADD] = ot.ADD_NPM),
        (t[ot.SCREEN] = ot.SCREEN_NPM))
    const e = []
    return (e.push(t), e.push(s), e)
}
const Id = mg()
function Md(s, t) {
    return Id[t ? 1 : 0][s]
}
function gg(s, t = null) {
    const e = s * 6
    if (((t = t || new Uint16Array(e)), t.length !== e))
        throw new Error(
            `Out buffer length is incorrect, got ${t.length} and expected ${e}`,
        )
    for (let i = 0, r = 0; i < e; i += 6, r += 4)
        ((t[i + 0] = r + 0),
            (t[i + 1] = r + 1),
            (t[i + 2] = r + 2),
            (t[i + 3] = r + 0),
            (t[i + 4] = r + 2),
            (t[i + 5] = r + 3))
    return t
}
function Dd(s) {
    if (s.BYTES_PER_ELEMENT === 4)
        return s instanceof Float32Array
            ? 'Float32Array'
            : s instanceof Uint32Array
              ? 'Uint32Array'
              : 'Int32Array'
    if (s.BYTES_PER_ELEMENT === 2) {
        if (s instanceof Uint16Array) return 'Uint16Array'
    } else if (s.BYTES_PER_ELEMENT === 1 && s instanceof Uint8Array)
        return 'Uint8Array'
    return null
}
function dn(s) {
    return (
        (s += s === 0 ? 1 : 0),
        --s,
        (s |= s >>> 1),
        (s |= s >>> 2),
        (s |= s >>> 4),
        (s |= s >>> 8),
        (s |= s >>> 16),
        s + 1
    )
}
function cc(s) {
    return !(s & (s - 1)) && !!s
}
function dc(s) {
    let t = (s > 65535 ? 1 : 0) << 4
    s >>>= t
    let e = (s > 255 ? 1 : 0) << 3
    return (
        (s >>>= e),
        (t |= e),
        (e = (s > 15 ? 1 : 0) << 2),
        (s >>>= e),
        (t |= e),
        (e = (s > 3 ? 1 : 0) << 1),
        (s >>>= e),
        (t |= e),
        t | (s >> 1)
    )
}
function Er(s, t, e) {
    const i = s.length
    let r
    if (t >= i || e === 0) return
    e = t + e > i ? i - t : e
    const n = i - e
    for (r = t; r < n; ++r) s[r] = s[r + e]
    s.length = n
}
function mi(s) {
    return s === 0 ? 0 : s < 0 ? -1 : 1
}
let _g = 0
function Zi() {
    return ++_g
}
const Go = class {
    constructor(s, t, e, i) {
        ;((this.left = s), (this.top = t), (this.right = e), (this.bottom = i))
    }
    get width() {
        return this.right - this.left
    }
    get height() {
        return this.bottom - this.top
    }
    isEmpty() {
        return this.left === this.right || this.top === this.bottom
    }
}
Go.EMPTY = new Go(0, 0, 0, 0)
let fc = Go
const pc = {},
    Ie = Object.create(null),
    ui = Object.create(null)
class yg {
    constructor(t, e, i) {
        ;((this._canvas = Y.ADAPTER.createCanvas()),
            (this._context = this._canvas.getContext('2d')),
            (this.resolution = i || Y.RESOLUTION),
            this.resize(t, e))
    }
    clear() {
        ;(this._checkDestroyed(),
            this._context.setTransform(1, 0, 0, 1, 0, 0),
            this._context.clearRect(
                0,
                0,
                this._canvas.width,
                this._canvas.height,
            ))
    }
    resize(t, e) {
        ;(this._checkDestroyed(),
            (this._canvas.width = Math.round(t * this.resolution)),
            (this._canvas.height = Math.round(e * this.resolution)))
    }
    destroy() {
        ;((this._context = null), (this._canvas = null))
    }
    get width() {
        return (this._checkDestroyed(), this._canvas.width)
    }
    set width(t) {
        ;(this._checkDestroyed(), (this._canvas.width = Math.round(t)))
    }
    get height() {
        return (this._checkDestroyed(), this._canvas.height)
    }
    set height(t) {
        ;(this._checkDestroyed(), (this._canvas.height = Math.round(t)))
    }
    get canvas() {
        return (this._checkDestroyed(), this._canvas)
    }
    get context() {
        return (this._checkDestroyed(), this._context)
    }
    _checkDestroyed() {
        if (this._canvas === null)
            throw new TypeError(
                'The CanvasRenderTarget has already been destroyed',
            )
    }
}
function mc(s, t, e) {
    for (let i = 0, r = 4 * e * t; i < t; ++i, r += 4)
        if (s[r + 3] !== 0) return !1
    return !0
}
function gc(s, t, e, i, r) {
    const n = 4 * t
    for (let a = i, o = i * n + 4 * e; a <= r; ++a, o += n)
        if (s[o + 3] !== 0) return !1
    return !0
}
function vg(s) {
    const { width: t, height: e } = s,
        i = s.getContext('2d', { willReadFrequently: !0 })
    if (i === null) throw new TypeError('Failed to get canvas 2D context')
    const r = i.getImageData(0, 0, t, e).data
    let n = 0,
        a = 0,
        o = t - 1,
        h = e - 1
    for (; a < e && mc(r, t, a); ) ++a
    if (a === e) return fc.EMPTY
    for (; mc(r, t, h); ) --h
    for (; gc(r, t, n, a, h); ) ++n
    for (; gc(r, t, o, a, h); ) --o
    return (++o, ++h, new fc(n, a, o, h))
}
function xg(s) {
    const t = vg(s),
        { width: e, height: i } = t
    let r = null
    if (!t.isEmpty()) {
        const n = s.getContext('2d')
        if (n === null) throw new TypeError('Failed to get canvas 2D context')
        r = n.getImageData(t.left, t.top, e, i)
    }
    return { width: e, height: i, data: r }
}
function bg(s, t = globalThis.location) {
    if (s.startsWith('data:')) return ''
    t = t || globalThis.location
    const e = new URL(s, document.baseURI)
    return e.hostname !== t.hostname ||
        e.port !== t.port ||
        e.protocol !== t.protocol
        ? 'anonymous'
        : ''
}
function ii(s, t = 1) {
    const e = Y.RETINA_PREFIX?.exec(s)
    return e ? parseFloat(e[1]) : t
}
var $ = (s => (
    (s.Renderer = 'renderer'),
    (s.Application = 'application'),
    (s.RendererSystem = 'renderer-webgl-system'),
    (s.RendererPlugin = 'renderer-webgl-plugin'),
    (s.CanvasRendererSystem = 'renderer-canvas-system'),
    (s.CanvasRendererPlugin = 'renderer-canvas-plugin'),
    (s.Asset = 'asset'),
    (s.LoadParser = 'load-parser'),
    (s.ResolveParser = 'resolve-parser'),
    (s.CacheParser = 'cache-parser'),
    (s.DetectionParser = 'detection-parser'),
    s
))($ || {})
const Ho = s => {
        if (typeof s == 'function' || (typeof s == 'object' && s.extension)) {
            if (!s.extension)
                throw new Error('Extension class must have an extension object')
            s = {
                ...(typeof s.extension != 'object'
                    ? { type: s.extension }
                    : s.extension),
                ref: s,
            }
        }
        if (typeof s == 'object') s = { ...s }
        else throw new Error('Invalid extension type')
        return (typeof s.type == 'string' && (s.type = [s.type]), s)
    },
    _c = (s, t) => Ho(s).priority ?? t,
    Q = {
        _addHandlers: {},
        _removeHandlers: {},
        _queue: {},
        remove(...s) {
            return (
                s.map(Ho).forEach(t => {
                    t.type.forEach(e => this._removeHandlers[e]?.(t))
                }),
                this
            )
        },
        add(...s) {
            return (
                s.map(Ho).forEach(t => {
                    t.type.forEach(e => {
                        const i = this._addHandlers,
                            r = this._queue
                        i[e] ? i[e]?.(t) : ((r[e] = r[e] || []), r[e]?.push(t))
                    })
                }),
                this
            )
        },
        handle(s, t, e) {
            const i = this._addHandlers,
                r = this._removeHandlers
            if (i[s] || r[s])
                throw new Error(`Extension type ${s} already has a handler`)
            ;((i[s] = t), (r[s] = e))
            const n = this._queue
            return (n[s] && (n[s]?.forEach(a => t(a)), delete n[s]), this)
        },
        handleByMap(s, t) {
            return this.handle(
                s,
                e => {
                    e.name && (t[e.name] = e.ref)
                },
                e => {
                    e.name && delete t[e.name]
                },
            )
        },
        handleByList(s, t, e = -1) {
            return this.handle(
                s,
                i => {
                    t.includes(i.ref) ||
                        (t.push(i.ref), t.sort((r, n) => _c(n, e) - _c(r, e)))
                },
                i => {
                    const r = t.indexOf(i.ref)
                    r !== -1 && t.splice(r, 1)
                },
            )
        },
    }
class zo {
    constructor(t) {
        ;(typeof t == 'number'
            ? (this.rawBinaryData = new ArrayBuffer(t))
            : t instanceof Uint8Array
              ? (this.rawBinaryData = t.buffer)
              : (this.rawBinaryData = t),
            (this.uint32View = new Uint32Array(this.rawBinaryData)),
            (this.float32View = new Float32Array(this.rawBinaryData)))
    }
    get int8View() {
        return (
            this._int8View ||
                (this._int8View = new Int8Array(this.rawBinaryData)),
            this._int8View
        )
    }
    get uint8View() {
        return (
            this._uint8View ||
                (this._uint8View = new Uint8Array(this.rawBinaryData)),
            this._uint8View
        )
    }
    get int16View() {
        return (
            this._int16View ||
                (this._int16View = new Int16Array(this.rawBinaryData)),
            this._int16View
        )
    }
    get uint16View() {
        return (
            this._uint16View ||
                (this._uint16View = new Uint16Array(this.rawBinaryData)),
            this._uint16View
        )
    }
    get int32View() {
        return (
            this._int32View ||
                (this._int32View = new Int32Array(this.rawBinaryData)),
            this._int32View
        )
    }
    view(t) {
        return this[`${t}View`]
    }
    destroy() {
        ;((this.rawBinaryData = null),
            (this._int8View = null),
            (this._uint8View = null),
            (this._int16View = null),
            (this._uint16View = null),
            (this._int32View = null),
            (this.uint32View = null),
            (this.float32View = null))
    }
    static sizeOf(t) {
        switch (t) {
            case 'int8':
            case 'uint8':
                return 1
            case 'int16':
            case 'uint16':
                return 2
            case 'int32':
            case 'uint32':
            case 'float32':
                return 4
            default:
                throw new Error(`${t} isn't a valid view type`)
        }
    }
}
const wg = [
    'precision mediump float;',
    'void main(void){',
    'float test = 0.1;',
    '%forloop%',
    'gl_FragColor = vec4(0.0);',
    '}',
].join(`
`)
function Tg(s) {
    let t = ''
    for (let e = 0; e < s; ++e)
        (e > 0 &&
            (t += `
else `),
            e < s - 1 && (t += `if(test == ${e}.0){}`))
    return t
}
function Eg(s, t) {
    if (s === 0)
        throw new Error(
            'Invalid value of `0` passed to `checkMaxIfStatementsInShader`',
        )
    const e = t.createShader(t.FRAGMENT_SHADER)
    for (;;) {
        const i = wg.replace(/%forloop%/gi, Tg(s))
        if (
            (t.shaderSource(e, i),
            t.compileShader(e),
            !t.getShaderParameter(e, t.COMPILE_STATUS))
        )
            s = (s / 2) | 0
        else break
    }
    return s
}
const no = 0,
    ao = 1,
    oo = 2,
    ho = 3,
    lo = 4,
    uo = 5
class $e {
    constructor() {
        ;((this.data = 0),
            (this.blendMode = ot.NORMAL),
            (this.polygonOffset = 0),
            (this.blend = !0),
            (this.depthMask = !0))
    }
    get blend() {
        return !!(this.data & (1 << no))
    }
    set blend(t) {
        !!(this.data & (1 << no)) !== t && (this.data ^= 1 << no)
    }
    get offsets() {
        return !!(this.data & (1 << ao))
    }
    set offsets(t) {
        !!(this.data & (1 << ao)) !== t && (this.data ^= 1 << ao)
    }
    get culling() {
        return !!(this.data & (1 << oo))
    }
    set culling(t) {
        !!(this.data & (1 << oo)) !== t && (this.data ^= 1 << oo)
    }
    get depthTest() {
        return !!(this.data & (1 << ho))
    }
    set depthTest(t) {
        !!(this.data & (1 << ho)) !== t && (this.data ^= 1 << ho)
    }
    get depthMask() {
        return !!(this.data & (1 << uo))
    }
    set depthMask(t) {
        !!(this.data & (1 << uo)) !== t && (this.data ^= 1 << uo)
    }
    get clockwiseFrontFace() {
        return !!(this.data & (1 << lo))
    }
    set clockwiseFrontFace(t) {
        !!(this.data & (1 << lo)) !== t && (this.data ^= 1 << lo)
    }
    get blendMode() {
        return this._blendMode
    }
    set blendMode(t) {
        ;((this.blend = t !== ot.NONE), (this._blendMode = t))
    }
    get polygonOffset() {
        return this._polygonOffset
    }
    set polygonOffset(t) {
        ;((this.offsets = !!t), (this._polygonOffset = t))
    }
    static for2d() {
        const t = new $e()
        return ((t.depthTest = !1), (t.blend = !0), t)
    }
}
$e.prototype.toString = function () {
    return `[@pixi/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`
}
const Vo = []
function Bd(s, t) {
    if (!s) return null
    let e = ''
    if (typeof s == 'string') {
        const i = /\.(\w{3,4})(?:$|\?|#)/i.exec(s)
        i && (e = i[1].toLowerCase())
    }
    for (let i = Vo.length - 1; i >= 0; --i) {
        const r = Vo[i]
        if (r.test && r.test(s, e)) return new r(s, t)
    }
    throw new Error('Unrecognized source type to auto-detect Resource')
}
class Ae {
    constructor(t) {
        ;((this.items = []), (this._name = t), (this._aliasCount = 0))
    }
    emit(t, e, i, r, n, a, o, h) {
        if (arguments.length > 8) throw new Error('max arguments reached')
        const { name: l, items: u } = this
        this._aliasCount++
        for (let c = 0, d = u.length; c < d; c++)
            u[c][l](t, e, i, r, n, a, o, h)
        return (u === this.items && this._aliasCount--, this)
    }
    ensureNonAliasedItems() {
        this._aliasCount > 0 &&
            this.items.length > 1 &&
            ((this._aliasCount = 0), (this.items = this.items.slice(0)))
    }
    add(t) {
        return (
            t[this._name] &&
                (this.ensureNonAliasedItems(),
                this.remove(t),
                this.items.push(t)),
            this
        )
    }
    remove(t) {
        const e = this.items.indexOf(t)
        return (
            e !== -1 && (this.ensureNonAliasedItems(), this.items.splice(e, 1)),
            this
        )
    }
    contains(t) {
        return this.items.includes(t)
    }
    removeAll() {
        return (this.ensureNonAliasedItems(), (this.items.length = 0), this)
    }
    destroy() {
        ;(this.removeAll(), (this.items.length = 0), (this._name = ''))
    }
    get empty() {
        return this.items.length === 0
    }
    get name() {
        return this._name
    }
}
Object.defineProperties(Ae.prototype, {
    dispatch: { value: Ae.prototype.emit },
    run: { value: Ae.prototype.emit },
})
class ls {
    constructor(t = 0, e = 0) {
        ;((this._width = t),
            (this._height = e),
            (this.destroyed = !1),
            (this.internal = !1),
            (this.onResize = new Ae('setRealSize')),
            (this.onUpdate = new Ae('update')),
            (this.onError = new Ae('onError')))
    }
    bind(t) {
        ;(this.onResize.add(t),
            this.onUpdate.add(t),
            this.onError.add(t),
            (this._width || this._height) &&
                this.onResize.emit(this._width, this._height))
    }
    unbind(t) {
        ;(this.onResize.remove(t),
            this.onUpdate.remove(t),
            this.onError.remove(t))
    }
    resize(t, e) {
        ;(t !== this._width || e !== this._height) &&
            ((this._width = t), (this._height = e), this.onResize.emit(t, e))
    }
    get valid() {
        return !!this._width && !!this._height
    }
    update() {
        this.destroyed || this.onUpdate.emit()
    }
    load() {
        return Promise.resolve(this)
    }
    get width() {
        return this._width
    }
    get height() {
        return this._height
    }
    style(t, e, i) {
        return !1
    }
    dispose() {}
    destroy() {
        this.destroyed ||
            ((this.destroyed = !0),
            this.dispose(),
            this.onError.removeAll(),
            (this.onError = null),
            this.onResize.removeAll(),
            (this.onResize = null),
            this.onUpdate.removeAll(),
            (this.onUpdate = null))
    }
    static test(t, e) {
        return !1
    }
}
class Fn extends ls {
    constructor(t, e) {
        const { width: i, height: r } = e || {}
        if (!i || !r) throw new Error('BufferResource width or height invalid')
        ;(super(i, r),
            (this.data = t),
            (this.unpackAlignment = e.unpackAlignment ?? 4))
    }
    upload(t, e, i) {
        const r = t.gl
        ;(r.pixelStorei(r.UNPACK_ALIGNMENT, this.unpackAlignment),
            r.pixelStorei(
                r.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                e.alphaMode === Zt.UNPACK,
            ))
        const n = e.realWidth,
            a = e.realHeight
        return (
            i.width === n && i.height === a
                ? r.texSubImage2D(
                      e.target,
                      0,
                      0,
                      0,
                      n,
                      a,
                      e.format,
                      i.type,
                      this.data,
                  )
                : ((i.width = n),
                  (i.height = a),
                  r.texImage2D(
                      e.target,
                      0,
                      i.internalFormat,
                      n,
                      a,
                      0,
                      e.format,
                      i.type,
                      this.data,
                  )),
            !0
        )
    }
    dispose() {
        this.data = null
    }
    static test(t) {
        return (
            t === null ||
            t instanceof Int8Array ||
            t instanceof Uint8Array ||
            t instanceof Uint8ClampedArray ||
            t instanceof Int16Array ||
            t instanceof Uint16Array ||
            t instanceof Int32Array ||
            t instanceof Uint32Array ||
            t instanceof Float32Array
        )
    }
}
const Ag = { scaleMode: Ze.NEAREST, alphaMode: Zt.NPM },
    Xo = class pr extends vs {
        constructor(t = null, e = null) {
            ;(super(), (e = Object.assign({}, pr.defaultOptions, e)))
            const {
                alphaMode: i,
                mipmap: r,
                anisotropicLevel: n,
                scaleMode: a,
                width: o,
                height: h,
                wrapMode: l,
                format: u,
                type: c,
                target: d,
                resolution: f,
                resourceOptions: m,
            } = e
            ;(t && !(t instanceof ls) && ((t = Bd(t, m)), (t.internal = !0)),
                (this.resolution = f || Y.RESOLUTION),
                (this.width =
                    Math.round((o || 0) * this.resolution) / this.resolution),
                (this.height =
                    Math.round((h || 0) * this.resolution) / this.resolution),
                (this._mipmap = r),
                (this.anisotropicLevel = n),
                (this._wrapMode = l),
                (this._scaleMode = a),
                (this.format = u),
                (this.type = c),
                (this.target = d),
                (this.alphaMode = i),
                (this.uid = Zi()),
                (this.touched = 0),
                (this.isPowerOfTwo = !1),
                this._refreshPOT(),
                (this._glTextures = {}),
                (this.dirtyId = 0),
                (this.dirtyStyleId = 0),
                (this.cacheId = null),
                (this.valid = o > 0 && h > 0),
                (this.textureCacheIds = []),
                (this.destroyed = !1),
                (this.resource = null),
                (this._batchEnabled = 0),
                (this._batchLocation = 0),
                (this.parentTextureArray = null),
                this.setResource(t))
        }
        get realWidth() {
            return Math.round(this.width * this.resolution)
        }
        get realHeight() {
            return Math.round(this.height * this.resolution)
        }
        get mipmap() {
            return this._mipmap
        }
        set mipmap(t) {
            this._mipmap !== t && ((this._mipmap = t), this.dirtyStyleId++)
        }
        get scaleMode() {
            return this._scaleMode
        }
        set scaleMode(t) {
            this._scaleMode !== t &&
                ((this._scaleMode = t), this.dirtyStyleId++)
        }
        get wrapMode() {
            return this._wrapMode
        }
        set wrapMode(t) {
            this._wrapMode !== t && ((this._wrapMode = t), this.dirtyStyleId++)
        }
        setStyle(t, e) {
            let i
            return (
                t !== void 0 &&
                    t !== this.scaleMode &&
                    ((this.scaleMode = t), (i = !0)),
                e !== void 0 &&
                    e !== this.mipmap &&
                    ((this.mipmap = e), (i = !0)),
                i && this.dirtyStyleId++,
                this
            )
        }
        setSize(t, e, i) {
            return (
                (i = i || this.resolution),
                this.setRealSize(t * i, e * i, i)
            )
        }
        setRealSize(t, e, i) {
            return (
                (this.resolution = i || this.resolution),
                (this.width = Math.round(t) / this.resolution),
                (this.height = Math.round(e) / this.resolution),
                this._refreshPOT(),
                this.update(),
                this
            )
        }
        _refreshPOT() {
            this.isPowerOfTwo = cc(this.realWidth) && cc(this.realHeight)
        }
        setResolution(t) {
            const e = this.resolution
            return e === t
                ? this
                : ((this.resolution = t),
                  this.valid &&
                      ((this.width = Math.round(this.width * e) / t),
                      (this.height = Math.round(this.height * e) / t),
                      this.emit('update', this)),
                  this._refreshPOT(),
                  this)
        }
        setResource(t) {
            if (this.resource === t) return this
            if (this.resource) throw new Error('Resource can be set only once')
            return (t.bind(this), (this.resource = t), this)
        }
        update() {
            this.valid
                ? (this.dirtyId++,
                  this.dirtyStyleId++,
                  this.emit('update', this))
                : this.width > 0 &&
                  this.height > 0 &&
                  ((this.valid = !0),
                  this.emit('loaded', this),
                  this.emit('update', this))
        }
        onError(t) {
            this.emit('error', this, t)
        }
        destroy() {
            ;(this.resource &&
                (this.resource.unbind(this),
                this.resource.internal && this.resource.destroy(),
                (this.resource = null)),
                this.cacheId &&
                    (delete ui[this.cacheId],
                    delete Ie[this.cacheId],
                    (this.cacheId = null)),
                (this.valid = !1),
                this.dispose(),
                pr.removeFromCache(this),
                (this.textureCacheIds = null),
                (this.destroyed = !0),
                this.emit('destroyed', this),
                this.removeAllListeners())
        }
        dispose() {
            this.emit('dispose', this)
        }
        castToBaseTexture() {
            return this
        }
        static from(t, e, i = Y.STRICT_TEXTURE_CACHE) {
            const r = typeof t == 'string'
            let n = null
            if (r) n = t
            else {
                if (!t._pixiId) {
                    const o = e?.pixiIdPrefix || 'pixiid'
                    t._pixiId = `${o}_${Zi()}`
                }
                n = t._pixiId
            }
            let a = ui[n]
            if (r && i && !a)
                throw new Error(
                    `The cacheId "${n}" does not exist in BaseTextureCache.`,
                )
            return (
                a || ((a = new pr(t, e)), (a.cacheId = n), pr.addToCache(a, n)),
                a
            )
        }
        static fromBuffer(t, e, i, r) {
            t = t || new Float32Array(e * i * 4)
            const n = new Fn(t, { width: e, height: i, ...r?.resourceOptions })
            let a, o
            return (
                t instanceof Float32Array
                    ? ((a = X.RGBA), (o = at.FLOAT))
                    : t instanceof Int32Array
                      ? ((a = X.RGBA_INTEGER), (o = at.INT))
                      : t instanceof Uint32Array
                        ? ((a = X.RGBA_INTEGER), (o = at.UNSIGNED_INT))
                        : t instanceof Int16Array
                          ? ((a = X.RGBA_INTEGER), (o = at.SHORT))
                          : t instanceof Uint16Array
                            ? ((a = X.RGBA_INTEGER), (o = at.UNSIGNED_SHORT))
                            : t instanceof Int8Array
                              ? ((a = X.RGBA), (o = at.BYTE))
                              : ((a = X.RGBA), (o = at.UNSIGNED_BYTE)),
                (n.internal = !0),
                new pr(n, Object.assign({}, Ag, { type: o, format: a }, r))
            )
        }
        static addToCache(t, e) {
            e &&
                (t.textureCacheIds.includes(e) || t.textureCacheIds.push(e),
                ui[e] &&
                    ui[e] !== t &&
                    console.warn(
                        `BaseTexture added to the cache with an id [${e}] that already had an entry`,
                    ),
                (ui[e] = t))
        }
        static removeFromCache(t) {
            if (typeof t == 'string') {
                const e = ui[t]
                if (e) {
                    const i = e.textureCacheIds.indexOf(t)
                    return (
                        i > -1 && e.textureCacheIds.splice(i, 1),
                        delete ui[t],
                        e
                    )
                }
            } else if (t?.textureCacheIds) {
                for (let e = 0; e < t.textureCacheIds.length; ++e)
                    delete ui[t.textureCacheIds[e]]
                return ((t.textureCacheIds.length = 0), t)
            }
            return null
        }
    }
;((Xo.defaultOptions = {
    mipmap: Xe.POW2,
    anisotropicLevel: 0,
    scaleMode: Ze.LINEAR,
    wrapMode: xi.CLAMP,
    alphaMode: Zt.UNPACK,
    target: Tr.TEXTURE_2D,
    format: X.RGBA,
    type: at.UNSIGNED_BYTE,
}),
    (Xo._globalBatch = 0))
let lt = Xo
class Wo {
    constructor() {
        ;((this.texArray = null),
            (this.blend = 0),
            (this.type = Ue.TRIANGLES),
            (this.start = 0),
            (this.size = 0),
            (this.data = null))
    }
}
let Sg = 0
class Bt {
    constructor(t, e = !0, i = !1) {
        ;((this.data = t || new Float32Array(1)),
            (this._glBuffers = {}),
            (this._updateID = 0),
            (this.index = i),
            (this.static = e),
            (this.id = Sg++),
            (this.disposeRunner = new Ae('disposeBuffer')))
    }
    update(t) {
        ;(t instanceof Array && (t = new Float32Array(t)),
            (this.data = t || this.data),
            this._updateID++)
    }
    dispose() {
        this.disposeRunner.emit(this, !1)
    }
    destroy() {
        ;(this.dispose(), (this.data = null))
    }
    set index(t) {
        this.type = t ? ze.ELEMENT_ARRAY_BUFFER : ze.ARRAY_BUFFER
    }
    get index() {
        return this.type === ze.ELEMENT_ARRAY_BUFFER
    }
    static from(t) {
        return (t instanceof Array && (t = new Float32Array(t)), new Bt(t))
    }
}
class fn {
    constructor(t, e = 0, i = !1, r = at.FLOAT, n, a, o, h = 1) {
        ;((this.buffer = t),
            (this.size = e),
            (this.normalized = i),
            (this.type = r),
            (this.stride = n),
            (this.start = a),
            (this.instance = o),
            (this.divisor = h))
    }
    destroy() {
        this.buffer = null
    }
    static from(t, e, i, r, n) {
        return new fn(t, e, i, r, n)
    }
}
const Cg = { Float32Array, Uint32Array, Int32Array, Uint8Array }
function Pg(s, t) {
    let e = 0,
        i = 0
    const r = {}
    for (let h = 0; h < s.length; h++) ((i += t[h]), (e += s[h].length))
    const n = new ArrayBuffer(e * 4)
    let a = null,
        o = 0
    for (let h = 0; h < s.length; h++) {
        const l = t[h],
            u = s[h],
            c = Dd(u)
        ;(r[c] || (r[c] = new Cg[c](n)), (a = r[c]))
        for (let d = 0; d < u.length; d++) {
            const f = ((d / l) | 0) * i + o,
                m = d % l
            a[f + m] = u[d]
        }
        o += l
    }
    return new Float32Array(n)
}
const yc = { 5126: 4, 5123: 2, 5121: 1 }
let Rg = 0
const Ig = { Float32Array, Uint32Array, Int32Array, Uint8Array, Uint16Array }
class Ti {
    constructor(t = [], e = {}) {
        ;((this.buffers = t),
            (this.indexBuffer = null),
            (this.attributes = e),
            (this.glVertexArrayObjects = {}),
            (this.id = Rg++),
            (this.instanced = !1),
            (this.instanceCount = 1),
            (this.disposeRunner = new Ae('disposeGeometry')),
            (this.refCount = 0))
    }
    addAttribute(t, e, i = 0, r = !1, n, a, o, h = !1) {
        if (!e)
            throw new Error('You must pass a buffer when creating an attribute')
        e instanceof Bt ||
            (e instanceof Array && (e = new Float32Array(e)), (e = new Bt(e)))
        const l = t.split('|')
        if (l.length > 1) {
            for (let c = 0; c < l.length; c++)
                this.addAttribute(l[c], e, i, r, n)
            return this
        }
        let u = this.buffers.indexOf(e)
        return (
            u === -1 && (this.buffers.push(e), (u = this.buffers.length - 1)),
            (this.attributes[t] = new fn(u, i, r, n, a, o, h)),
            (this.instanced = this.instanced || h),
            this
        )
    }
    getAttribute(t) {
        return this.attributes[t]
    }
    getBuffer(t) {
        return this.buffers[this.getAttribute(t).buffer]
    }
    addIndex(t) {
        return (
            t instanceof Bt ||
                (t instanceof Array && (t = new Uint16Array(t)),
                (t = new Bt(t))),
            (t.type = ze.ELEMENT_ARRAY_BUFFER),
            (this.indexBuffer = t),
            this.buffers.includes(t) || this.buffers.push(t),
            this
        )
    }
    getIndex() {
        return this.indexBuffer
    }
    interleave() {
        if (
            this.buffers.length === 1 ||
            (this.buffers.length === 2 && this.indexBuffer)
        )
            return this
        const t = [],
            e = [],
            i = new Bt()
        let r
        for (r in this.attributes) {
            const n = this.attributes[r],
                a = this.buffers[n.buffer]
            ;(t.push(a.data), e.push((n.size * yc[n.type]) / 4), (n.buffer = 0))
        }
        for (i.data = Pg(t, e), r = 0; r < this.buffers.length; r++)
            this.buffers[r] !== this.indexBuffer && this.buffers[r].destroy()
        return (
            (this.buffers = [i]),
            this.indexBuffer && this.buffers.push(this.indexBuffer),
            this
        )
    }
    getSize() {
        for (const t in this.attributes) {
            const e = this.attributes[t]
            return this.buffers[e.buffer].data.length / (e.stride / 4 || e.size)
        }
        return 0
    }
    dispose() {
        this.disposeRunner.emit(this, !1)
    }
    destroy() {
        ;(this.dispose(),
            (this.buffers = null),
            (this.indexBuffer = null),
            (this.attributes = null))
    }
    clone() {
        const t = new Ti()
        for (let e = 0; e < this.buffers.length; e++)
            t.buffers[e] = new Bt(this.buffers[e].data.slice(0))
        for (const e in this.attributes) {
            const i = this.attributes[e]
            t.attributes[e] = new fn(
                i.buffer,
                i.size,
                i.normalized,
                i.type,
                i.stride,
                i.start,
                i.instance,
            )
        }
        return (
            this.indexBuffer &&
                ((t.indexBuffer =
                    t.buffers[this.buffers.indexOf(this.indexBuffer)]),
                (t.indexBuffer.type = ze.ELEMENT_ARRAY_BUFFER)),
            t
        )
    }
    static merge(t) {
        const e = new Ti(),
            i = [],
            r = [],
            n = []
        let a
        for (let o = 0; o < t.length; o++) {
            a = t[o]
            for (let h = 0; h < a.buffers.length; h++)
                ((r[h] = r[h] || 0),
                    (r[h] += a.buffers[h].data.length),
                    (n[h] = 0))
        }
        for (let o = 0; o < a.buffers.length; o++)
            ((i[o] = new Ig[Dd(a.buffers[o].data)](r[o])),
                (e.buffers[o] = new Bt(i[o])))
        for (let o = 0; o < t.length; o++) {
            a = t[o]
            for (let h = 0; h < a.buffers.length; h++)
                (i[h].set(a.buffers[h].data, n[h]),
                    (n[h] += a.buffers[h].data.length))
        }
        if (((e.attributes = a.attributes), a.indexBuffer)) {
            ;((e.indexBuffer = e.buffers[a.buffers.indexOf(a.indexBuffer)]),
                (e.indexBuffer.type = ze.ELEMENT_ARRAY_BUFFER))
            let o = 0,
                h = 0,
                l = 0,
                u = 0
            for (let c = 0; c < a.buffers.length; c++)
                if (a.buffers[c] !== a.indexBuffer) {
                    u = c
                    break
                }
            for (const c in a.attributes) {
                const d = a.attributes[c]
                ;(d.buffer | 0) === u && (h += (d.size * yc[d.type]) / 4)
            }
            for (let c = 0; c < t.length; c++) {
                const d = t[c].indexBuffer.data
                for (let f = 0; f < d.length; f++)
                    e.indexBuffer.data[f + l] += o
                ;((o += t[c].buffers[u].data.length / h), (l += d.length))
            }
        }
        return e
    }
}
class Od extends Ti {
    constructor(t = !1) {
        ;(super(),
            (this._buffer = new Bt(null, t, !1)),
            (this._indexBuffer = new Bt(null, t, !0)),
            this.addAttribute('aVertexPosition', this._buffer, 2, !1, at.FLOAT)
                .addAttribute('aTextureCoord', this._buffer, 2, !1, at.FLOAT)
                .addAttribute('aColor', this._buffer, 4, !0, at.UNSIGNED_BYTE)
                .addAttribute('aTextureId', this._buffer, 1, !0, at.FLOAT)
                .addIndex(this._indexBuffer))
    }
}
const pn = Math.PI * 2,
    Mg = 180 / Math.PI,
    Dg = Math.PI / 180
var Vt = (s => (
    (s[(s.POLY = 0)] = 'POLY'),
    (s[(s.RECT = 1)] = 'RECT'),
    (s[(s.CIRC = 2)] = 'CIRC'),
    (s[(s.ELIP = 3)] = 'ELIP'),
    (s[(s.RREC = 4)] = 'RREC'),
    s
))(Vt || {})
class ut {
    constructor(t = 0, e = 0) {
        ;((this.x = 0), (this.y = 0), (this.x = t), (this.y = e))
    }
    clone() {
        return new ut(this.x, this.y)
    }
    copyFrom(t) {
        return (this.set(t.x, t.y), this)
    }
    copyTo(t) {
        return (t.set(this.x, this.y), t)
    }
    equals(t) {
        return t.x === this.x && t.y === this.y
    }
    set(t = 0, e = t) {
        return ((this.x = t), (this.y = e), this)
    }
}
ut.prototype.toString = function () {
    return `[@pixi/math:Point x=${this.x} y=${this.y}]`
}
const Ms = [new ut(), new ut(), new ut(), new ut()]
let dt = class $o {
    constructor(t = 0, e = 0, i = 0, r = 0) {
        ;((this.x = Number(t)),
            (this.y = Number(e)),
            (this.width = Number(i)),
            (this.height = Number(r)),
            (this.type = Vt.RECT))
    }
    get left() {
        return this.x
    }
    get right() {
        return this.x + this.width
    }
    get top() {
        return this.y
    }
    get bottom() {
        return this.y + this.height
    }
    static get EMPTY() {
        return new $o(0, 0, 0, 0)
    }
    clone() {
        return new $o(this.x, this.y, this.width, this.height)
    }
    copyFrom(t) {
        return (
            (this.x = t.x),
            (this.y = t.y),
            (this.width = t.width),
            (this.height = t.height),
            this
        )
    }
    copyTo(t) {
        return (
            (t.x = this.x),
            (t.y = this.y),
            (t.width = this.width),
            (t.height = this.height),
            t
        )
    }
    contains(t, e) {
        return this.width <= 0 || this.height <= 0
            ? !1
            : t >= this.x &&
                  t < this.x + this.width &&
                  e >= this.y &&
                  e < this.y + this.height
    }
    intersects(t, e) {
        if (!e) {
            const S = this.x < t.x ? t.x : this.x
            if ((this.right > t.right ? t.right : this.right) <= S) return !1
            const R = this.y < t.y ? t.y : this.y
            return (this.bottom > t.bottom ? t.bottom : this.bottom) > R
        }
        const i = this.left,
            r = this.right,
            n = this.top,
            a = this.bottom
        if (r <= i || a <= n) return !1
        const o = Ms[0].set(t.left, t.top),
            h = Ms[1].set(t.left, t.bottom),
            l = Ms[2].set(t.right, t.top),
            u = Ms[3].set(t.right, t.bottom)
        if (l.x <= o.x || h.y <= o.y) return !1
        const c = Math.sign(e.a * e.d - e.b * e.c)
        if (
            c === 0 ||
            (e.apply(o, o),
            e.apply(h, h),
            e.apply(l, l),
            e.apply(u, u),
            Math.max(o.x, h.x, l.x, u.x) <= i ||
                Math.min(o.x, h.x, l.x, u.x) >= r ||
                Math.max(o.y, h.y, l.y, u.y) <= n ||
                Math.min(o.y, h.y, l.y, u.y) >= a)
        )
            return !1
        const d = c * (h.y - o.y),
            f = c * (o.x - h.x),
            m = d * i + f * n,
            p = d * r + f * n,
            g = d * i + f * a,
            _ = d * r + f * a
        if (
            Math.max(m, p, g, _) <= d * o.x + f * o.y ||
            Math.min(m, p, g, _) >= d * u.x + f * u.y
        )
            return !1
        const b = c * (o.y - l.y),
            v = c * (l.x - o.x),
            w = b * i + v * n,
            x = b * r + v * n,
            P = b * i + v * a,
            y = b * r + v * a
        return !(
            Math.max(w, x, P, y) <= b * o.x + v * o.y ||
            Math.min(w, x, P, y) >= b * u.x + v * u.y
        )
    }
    pad(t = 0, e = t) {
        return (
            (this.x -= t),
            (this.y -= e),
            (this.width += t * 2),
            (this.height += e * 2),
            this
        )
    }
    fit(t) {
        const e = Math.max(this.x, t.x),
            i = Math.min(this.x + this.width, t.x + t.width),
            r = Math.max(this.y, t.y),
            n = Math.min(this.y + this.height, t.y + t.height)
        return (
            (this.x = e),
            (this.width = Math.max(i - e, 0)),
            (this.y = r),
            (this.height = Math.max(n - r, 0)),
            this
        )
    }
    ceil(t = 1, e = 0.001) {
        const i = Math.ceil((this.x + this.width - e) * t) / t,
            r = Math.ceil((this.y + this.height - e) * t) / t
        return (
            (this.x = Math.floor((this.x + e) * t) / t),
            (this.y = Math.floor((this.y + e) * t) / t),
            (this.width = i - this.x),
            (this.height = r - this.y),
            this
        )
    }
    enlarge(t) {
        const e = Math.min(this.x, t.x),
            i = Math.max(this.x + this.width, t.x + t.width),
            r = Math.min(this.y, t.y),
            n = Math.max(this.y + this.height, t.y + t.height)
        return (
            (this.x = e),
            (this.width = i - e),
            (this.y = r),
            (this.height = n - r),
            this
        )
    }
}
dt.prototype.toString = function () {
    return `[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`
}
class Ln {
    constructor(t = 0, e = 0, i = 0) {
        ;((this.x = t), (this.y = e), (this.radius = i), (this.type = Vt.CIRC))
    }
    clone() {
        return new Ln(this.x, this.y, this.radius)
    }
    contains(t, e) {
        if (this.radius <= 0) return !1
        const i = this.radius * this.radius
        let r = this.x - t,
            n = this.y - e
        return ((r *= r), (n *= n), r + n <= i)
    }
    getBounds() {
        return new dt(
            this.x - this.radius,
            this.y - this.radius,
            this.radius * 2,
            this.radius * 2,
        )
    }
}
Ln.prototype.toString = function () {
    return `[@pixi/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`
}
class kn {
    constructor(t = 0, e = 0, i = 0, r = 0) {
        ;((this.x = t),
            (this.y = e),
            (this.width = i),
            (this.height = r),
            (this.type = Vt.ELIP))
    }
    clone() {
        return new kn(this.x, this.y, this.width, this.height)
    }
    contains(t, e) {
        if (this.width <= 0 || this.height <= 0) return !1
        let i = (t - this.x) / this.width,
            r = (e - this.y) / this.height
        return ((i *= i), (r *= r), i + r <= 1)
    }
    getBounds() {
        return new dt(
            this.x - this.width,
            this.y - this.height,
            this.width,
            this.height,
        )
    }
}
kn.prototype.toString = function () {
    return `[@pixi/math:Ellipse x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`
}
class Wi {
    constructor(...t) {
        let e = Array.isArray(t[0]) ? t[0] : t
        if (typeof e[0] != 'number') {
            const i = []
            for (let r = 0, n = e.length; r < n; r++) i.push(e[r].x, e[r].y)
            e = i
        }
        ;((this.points = e), (this.type = Vt.POLY), (this.closeStroke = !0))
    }
    clone() {
        const t = this.points.slice(),
            e = new Wi(t)
        return ((e.closeStroke = this.closeStroke), e)
    }
    contains(t, e) {
        let i = !1
        const r = this.points.length / 2
        for (let n = 0, a = r - 1; n < r; a = n++) {
            const o = this.points[n * 2],
                h = this.points[n * 2 + 1],
                l = this.points[a * 2],
                u = this.points[a * 2 + 1]
            h > e != u > e && t < (l - o) * ((e - h) / (u - h)) + o && (i = !i)
        }
        return i
    }
}
Wi.prototype.toString = function () {
    return `[@pixi/math:PolygoncloseStroke=${this.closeStroke}points=${this.points.reduce((s, t) => `${s}, ${t}`, '')}]`
}
class Nn {
    constructor(t = 0, e = 0, i = 0, r = 0, n = 20) {
        ;((this.x = t),
            (this.y = e),
            (this.width = i),
            (this.height = r),
            (this.radius = n),
            (this.type = Vt.RREC))
    }
    clone() {
        return new Nn(this.x, this.y, this.width, this.height, this.radius)
    }
    contains(t, e) {
        if (this.width <= 0 || this.height <= 0) return !1
        if (
            t >= this.x &&
            t <= this.x + this.width &&
            e >= this.y &&
            e <= this.y + this.height
        ) {
            const i = Math.max(
                0,
                Math.min(this.radius, Math.min(this.width, this.height) / 2),
            )
            if (
                (e >= this.y + i && e <= this.y + this.height - i) ||
                (t >= this.x + i && t <= this.x + this.width - i)
            )
                return !0
            let r = t - (this.x + i),
                n = e - (this.y + i)
            const a = i * i
            if (
                r * r + n * n <= a ||
                ((r = t - (this.x + this.width - i)), r * r + n * n <= a) ||
                ((n = e - (this.y + this.height - i)), r * r + n * n <= a) ||
                ((r = t - (this.x + i)), r * r + n * n <= a)
            )
                return !0
        }
        return !1
    }
}
Nn.prototype.toString = function () {
    return `[@pixi/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`
}
class Et {
    constructor(t = 1, e = 0, i = 0, r = 1, n = 0, a = 0) {
        ;((this.array = null),
            (this.a = t),
            (this.b = e),
            (this.c = i),
            (this.d = r),
            (this.tx = n),
            (this.ty = a))
    }
    fromArray(t) {
        ;((this.a = t[0]),
            (this.b = t[1]),
            (this.c = t[3]),
            (this.d = t[4]),
            (this.tx = t[2]),
            (this.ty = t[5]))
    }
    set(t, e, i, r, n, a) {
        return (
            (this.a = t),
            (this.b = e),
            (this.c = i),
            (this.d = r),
            (this.tx = n),
            (this.ty = a),
            this
        )
    }
    toArray(t, e) {
        this.array || (this.array = new Float32Array(9))
        const i = e || this.array
        return (
            t
                ? ((i[0] = this.a),
                  (i[1] = this.b),
                  (i[2] = 0),
                  (i[3] = this.c),
                  (i[4] = this.d),
                  (i[5] = 0),
                  (i[6] = this.tx),
                  (i[7] = this.ty),
                  (i[8] = 1))
                : ((i[0] = this.a),
                  (i[1] = this.c),
                  (i[2] = this.tx),
                  (i[3] = this.b),
                  (i[4] = this.d),
                  (i[5] = this.ty),
                  (i[6] = 0),
                  (i[7] = 0),
                  (i[8] = 1)),
            i
        )
    }
    apply(t, e) {
        e = e || new ut()
        const i = t.x,
            r = t.y
        return (
            (e.x = this.a * i + this.c * r + this.tx),
            (e.y = this.b * i + this.d * r + this.ty),
            e
        )
    }
    applyInverse(t, e) {
        e = e || new ut()
        const i = 1 / (this.a * this.d + this.c * -this.b),
            r = t.x,
            n = t.y
        return (
            (e.x =
                this.d * i * r +
                -this.c * i * n +
                (this.ty * this.c - this.tx * this.d) * i),
            (e.y =
                this.a * i * n +
                -this.b * i * r +
                (-this.ty * this.a + this.tx * this.b) * i),
            e
        )
    }
    translate(t, e) {
        return ((this.tx += t), (this.ty += e), this)
    }
    scale(t, e) {
        return (
            (this.a *= t),
            (this.d *= e),
            (this.c *= t),
            (this.b *= e),
            (this.tx *= t),
            (this.ty *= e),
            this
        )
    }
    rotate(t) {
        const e = Math.cos(t),
            i = Math.sin(t),
            r = this.a,
            n = this.c,
            a = this.tx
        return (
            (this.a = r * e - this.b * i),
            (this.b = r * i + this.b * e),
            (this.c = n * e - this.d * i),
            (this.d = n * i + this.d * e),
            (this.tx = a * e - this.ty * i),
            (this.ty = a * i + this.ty * e),
            this
        )
    }
    append(t) {
        const e = this.a,
            i = this.b,
            r = this.c,
            n = this.d
        return (
            (this.a = t.a * e + t.b * r),
            (this.b = t.a * i + t.b * n),
            (this.c = t.c * e + t.d * r),
            (this.d = t.c * i + t.d * n),
            (this.tx = t.tx * e + t.ty * r + this.tx),
            (this.ty = t.tx * i + t.ty * n + this.ty),
            this
        )
    }
    setTransform(t, e, i, r, n, a, o, h, l) {
        return (
            (this.a = Math.cos(o + l) * n),
            (this.b = Math.sin(o + l) * n),
            (this.c = -Math.sin(o - h) * a),
            (this.d = Math.cos(o - h) * a),
            (this.tx = t - (i * this.a + r * this.c)),
            (this.ty = e - (i * this.b + r * this.d)),
            this
        )
    }
    prepend(t) {
        const e = this.tx
        if (t.a !== 1 || t.b !== 0 || t.c !== 0 || t.d !== 1) {
            const i = this.a,
                r = this.c
            ;((this.a = i * t.a + this.b * t.c),
                (this.b = i * t.b + this.b * t.d),
                (this.c = r * t.a + this.d * t.c),
                (this.d = r * t.b + this.d * t.d))
        }
        return (
            (this.tx = e * t.a + this.ty * t.c + t.tx),
            (this.ty = e * t.b + this.ty * t.d + t.ty),
            this
        )
    }
    decompose(t) {
        const e = this.a,
            i = this.b,
            r = this.c,
            n = this.d,
            a = t.pivot,
            o = -Math.atan2(-r, n),
            h = Math.atan2(i, e),
            l = Math.abs(o + h)
        return (
            l < 1e-5 || Math.abs(pn - l) < 1e-5
                ? ((t.rotation = h), (t.skew.x = t.skew.y = 0))
                : ((t.rotation = 0), (t.skew.x = o), (t.skew.y = h)),
            (t.scale.x = Math.sqrt(e * e + i * i)),
            (t.scale.y = Math.sqrt(r * r + n * n)),
            (t.position.x = this.tx + (a.x * e + a.y * r)),
            (t.position.y = this.ty + (a.x * i + a.y * n)),
            t
        )
    }
    invert() {
        const t = this.a,
            e = this.b,
            i = this.c,
            r = this.d,
            n = this.tx,
            a = t * r - e * i
        return (
            (this.a = r / a),
            (this.b = -e / a),
            (this.c = -i / a),
            (this.d = t / a),
            (this.tx = (i * this.ty - r * n) / a),
            (this.ty = -(t * this.ty - e * n) / a),
            this
        )
    }
    identity() {
        return (
            (this.a = 1),
            (this.b = 0),
            (this.c = 0),
            (this.d = 1),
            (this.tx = 0),
            (this.ty = 0),
            this
        )
    }
    clone() {
        const t = new Et()
        return (
            (t.a = this.a),
            (t.b = this.b),
            (t.c = this.c),
            (t.d = this.d),
            (t.tx = this.tx),
            (t.ty = this.ty),
            t
        )
    }
    copyTo(t) {
        return (
            (t.a = this.a),
            (t.b = this.b),
            (t.c = this.c),
            (t.d = this.d),
            (t.tx = this.tx),
            (t.ty = this.ty),
            t
        )
    }
    copyFrom(t) {
        return (
            (this.a = t.a),
            (this.b = t.b),
            (this.c = t.c),
            (this.d = t.d),
            (this.tx = t.tx),
            (this.ty = t.ty),
            this
        )
    }
    static get IDENTITY() {
        return new Et()
    }
    static get TEMP_MATRIX() {
        return new Et()
    }
}
Et.prototype.toString = function () {
    return `[@pixi/math:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`
}
const Fi = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1],
    Li = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1],
    ki = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1],
    Ni = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1],
    jo = [],
    Fd = [],
    Ds = Math.sign
function Bg() {
    for (let s = 0; s < 16; s++) {
        const t = []
        jo.push(t)
        for (let e = 0; e < 16; e++) {
            const i = Ds(Fi[s] * Fi[e] + ki[s] * Li[e]),
                r = Ds(Li[s] * Fi[e] + Ni[s] * Li[e]),
                n = Ds(Fi[s] * ki[e] + ki[s] * Ni[e]),
                a = Ds(Li[s] * ki[e] + Ni[s] * Ni[e])
            for (let o = 0; o < 16; o++)
                if (Fi[o] === i && Li[o] === r && ki[o] === n && Ni[o] === a) {
                    t.push(o)
                    break
                }
        }
    }
    for (let s = 0; s < 16; s++) {
        const t = new Et()
        ;(t.set(Fi[s], Li[s], ki[s], Ni[s], 0, 0), Fd.push(t))
    }
}
Bg()
const St = {
    E: 0,
    SE: 1,
    S: 2,
    SW: 3,
    W: 4,
    NW: 5,
    N: 6,
    NE: 7,
    MIRROR_VERTICAL: 8,
    MAIN_DIAGONAL: 10,
    MIRROR_HORIZONTAL: 12,
    REVERSE_DIAGONAL: 14,
    uX: s => Fi[s],
    uY: s => Li[s],
    vX: s => ki[s],
    vY: s => Ni[s],
    inv: s => (s & 8 ? s & 15 : -s & 7),
    add: (s, t) => jo[s][t],
    sub: (s, t) => jo[s][St.inv(t)],
    rotate180: s => s ^ 4,
    isVertical: s => (s & 3) === 2,
    byDirection: (s, t) =>
        Math.abs(s) * 2 <= Math.abs(t)
            ? t >= 0
                ? St.S
                : St.N
            : Math.abs(t) * 2 <= Math.abs(s)
              ? s > 0
                  ? St.E
                  : St.W
              : t > 0
                ? s > 0
                    ? St.SE
                    : St.SW
                : s > 0
                  ? St.NE
                  : St.NW,
    matrixAppendRotationInv: (s, t, e = 0, i = 0) => {
        const r = Fd[St.inv(t)]
        ;((r.tx = e), (r.ty = i), s.append(r))
    },
}
class Je {
    constructor(t, e, i = 0, r = 0) {
        ;((this._x = i), (this._y = r), (this.cb = t), (this.scope = e))
    }
    clone(t = this.cb, e = this.scope) {
        return new Je(t, e, this._x, this._y)
    }
    set(t = 0, e = t) {
        return (
            (this._x !== t || this._y !== e) &&
                ((this._x = t), (this._y = e), this.cb.call(this.scope)),
            this
        )
    }
    copyFrom(t) {
        return (
            (this._x !== t.x || this._y !== t.y) &&
                ((this._x = t.x), (this._y = t.y), this.cb.call(this.scope)),
            this
        )
    }
    copyTo(t) {
        return (t.set(this._x, this._y), t)
    }
    equals(t) {
        return t.x === this._x && t.y === this._y
    }
    get x() {
        return this._x
    }
    set x(t) {
        this._x !== t && ((this._x = t), this.cb.call(this.scope))
    }
    get y() {
        return this._y
    }
    set y(t) {
        this._y !== t && ((this._y = t), this.cb.call(this.scope))
    }
}
Je.prototype.toString = function () {
    return `[@pixi/math:ObservablePoint x=${this.x} y=${this.y} scope=${this.scope}]`
}
const qo = class {
    constructor() {
        ;((this.worldTransform = new Et()),
            (this.localTransform = new Et()),
            (this.position = new Je(this.onChange, this, 0, 0)),
            (this.scale = new Je(this.onChange, this, 1, 1)),
            (this.pivot = new Je(this.onChange, this, 0, 0)),
            (this.skew = new Je(this.updateSkew, this, 0, 0)),
            (this._rotation = 0),
            (this._cx = 1),
            (this._sx = 0),
            (this._cy = 0),
            (this._sy = 1),
            (this._localID = 0),
            (this._currentLocalID = 0),
            (this._worldID = 0),
            (this._parentID = 0))
    }
    onChange() {
        this._localID++
    }
    updateSkew() {
        ;((this._cx = Math.cos(this._rotation + this.skew.y)),
            (this._sx = Math.sin(this._rotation + this.skew.y)),
            (this._cy = -Math.sin(this._rotation - this.skew.x)),
            (this._sy = Math.cos(this._rotation - this.skew.x)),
            this._localID++)
    }
    updateLocalTransform() {
        const s = this.localTransform
        this._localID !== this._currentLocalID &&
            ((s.a = this._cx * this.scale.x),
            (s.b = this._sx * this.scale.x),
            (s.c = this._cy * this.scale.y),
            (s.d = this._sy * this.scale.y),
            (s.tx =
                this.position.x - (this.pivot.x * s.a + this.pivot.y * s.c)),
            (s.ty =
                this.position.y - (this.pivot.x * s.b + this.pivot.y * s.d)),
            (this._currentLocalID = this._localID),
            (this._parentID = -1))
    }
    updateTransform(s) {
        const t = this.localTransform
        if (
            (this._localID !== this._currentLocalID &&
                ((t.a = this._cx * this.scale.x),
                (t.b = this._sx * this.scale.x),
                (t.c = this._cy * this.scale.y),
                (t.d = this._sy * this.scale.y),
                (t.tx =
                    this.position.x -
                    (this.pivot.x * t.a + this.pivot.y * t.c)),
                (t.ty =
                    this.position.y -
                    (this.pivot.x * t.b + this.pivot.y * t.d)),
                (this._currentLocalID = this._localID),
                (this._parentID = -1)),
            this._parentID !== s._worldID)
        ) {
            const e = s.worldTransform,
                i = this.worldTransform
            ;((i.a = t.a * e.a + t.b * e.c),
                (i.b = t.a * e.b + t.b * e.d),
                (i.c = t.c * e.a + t.d * e.c),
                (i.d = t.c * e.b + t.d * e.d),
                (i.tx = t.tx * e.a + t.ty * e.c + e.tx),
                (i.ty = t.tx * e.b + t.ty * e.d + e.ty),
                (this._parentID = s._worldID),
                this._worldID++)
        }
    }
    setFromMatrix(s) {
        ;(s.decompose(this), this._localID++)
    }
    get rotation() {
        return this._rotation
    }
    set rotation(s) {
        this._rotation !== s && ((this._rotation = s), this.updateSkew())
    }
}
qo.IDENTITY = new qo()
let Vh = qo
Vh.prototype.toString = function () {
    return `[@pixi/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`
}
var Og = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor *= texture2D(uSampler, vTextureCoord);
}`,
    Fg = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void){
   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
   vTextureCoord = aTextureCoord;
}
`
function vc(s, t, e) {
    const i = s.createShader(t)
    return (s.shaderSource(i, e), s.compileShader(i), i)
}
function co(s) {
    const t = new Array(s)
    for (let e = 0; e < t.length; e++) t[e] = !1
    return t
}
function Ld(s, t) {
    switch (s) {
        case 'float':
            return 0
        case 'vec2':
            return new Float32Array(2 * t)
        case 'vec3':
            return new Float32Array(3 * t)
        case 'vec4':
            return new Float32Array(4 * t)
        case 'int':
        case 'uint':
        case 'sampler2D':
        case 'sampler2DArray':
            return 0
        case 'ivec2':
            return new Int32Array(2 * t)
        case 'ivec3':
            return new Int32Array(3 * t)
        case 'ivec4':
            return new Int32Array(4 * t)
        case 'uvec2':
            return new Uint32Array(2 * t)
        case 'uvec3':
            return new Uint32Array(3 * t)
        case 'uvec4':
            return new Uint32Array(4 * t)
        case 'bool':
            return !1
        case 'bvec2':
            return co(2 * t)
        case 'bvec3':
            return co(3 * t)
        case 'bvec4':
            return co(4 * t)
        case 'mat2':
            return new Float32Array([1, 0, 0, 1])
        case 'mat3':
            return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1])
        case 'mat4':
            return new Float32Array([
                1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
            ])
    }
    return null
}
const Ar = [
        {
            test: s => s.type === 'float' && s.size === 1 && !s.isArray,
            code: s => `
            if(uv["${s}"] !== ud["${s}"].value)
            {
                ud["${s}"].value = uv["${s}"]
                gl.uniform1f(ud["${s}"].location, uv["${s}"])
            }
            `,
        },
        {
            test: (s, t) =>
                (s.type === 'sampler2D' ||
                    s.type === 'samplerCube' ||
                    s.type === 'sampler2DArray') &&
                s.size === 1 &&
                !s.isArray &&
                (t == null || t.castToBaseTexture !== void 0),
            code: s => `t = syncData.textureCount++;

            renderer.texture.bind(uv["${s}"], t);

            if(ud["${s}"].value !== t)
            {
                ud["${s}"].value = t;
                gl.uniform1i(ud["${s}"].location, t);
; // eslint-disable-line max-len
            }`,
        },
        {
            test: (s, t) =>
                s.type === 'mat3' &&
                s.size === 1 &&
                !s.isArray &&
                t.a !== void 0,
            code: s => `
            gl.uniformMatrix3fv(ud["${s}"].location, false, uv["${s}"].toArray(true));
            `,
            codeUbo: s => `
                var ${s}_matrix = uv.${s}.toArray(true);

                data[offset] = ${s}_matrix[0];
                data[offset+1] = ${s}_matrix[1];
                data[offset+2] = ${s}_matrix[2];
        
                data[offset + 4] = ${s}_matrix[3];
                data[offset + 5] = ${s}_matrix[4];
                data[offset + 6] = ${s}_matrix[5];
        
                data[offset + 8] = ${s}_matrix[6];
                data[offset + 9] = ${s}_matrix[7];
                data[offset + 10] = ${s}_matrix[8];
            `,
        },
        {
            test: (s, t) =>
                s.type === 'vec2' &&
                s.size === 1 &&
                !s.isArray &&
                t.x !== void 0,
            code: s => `
                cv = ud["${s}"].value;
                v = uv["${s}"];

                if(cv[0] !== v.x || cv[1] !== v.y)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    gl.uniform2f(ud["${s}"].location, v.x, v.y);
                }`,
            codeUbo: s => `
                v = uv.${s};

                data[offset] = v.x;
                data[offset+1] = v.y;
            `,
        },
        {
            test: s => s.type === 'vec2' && s.size === 1 && !s.isArray,
            code: s => `
                cv = ud["${s}"].value;
                v = uv["${s}"];

                if(cv[0] !== v[0] || cv[1] !== v[1])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    gl.uniform2f(ud["${s}"].location, v[0], v[1]);
                }
            `,
        },
        {
            test: (s, t) =>
                s.type === 'vec4' &&
                s.size === 1 &&
                !s.isArray &&
                t.width !== void 0,
            code: s => `
                cv = ud["${s}"].value;
                v = uv["${s}"];

                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    cv[2] = v.width;
                    cv[3] = v.height;
                    gl.uniform4f(ud["${s}"].location, v.x, v.y, v.width, v.height)
                }`,
            codeUbo: s => `
                    v = uv.${s};

                    data[offset] = v.x;
                    data[offset+1] = v.y;
                    data[offset+2] = v.width;
                    data[offset+3] = v.height;
                `,
        },
        {
            test: (s, t) =>
                s.type === 'vec4' &&
                s.size === 1 &&
                !s.isArray &&
                t.red !== void 0,
            code: s => `
                cv = ud["${s}"].value;
                v = uv["${s}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
                    cv[3] = v.alpha;
                    gl.uniform4f(ud["${s}"].location, v.red, v.green, v.blue, v.alpha)
                }`,
            codeUbo: s => `
                    v = uv.${s};

                    data[offset] = v.red;
                    data[offset+1] = v.green;
                    data[offset+2] = v.blue;
                    data[offset+3] = v.alpha;
                `,
        },
        {
            test: (s, t) =>
                s.type === 'vec3' &&
                s.size === 1 &&
                !s.isArray &&
                t.red !== void 0,
            code: s => `
                cv = ud["${s}"].value;
                v = uv["${s}"];

                if(cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.a)
                {
                    cv[0] = v.red;
                    cv[1] = v.green;
                    cv[2] = v.blue;
    
                    gl.uniform3f(ud["${s}"].location, v.red, v.green, v.blue)
                }`,
            codeUbo: s => `
                    v = uv.${s};

                    data[offset] = v.red;
                    data[offset+1] = v.green;
                    data[offset+2] = v.blue;
                `,
        },
        {
            test: s => s.type === 'vec4' && s.size === 1 && !s.isArray,
            code: s => `
                cv = ud["${s}"].value;
                v = uv["${s}"];

                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    cv[2] = v[2];
                    cv[3] = v[3];

                    gl.uniform4f(ud["${s}"].location, v[0], v[1], v[2], v[3])
                }`,
        },
    ],
    Lg = {
        float: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1f(location, v);
    }`,
        vec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2f(location, v[0], v[1])
    }`,
        vec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3f(location, v[0], v[1], v[2])
    }`,
        vec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4f(location, v[0], v[1], v[2], v[3]);
    }`,
        int: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
        ivec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
        ivec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
        ivec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
        uint: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1ui(location, v);
    }`,
        uvec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2ui(location, v[0], v[1]);
    }`,
        uvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3ui(location, v[0], v[1], v[2]);
    }`,
        uvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
    }`,
        bool: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1i(location, v);
    }`,
        bvec2: `
    if (cv[0] != v[0] || cv[1] != v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
        bvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
        bvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
        mat2: 'gl.uniformMatrix2fv(location, false, v)',
        mat3: 'gl.uniformMatrix3fv(location, false, v)',
        mat4: 'gl.uniformMatrix4fv(location, false, v)',
        sampler2D: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
        samplerCube: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
        sampler2DArray: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
    },
    kg = {
        float: 'gl.uniform1fv(location, v)',
        vec2: 'gl.uniform2fv(location, v)',
        vec3: 'gl.uniform3fv(location, v)',
        vec4: 'gl.uniform4fv(location, v)',
        mat4: 'gl.uniformMatrix4fv(location, false, v)',
        mat3: 'gl.uniformMatrix3fv(location, false, v)',
        mat2: 'gl.uniformMatrix2fv(location, false, v)',
        int: 'gl.uniform1iv(location, v)',
        ivec2: 'gl.uniform2iv(location, v)',
        ivec3: 'gl.uniform3iv(location, v)',
        ivec4: 'gl.uniform4iv(location, v)',
        uint: 'gl.uniform1uiv(location, v)',
        uvec2: 'gl.uniform2uiv(location, v)',
        uvec3: 'gl.uniform3uiv(location, v)',
        uvec4: 'gl.uniform4uiv(location, v)',
        bool: 'gl.uniform1iv(location, v)',
        bvec2: 'gl.uniform2iv(location, v)',
        bvec3: 'gl.uniform3iv(location, v)',
        bvec4: 'gl.uniform4iv(location, v)',
        sampler2D: 'gl.uniform1iv(location, v)',
        samplerCube: 'gl.uniform1iv(location, v)',
        sampler2DArray: 'gl.uniform1iv(location, v)',
    }
function Ng(s, t) {
    const e = [
        `
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
    `,
    ]
    for (const i in s.uniforms) {
        const r = t[i]
        if (!r) {
            s.uniforms[i]?.group === !0 &&
                (s.uniforms[i].ubo
                    ? e.push(`
                        renderer.shader.syncUniformBufferGroup(uv.${i}, '${i}');
                    `)
                    : e.push(`
                        renderer.shader.syncUniformGroup(uv.${i}, syncData);
                    `))
            continue
        }
        const n = s.uniforms[i]
        let a = !1
        for (let o = 0; o < Ar.length; o++)
            if (Ar[o].test(r, n)) {
                ;(e.push(Ar[o].code(i, n)), (a = !0))
                break
            }
        if (!a) {
            const o = (r.size === 1 && !r.isArray ? Lg : kg)[r.type].replace(
                'location',
                `ud["${i}"].location`,
            )
            e.push(`
            cu = ud["${i}"];
            cv = cu.value;
            v = uv["${i}"];
            ${o};`)
        }
    }
    return new Function(
        'ud',
        'uv',
        'renderer',
        'syncData',
        e.join(`
`),
    )
}
const kd = {}
let Bs = kd
function Ug() {
    if (Bs === kd || Bs?.isContextLost()) {
        const s = Y.ADAPTER.createCanvas()
        let t
        ;(Y.PREFER_ENV >= tr.WEBGL2 && (t = s.getContext('webgl2', {})),
            t ||
                ((t =
                    s.getContext('webgl', {}) ||
                    s.getContext('experimental-webgl', {})),
                t ? t.getExtension('WEBGL_draw_buffers') : (t = null)),
            (Bs = t))
    }
    return Bs
}
let Os
function Gg() {
    if (!Os) {
        Os = fe.MEDIUM
        const s = Ug()
        if (s && s.getShaderPrecisionFormat) {
            const t = s.getShaderPrecisionFormat(
                s.FRAGMENT_SHADER,
                s.HIGH_FLOAT,
            )
            t && (Os = t.precision ? fe.HIGH : fe.MEDIUM)
        }
    }
    return Os
}
function xc(s, t) {
    const e = s
            .getShaderSource(t)
            .split(
                `
`,
            )
            .map((l, u) => `${u}: ${l}`),
        i = s.getShaderInfoLog(t),
        r = i.split(`
`),
        n = {},
        a = r
            .map(l => parseFloat(l.replace(/^ERROR\: 0\:([\d]+)\:.*$/, '$1')))
            .filter(l => (l && !n[l] ? ((n[l] = !0), !0) : !1)),
        o = ['']
    a.forEach(l => {
        ;((e[l - 1] = `%c${e[l - 1]}%c`),
            o.push(
                'background: #FF0000; color:#FFFFFF; font-size: 10px',
                'font-size: 10px',
            ))
    })
    const h = e.join(`
`)
    ;((o[0] = h),
        console.error(i),
        console.groupCollapsed('click to view full shader code'),
        console.warn(...o),
        console.groupEnd())
}
function Hg(s, t, e, i) {
    s.getProgramParameter(t, s.LINK_STATUS) ||
        (s.getShaderParameter(e, s.COMPILE_STATUS) || xc(s, e),
        s.getShaderParameter(i, s.COMPILE_STATUS) || xc(s, i),
        console.error('PixiJS Error: Could not initialize shader.'),
        s.getProgramInfoLog(t) !== '' &&
            console.warn(
                'PixiJS Warning: gl.getProgramInfoLog()',
                s.getProgramInfoLog(t),
            ))
}
const zg = {
    float: 1,
    vec2: 2,
    vec3: 3,
    vec4: 4,
    int: 1,
    ivec2: 2,
    ivec3: 3,
    ivec4: 4,
    uint: 1,
    uvec2: 2,
    uvec3: 3,
    uvec4: 4,
    bool: 1,
    bvec2: 2,
    bvec3: 3,
    bvec4: 4,
    mat2: 4,
    mat3: 9,
    mat4: 16,
    sampler2D: 1,
}
function Nd(s) {
    return zg[s]
}
let Fs = null
const bc = {
    FLOAT: 'float',
    FLOAT_VEC2: 'vec2',
    FLOAT_VEC3: 'vec3',
    FLOAT_VEC4: 'vec4',
    INT: 'int',
    INT_VEC2: 'ivec2',
    INT_VEC3: 'ivec3',
    INT_VEC4: 'ivec4',
    UNSIGNED_INT: 'uint',
    UNSIGNED_INT_VEC2: 'uvec2',
    UNSIGNED_INT_VEC3: 'uvec3',
    UNSIGNED_INT_VEC4: 'uvec4',
    BOOL: 'bool',
    BOOL_VEC2: 'bvec2',
    BOOL_VEC3: 'bvec3',
    BOOL_VEC4: 'bvec4',
    FLOAT_MAT2: 'mat2',
    FLOAT_MAT3: 'mat3',
    FLOAT_MAT4: 'mat4',
    SAMPLER_2D: 'sampler2D',
    INT_SAMPLER_2D: 'sampler2D',
    UNSIGNED_INT_SAMPLER_2D: 'sampler2D',
    SAMPLER_CUBE: 'samplerCube',
    INT_SAMPLER_CUBE: 'samplerCube',
    UNSIGNED_INT_SAMPLER_CUBE: 'samplerCube',
    SAMPLER_2D_ARRAY: 'sampler2DArray',
    INT_SAMPLER_2D_ARRAY: 'sampler2DArray',
    UNSIGNED_INT_SAMPLER_2D_ARRAY: 'sampler2DArray',
}
function Ud(s, t) {
    if (!Fs) {
        const e = Object.keys(bc)
        Fs = {}
        for (let i = 0; i < e.length; ++i) {
            const r = e[i]
            Fs[s[r]] = bc[r]
        }
    }
    return Fs[t]
}
function wc(s, t, e) {
    if (s.substring(0, 9) !== 'precision') {
        let i = t
        return (
            t === fe.HIGH && e !== fe.HIGH && (i = fe.MEDIUM),
            `precision ${i} float;
${s}`
        )
    } else if (e !== fe.HIGH && s.substring(0, 15) === 'precision highp')
        return s.replace('precision highp', 'precision mediump')
    return s
}
let Wr
function Vg() {
    if (typeof Wr == 'boolean') return Wr
    try {
        Wr =
            new Function(
                'param1',
                'param2',
                'param3',
                'return param1[param2] === param3;',
            )({ a: 'b' }, 'a', 'b') === !0
    } catch {
        Wr = !1
    }
    return Wr
}
let Xg = 0
const Ls = {},
    Yo = class mr {
        constructor(t, e, i = 'pixi-shader', r = {}) {
            ;((this.extra = {}),
                (this.id = Xg++),
                (this.vertexSrc = t || mr.defaultVertexSrc),
                (this.fragmentSrc = e || mr.defaultFragmentSrc),
                (this.vertexSrc = this.vertexSrc.trim()),
                (this.fragmentSrc = this.fragmentSrc.trim()),
                (this.extra = r),
                this.vertexSrc.substring(0, 8) !== '#version' &&
                    ((i = i.replace(/\s+/g, '-')),
                    Ls[i] ? (Ls[i]++, (i += `-${Ls[i]}`)) : (Ls[i] = 1),
                    (this.vertexSrc = `#define SHADER_NAME ${i}
${this.vertexSrc}`),
                    (this.fragmentSrc = `#define SHADER_NAME ${i}
${this.fragmentSrc}`),
                    (this.vertexSrc = wc(
                        this.vertexSrc,
                        mr.defaultVertexPrecision,
                        fe.HIGH,
                    )),
                    (this.fragmentSrc = wc(
                        this.fragmentSrc,
                        mr.defaultFragmentPrecision,
                        Gg(),
                    ))),
                (this.glPrograms = {}),
                (this.syncUniforms = null))
        }
        static get defaultVertexSrc() {
            return Fg
        }
        static get defaultFragmentSrc() {
            return Og
        }
        static from(t, e, i) {
            const r = t + e
            let n = pc[r]
            return (n || (pc[r] = n = new mr(t, e, i)), n)
        }
    }
;((Yo.defaultVertexPrecision = fe.HIGH),
    (Yo.defaultFragmentPrecision = Qe.apple.device ? fe.HIGH : fe.MEDIUM))
let ti = Yo,
    Wg = 0
class Se {
    constructor(t, e, i) {
        ;((this.group = !0),
            (this.syncUniforms = {}),
            (this.dirtyId = 0),
            (this.id = Wg++),
            (this.static = !!e),
            (this.ubo = !!i),
            t instanceof Bt
                ? ((this.buffer = t),
                  (this.buffer.type = ze.UNIFORM_BUFFER),
                  (this.autoManage = !1),
                  (this.ubo = !0))
                : ((this.uniforms = t),
                  this.ubo &&
                      ((this.buffer = new Bt(new Float32Array(1))),
                      (this.buffer.type = ze.UNIFORM_BUFFER),
                      (this.autoManage = !0))))
    }
    update() {
        ;(this.dirtyId++,
            !this.autoManage && this.buffer && this.buffer.update())
    }
    add(t, e, i) {
        if (!this.ubo) this.uniforms[t] = new Se(e, i)
        else
            throw new Error(
                '[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them',
            )
    }
    static from(t, e, i) {
        return new Se(t, e, i)
    }
    static uboFrom(t, e) {
        return new Se(t, e ?? !0, !0)
    }
}
class Ve {
    constructor(t, e) {
        ;((this.uniformBindCount = 0),
            (this.program = t),
            e
                ? e instanceof Se
                    ? (this.uniformGroup = e)
                    : (this.uniformGroup = new Se(e))
                : (this.uniformGroup = new Se({})),
            (this.disposeRunner = new Ae('disposeShader')))
    }
    checkUniformExists(t, e) {
        if (e.uniforms[t]) return !0
        for (const i in e.uniforms) {
            const r = e.uniforms[i]
            if (r.group === !0 && this.checkUniformExists(t, r)) return !0
        }
        return !1
    }
    destroy() {
        ;((this.uniformGroup = null),
            this.disposeRunner.emit(this),
            this.disposeRunner.destroy())
    }
    get uniforms() {
        return this.uniformGroup.uniforms
    }
    static from(t, e, i) {
        const r = ti.from(t, e)
        return new Ve(r, i)
    }
}
class $g {
    constructor(t, e) {
        if (
            ((this.vertexSrc = t),
            (this.fragTemplate = e),
            (this.programCache = {}),
            (this.defaultGroupCache = {}),
            !e.includes('%count%'))
        )
            throw new Error('Fragment template must contain "%count%".')
        if (!e.includes('%forloop%'))
            throw new Error('Fragment template must contain "%forloop%".')
    }
    generateShader(t) {
        if (!this.programCache[t]) {
            const i = new Int32Array(t)
            for (let n = 0; n < t; n++) i[n] = n
            this.defaultGroupCache[t] = Se.from({ uSamplers: i }, !0)
            let r = this.fragTemplate
            ;((r = r.replace(/%count%/gi, `${t}`)),
                (r = r.replace(/%forloop%/gi, this.generateSampleSrc(t))),
                (this.programCache[t] = new ti(this.vertexSrc, r)))
        }
        const e = {
            tint: new Float32Array([1, 1, 1, 1]),
            translationMatrix: new Et(),
            default: this.defaultGroupCache[t],
        }
        return new Ve(this.programCache[t], e)
    }
    generateSampleSrc(t) {
        let e = ''
        ;((e += `
`),
            (e += `
`))
        for (let i = 0; i < t; i++)
            (i > 0 &&
                (e += `
else `),
                i < t - 1 && (e += `if(vTextureId < ${i}.5)`),
                (e += `
{`),
                (e += `
	color = texture2D(uSamplers[${i}], vTextureCoord);`),
                (e += `
}`))
        return (
            (e += `
`),
            (e += `
`),
            e
        )
    }
}
class Ko {
    constructor() {
        ;((this.elements = []), (this.ids = []), (this.count = 0))
    }
    clear() {
        for (let t = 0; t < this.count; t++) this.elements[t] = null
        this.count = 0
    }
}
function jg() {
    return !Qe.apple.device
}
function qg(s) {
    let t = !0
    const e = Y.ADAPTER.getNavigator()
    if (Qe.tablet || Qe.phone) {
        if (Qe.apple.device) {
            const i = e.userAgent.match(/OS (\d+)_(\d+)?/)
            i && parseInt(i[1], 10) < 11 && (t = !1)
        }
        if (Qe.android.device) {
            const i = e.userAgent.match(/Android\s([0-9.]*)/)
            i && parseInt(i[1], 10) < 7 && (t = !1)
        }
    }
    return t ? s : 4
}
class Un {
    constructor(t) {
        this.renderer = t
    }
    flush() {}
    destroy() {
        this.renderer = null
    }
    start() {}
    stop() {
        this.flush()
    }
    render(t) {}
}
var Yg = `varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;
uniform sampler2D uSamplers[%count%];

void main(void){
    vec4 color;
    %forloop%
    gl_FragColor = color * vColor;
}
`,
    Kg = `precision highp float;
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;
attribute float aTextureId;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform vec4 tint;

varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;

void main(void){
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vTextureId = aTextureId;
    vColor = aColor * tint;
}
`
const Kr = class we extends Un {
    constructor(t) {
        ;(super(t),
            this.setShaderGenerator(),
            (this.geometryClass = Od),
            (this.vertexSize = 6),
            (this.state = $e.for2d()),
            (this.size = we.defaultBatchSize * 4),
            (this._vertexCount = 0),
            (this._indexCount = 0),
            (this._bufferedElements = []),
            (this._bufferedTextures = []),
            (this._bufferSize = 0),
            (this._shader = null),
            (this._packedGeometries = []),
            (this._packedGeometryPoolSize = 2),
            (this._flushId = 0),
            (this._aBuffers = {}),
            (this._iBuffers = {}),
            (this.maxTextures = 1),
            this.renderer.on('prerender', this.onPrerender, this),
            t.runners.contextChange.add(this),
            (this._dcIndex = 0),
            (this._aIndex = 0),
            (this._iIndex = 0),
            (this._attributeBuffer = null),
            (this._indexBuffer = null),
            (this._tempBoundTextures = []))
    }
    static get defaultMaxTextures() {
        return (
            (this._defaultMaxTextures = this._defaultMaxTextures ?? qg(32)),
            this._defaultMaxTextures
        )
    }
    static set defaultMaxTextures(t) {
        this._defaultMaxTextures = t
    }
    static get canUploadSameBuffer() {
        return (
            (this._canUploadSameBuffer = this._canUploadSameBuffer ?? jg()),
            this._canUploadSameBuffer
        )
    }
    static set canUploadSameBuffer(t) {
        this._canUploadSameBuffer = t
    }
    get MAX_TEXTURES() {
        return (
            ft(
                '7.1.0',
                'BatchRenderer#MAX_TEXTURES renamed to BatchRenderer#maxTextures',
            ),
            this.maxTextures
        )
    }
    static get defaultVertexSrc() {
        return Kg
    }
    static get defaultFragmentTemplate() {
        return Yg
    }
    setShaderGenerator({
        vertex: t = we.defaultVertexSrc,
        fragment: e = we.defaultFragmentTemplate,
    } = {}) {
        this.shaderGenerator = new $g(t, e)
    }
    contextChange() {
        const t = this.renderer.gl
        ;(Y.PREFER_ENV === tr.WEBGL_LEGACY
            ? (this.maxTextures = 1)
            : ((this.maxTextures = Math.min(
                  t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
                  we.defaultMaxTextures,
              )),
              (this.maxTextures = Eg(this.maxTextures, t))),
            (this._shader = this.shaderGenerator.generateShader(
                this.maxTextures,
            )))
        for (let e = 0; e < this._packedGeometryPoolSize; e++)
            this._packedGeometries[e] = new this.geometryClass()
        this.initFlushBuffers()
    }
    initFlushBuffers() {
        const { _drawCallPool: t, _textureArrayPool: e } = we,
            i = this.size / 4,
            r = Math.floor(i / this.maxTextures) + 1
        for (; t.length < i; ) t.push(new Wo())
        for (; e.length < r; ) e.push(new Ko())
        for (let n = 0; n < this.maxTextures; n++)
            this._tempBoundTextures[n] = null
    }
    onPrerender() {
        this._flushId = 0
    }
    render(t) {
        t._texture.valid &&
            (this._vertexCount + t.vertexData.length / 2 > this.size &&
                this.flush(),
            (this._vertexCount += t.vertexData.length / 2),
            (this._indexCount += t.indices.length),
            (this._bufferedTextures[this._bufferSize] = t._texture.baseTexture),
            (this._bufferedElements[this._bufferSize++] = t))
    }
    buildTexturesAndDrawCalls() {
        const { _bufferedTextures: t, maxTextures: e } = this,
            i = we._textureArrayPool,
            r = this.renderer.batch,
            n = this._tempBoundTextures,
            a = this.renderer.textureGC.count
        let o = ++lt._globalBatch,
            h = 0,
            l = i[0],
            u = 0
        r.copyBoundTextures(n, e)
        for (let c = 0; c < this._bufferSize; ++c) {
            const d = t[c]
            ;((t[c] = null),
                d._batchEnabled !== o &&
                    (l.count >= e &&
                        (r.boundArray(l, n, o, e),
                        this.buildDrawCalls(l, u, c),
                        (u = c),
                        (l = i[++h]),
                        ++o),
                    (d._batchEnabled = o),
                    (d.touched = a),
                    (l.elements[l.count++] = d)))
        }
        l.count > 0 &&
            (r.boundArray(l, n, o, e),
            this.buildDrawCalls(l, u, this._bufferSize),
            ++h,
            ++o)
        for (let c = 0; c < n.length; c++) n[c] = null
        lt._globalBatch = o
    }
    buildDrawCalls(t, e, i) {
        const {
                _bufferedElements: r,
                _attributeBuffer: n,
                _indexBuffer: a,
                vertexSize: o,
            } = this,
            h = we._drawCallPool
        let l = this._dcIndex,
            u = this._aIndex,
            c = this._iIndex,
            d = h[l]
        ;((d.start = this._iIndex), (d.texArray = t))
        for (let f = e; f < i; ++f) {
            const m = r[f],
                p = m._texture.baseTexture,
                g = Id[p.alphaMode ? 1 : 0][m.blendMode]
            ;((r[f] = null),
                e < f &&
                    d.blend !== g &&
                    ((d.size = c - d.start),
                    (e = f),
                    (d = h[++l]),
                    (d.texArray = t),
                    (d.start = c)),
                this.packInterleavedGeometry(m, n, a, u, c),
                (u += (m.vertexData.length / 2) * o),
                (c += m.indices.length),
                (d.blend = g))
        }
        ;(e < i && ((d.size = c - d.start), ++l),
            (this._dcIndex = l),
            (this._aIndex = u),
            (this._iIndex = c))
    }
    bindAndClearTexArray(t) {
        const e = this.renderer.texture
        for (let i = 0; i < t.count; i++)
            (e.bind(t.elements[i], t.ids[i]), (t.elements[i] = null))
        t.count = 0
    }
    updateGeometry() {
        const {
            _packedGeometries: t,
            _attributeBuffer: e,
            _indexBuffer: i,
        } = this
        we.canUploadSameBuffer
            ? (t[this._flushId]._buffer.update(e.rawBinaryData),
              t[this._flushId]._indexBuffer.update(i),
              this.renderer.geometry.updateBuffers())
            : (this._packedGeometryPoolSize <= this._flushId &&
                  (this._packedGeometryPoolSize++,
                  (t[this._flushId] = new this.geometryClass())),
              t[this._flushId]._buffer.update(e.rawBinaryData),
              t[this._flushId]._indexBuffer.update(i),
              this.renderer.geometry.bind(t[this._flushId]),
              this.renderer.geometry.updateBuffers(),
              this._flushId++)
    }
    drawBatches() {
        const t = this._dcIndex,
            { gl: e, state: i } = this.renderer,
            r = we._drawCallPool
        let n = null
        for (let a = 0; a < t; a++) {
            const { texArray: o, type: h, size: l, start: u, blend: c } = r[a]
            ;(n !== o && ((n = o), this.bindAndClearTexArray(o)),
                (this.state.blendMode = c),
                i.set(this.state),
                e.drawElements(h, l, e.UNSIGNED_SHORT, u * 2))
        }
    }
    flush() {
        this._vertexCount !== 0 &&
            ((this._attributeBuffer = this.getAttributeBuffer(
                this._vertexCount,
            )),
            (this._indexBuffer = this.getIndexBuffer(this._indexCount)),
            (this._aIndex = 0),
            (this._iIndex = 0),
            (this._dcIndex = 0),
            this.buildTexturesAndDrawCalls(),
            this.updateGeometry(),
            this.drawBatches(),
            (this._bufferSize = 0),
            (this._vertexCount = 0),
            (this._indexCount = 0))
    }
    start() {
        ;(this.renderer.state.set(this.state),
            this.renderer.texture.ensureSamplerType(this.maxTextures),
            this.renderer.shader.bind(this._shader),
            we.canUploadSameBuffer &&
                this.renderer.geometry.bind(
                    this._packedGeometries[this._flushId],
                ))
    }
    stop() {
        this.flush()
    }
    destroy() {
        for (let t = 0; t < this._packedGeometryPoolSize; t++)
            this._packedGeometries[t] && this._packedGeometries[t].destroy()
        ;(this.renderer.off('prerender', this.onPrerender, this),
            (this._aBuffers = null),
            (this._iBuffers = null),
            (this._packedGeometries = null),
            (this._attributeBuffer = null),
            (this._indexBuffer = null),
            this._shader && (this._shader.destroy(), (this._shader = null)),
            super.destroy())
    }
    getAttributeBuffer(t) {
        const e = dn(Math.ceil(t / 8)),
            i = dc(e),
            r = e * 8
        this._aBuffers.length <= i && (this._iBuffers.length = i + 1)
        let n = this._aBuffers[r]
        return (
            n || (this._aBuffers[r] = n = new zo(r * this.vertexSize * 4)),
            n
        )
    }
    getIndexBuffer(t) {
        const e = dn(Math.ceil(t / 12)),
            i = dc(e),
            r = e * 12
        this._iBuffers.length <= i && (this._iBuffers.length = i + 1)
        let n = this._iBuffers[i]
        return (n || (this._iBuffers[i] = n = new Uint16Array(r)), n)
    }
    packInterleavedGeometry(t, e, i, r, n) {
        const { uint32View: a, float32View: o } = e,
            h = r / this.vertexSize,
            l = t.uvs,
            u = t.indices,
            c = t.vertexData,
            d = t._texture.baseTexture._batchLocation,
            f = Math.min(t.worldAlpha, 1),
            m = Tt.shared
                .setValue(t._tintRGB)
                .toPremultiplied(f, t._texture.baseTexture.alphaMode > 0)
        for (let p = 0; p < c.length; p += 2)
            ((o[r++] = c[p]),
                (o[r++] = c[p + 1]),
                (o[r++] = l[p]),
                (o[r++] = l[p + 1]),
                (a[r++] = m),
                (o[r++] = d))
        for (let p = 0; p < u.length; p++) i[n++] = h + u[p]
    }
}
;((Kr.defaultBatchSize = 4096),
    (Kr.extension = { name: 'batch', type: $.RendererPlugin }),
    (Kr._drawCallPool = []),
    (Kr._textureArrayPool = []))
let Ui = Kr
Q.add(Ui)
var Zg = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor = texture2D(uSampler, vTextureCoord);
}
`,
    Qg = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`
const Zo = class Zr extends Ve {
    constructor(t, e, i) {
        const r = ti.from(t || Zr.defaultVertexSrc, e || Zr.defaultFragmentSrc)
        ;(super(r, i),
            (this.padding = 0),
            (this.resolution = Zr.defaultResolution),
            (this.multisample = Zr.defaultMultisample),
            (this.enabled = !0),
            (this.autoFit = !0),
            (this.state = new $e()))
    }
    apply(t, e, i, r, n) {
        t.applyFilter(this, e, i, r)
    }
    get blendMode() {
        return this.state.blendMode
    }
    set blendMode(t) {
        this.state.blendMode = t
    }
    get resolution() {
        return this._resolution
    }
    set resolution(t) {
        this._resolution = t
    }
    static get defaultVertexSrc() {
        return Qg
    }
    static get defaultFragmentSrc() {
        return Zg
    }
}
;((Zo.defaultResolution = 1), (Zo.defaultMultisample = Ft.NONE))
let qt = Zo
class mn {
    constructor() {
        ;((this.clearBeforeRender = !0),
            (this._backgroundColor = new Tt(0)),
            (this.alpha = 1))
    }
    init(t) {
        this.clearBeforeRender = t.clearBeforeRender
        const { backgroundColor: e, background: i, backgroundAlpha: r } = t,
            n = i ?? e
        ;(n !== void 0 && (this.color = n), (this.alpha = r))
    }
    get color() {
        return this._backgroundColor.value
    }
    set color(t) {
        this._backgroundColor.setValue(t)
    }
    get alpha() {
        return this._backgroundColor.alpha
    }
    set alpha(t) {
        this._backgroundColor.setAlpha(t)
    }
    get backgroundColor() {
        return this._backgroundColor
    }
    destroy() {}
}
;((mn.defaultOptions = {
    backgroundAlpha: 1,
    backgroundColor: 0,
    clearBeforeRender: !0,
}),
    (mn.extension = {
        type: [$.RendererSystem, $.CanvasRendererSystem],
        name: 'background',
    }))
Q.add(mn)
class Gd {
    constructor(t) {
        ;((this.renderer = t),
            (this.emptyRenderer = new Un(t)),
            (this.currentRenderer = this.emptyRenderer))
    }
    setObjectRenderer(t) {
        this.currentRenderer !== t &&
            (this.currentRenderer.stop(),
            (this.currentRenderer = t),
            this.currentRenderer.start())
    }
    flush() {
        this.setObjectRenderer(this.emptyRenderer)
    }
    reset() {
        this.setObjectRenderer(this.emptyRenderer)
    }
    copyBoundTextures(t, e) {
        const { boundTextures: i } = this.renderer.texture
        for (let r = e - 1; r >= 0; --r)
            ((t[r] = i[r] || null), t[r] && (t[r]._batchLocation = r))
    }
    boundArray(t, e, i, r) {
        const { elements: n, ids: a, count: o } = t
        let h = 0
        for (let l = 0; l < o; l++) {
            const u = n[l],
                c = u._batchLocation
            if (c >= 0 && c < r && e[c] === u) {
                a[l] = c
                continue
            }
            for (; h < r; ) {
                const d = e[h]
                if (d && d._batchEnabled === i && d._batchLocation === h) {
                    h++
                    continue
                }
                ;((a[l] = h), (u._batchLocation = h), (e[h] = u))
                break
            }
        }
    }
    destroy() {
        this.renderer = null
    }
}
Gd.extension = { type: $.RendererSystem, name: 'batch' }
Q.add(Gd)
let Tc = 0
class gn {
    constructor(t) {
        ;((this.renderer = t),
            (this.webGLVersion = 1),
            (this.extensions = {}),
            (this.supports = { uint32Indices: !1 }),
            (this.handleContextLost = this.handleContextLost.bind(this)),
            (this.handleContextRestored =
                this.handleContextRestored.bind(this)))
    }
    get isLost() {
        return !this.gl || this.gl.isContextLost()
    }
    contextChange(t) {
        ;((this.gl = t),
            (this.renderer.gl = t),
            (this.renderer.CONTEXT_UID = Tc++))
    }
    init(t) {
        if (t.context) this.initFromContext(t.context)
        else {
            const e = this.renderer.background.alpha < 1,
                i = t.premultipliedAlpha
            ;((this.preserveDrawingBuffer = t.preserveDrawingBuffer),
                (this.useContextAlpha = t.useContextAlpha),
                (this.powerPreference = t.powerPreference),
                this.initFromOptions({
                    alpha: e,
                    premultipliedAlpha: i,
                    antialias: t.antialias,
                    stencil: !0,
                    preserveDrawingBuffer: t.preserveDrawingBuffer,
                    powerPreference: t.powerPreference,
                }))
        }
    }
    initFromContext(t) {
        ;((this.gl = t),
            this.validateContext(t),
            (this.renderer.gl = t),
            (this.renderer.CONTEXT_UID = Tc++),
            this.renderer.runners.contextChange.emit(t))
        const e = this.renderer.view
        e.addEventListener !== void 0 &&
            (e.addEventListener('webglcontextlost', this.handleContextLost, !1),
            e.addEventListener(
                'webglcontextrestored',
                this.handleContextRestored,
                !1,
            ))
    }
    initFromOptions(t) {
        const e = this.createContext(this.renderer.view, t)
        this.initFromContext(e)
    }
    createContext(t, e) {
        let i
        if ((Y.PREFER_ENV >= tr.WEBGL2 && (i = t.getContext('webgl2', e)), i))
            this.webGLVersion = 2
        else if (
            ((this.webGLVersion = 1),
            (i =
                t.getContext('webgl', e) ||
                t.getContext('experimental-webgl', e)),
            !i)
        )
            throw new Error(
                'This browser does not support WebGL. Try using the canvas renderer',
            )
        return ((this.gl = i), this.getExtensions(), this.gl)
    }
    getExtensions() {
        const { gl: t } = this,
            e = {
                loseContext: t.getExtension('WEBGL_lose_context'),
                anisotropicFiltering: t.getExtension(
                    'EXT_texture_filter_anisotropic',
                ),
                floatTextureLinear: t.getExtension('OES_texture_float_linear'),
                s3tc: t.getExtension('WEBGL_compressed_texture_s3tc'),
                s3tc_sRGB: t.getExtension('WEBGL_compressed_texture_s3tc_srgb'),
                etc: t.getExtension('WEBGL_compressed_texture_etc'),
                etc1: t.getExtension('WEBGL_compressed_texture_etc1'),
                pvrtc:
                    t.getExtension('WEBGL_compressed_texture_pvrtc') ||
                    t.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc'),
                atc: t.getExtension('WEBGL_compressed_texture_atc'),
                astc: t.getExtension('WEBGL_compressed_texture_astc'),
                bptc: t.getExtension('EXT_texture_compression_bptc'),
            }
        this.webGLVersion === 1
            ? Object.assign(this.extensions, e, {
                  drawBuffers: t.getExtension('WEBGL_draw_buffers'),
                  depthTexture: t.getExtension('WEBGL_depth_texture'),
                  vertexArrayObject:
                      t.getExtension('OES_vertex_array_object') ||
                      t.getExtension('MOZ_OES_vertex_array_object') ||
                      t.getExtension('WEBKIT_OES_vertex_array_object'),
                  uint32ElementIndex: t.getExtension('OES_element_index_uint'),
                  floatTexture: t.getExtension('OES_texture_float'),
                  floatTextureLinear: t.getExtension(
                      'OES_texture_float_linear',
                  ),
                  textureHalfFloat: t.getExtension('OES_texture_half_float'),
                  textureHalfFloatLinear: t.getExtension(
                      'OES_texture_half_float_linear',
                  ),
              })
            : this.webGLVersion === 2 &&
              Object.assign(this.extensions, e, {
                  colorBufferFloat: t.getExtension('EXT_color_buffer_float'),
              })
    }
    handleContextLost(t) {
        ;(t.preventDefault(),
            setTimeout(() => {
                this.gl.isContextLost() &&
                    this.extensions.loseContext &&
                    this.extensions.loseContext.restoreContext()
            }, 0))
    }
    handleContextRestored() {
        this.renderer.runners.contextChange.emit(this.gl)
    }
    destroy() {
        const t = this.renderer.view
        ;((this.renderer = null),
            t.removeEventListener !== void 0 &&
                (t.removeEventListener(
                    'webglcontextlost',
                    this.handleContextLost,
                ),
                t.removeEventListener(
                    'webglcontextrestored',
                    this.handleContextRestored,
                )),
            this.gl.useProgram(null),
            this.extensions.loseContext &&
                this.extensions.loseContext.loseContext())
    }
    postrender() {
        this.renderer.objectRenderer.renderingToScreen && this.gl.flush()
    }
    validateContext(t) {
        const e = t.getContextAttributes(),
            i =
                'WebGL2RenderingContext' in globalThis &&
                t instanceof globalThis.WebGL2RenderingContext
        ;(i && (this.webGLVersion = 2),
            e &&
                !e.stencil &&
                console.warn(
                    'Provided WebGL context does not have a stencil buffer, masks may not render correctly',
                ))
        const r = i || !!t.getExtension('OES_element_index_uint')
        ;((this.supports.uint32Indices = r),
            r ||
                console.warn(
                    'Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly',
                ))
    }
}
;((gn.defaultOptions = {
    context: null,
    antialias: !1,
    premultipliedAlpha: !0,
    preserveDrawingBuffer: !1,
    powerPreference: 'default',
}),
    (gn.extension = { type: $.RendererSystem, name: 'context' }))
Q.add(gn)
class Qo {
    constructor(t, e) {
        if (
            ((this.width = Math.round(t)),
            (this.height = Math.round(e)),
            !this.width || !this.height)
        )
            throw new Error('Framebuffer width or height is zero')
        ;((this.stencil = !1),
            (this.depth = !1),
            (this.dirtyId = 0),
            (this.dirtyFormat = 0),
            (this.dirtySize = 0),
            (this.depthTexture = null),
            (this.colorTextures = []),
            (this.glFramebuffers = {}),
            (this.disposeRunner = new Ae('disposeFramebuffer')),
            (this.multisample = Ft.NONE))
    }
    get colorTexture() {
        return this.colorTextures[0]
    }
    addColorTexture(t = 0, e) {
        return (
            (this.colorTextures[t] =
                e ||
                new lt(null, {
                    scaleMode: Ze.NEAREST,
                    resolution: 1,
                    mipmap: Xe.OFF,
                    width: this.width,
                    height: this.height,
                })),
            this.dirtyId++,
            this.dirtyFormat++,
            this
        )
    }
    addDepthTexture(t) {
        return (
            (this.depthTexture =
                t ||
                new lt(null, {
                    scaleMode: Ze.NEAREST,
                    resolution: 1,
                    width: this.width,
                    height: this.height,
                    mipmap: Xe.OFF,
                    format: X.DEPTH_COMPONENT,
                    type: at.UNSIGNED_SHORT,
                })),
            this.dirtyId++,
            this.dirtyFormat++,
            this
        )
    }
    enableDepth() {
        return ((this.depth = !0), this.dirtyId++, this.dirtyFormat++, this)
    }
    enableStencil() {
        return ((this.stencil = !0), this.dirtyId++, this.dirtyFormat++, this)
    }
    resize(t, e) {
        if (((t = Math.round(t)), (e = Math.round(e)), !t || !e))
            throw new Error('Framebuffer width and height must not be zero')
        if (!(t === this.width && e === this.height)) {
            ;((this.width = t),
                (this.height = e),
                this.dirtyId++,
                this.dirtySize++)
            for (let i = 0; i < this.colorTextures.length; i++) {
                const r = this.colorTextures[i],
                    n = r.resolution
                r.setSize(t / n, e / n)
            }
            if (this.depthTexture) {
                const i = this.depthTexture.resolution
                this.depthTexture.setSize(t / i, e / i)
            }
        }
    }
    dispose() {
        this.disposeRunner.emit(this, !1)
    }
    destroyDepthTexture() {
        this.depthTexture &&
            (this.depthTexture.destroy(),
            (this.depthTexture = null),
            ++this.dirtyId,
            ++this.dirtyFormat)
    }
}
class Hd extends lt {
    constructor(t = {}) {
        if (typeof t == 'number') {
            const e = arguments[0],
                i = arguments[1],
                r = arguments[2],
                n = arguments[3]
            t = { width: e, height: i, scaleMode: r, resolution: n }
        }
        ;((t.width = t.width ?? 100),
            (t.height = t.height ?? 100),
            t.multisample ?? (t.multisample = Ft.NONE),
            super(null, t),
            (this.mipmap = Xe.OFF),
            (this.valid = !0),
            (this._clear = new Tt([0, 0, 0, 0])),
            (this.framebuffer = new Qo(
                this.realWidth,
                this.realHeight,
            ).addColorTexture(0, this)),
            (this.framebuffer.multisample = t.multisample),
            (this.maskStack = []),
            (this.filterStack = [{}]))
    }
    set clearColor(t) {
        this._clear.setValue(t)
    }
    get clearColor() {
        return this._clear.value
    }
    get clear() {
        return this._clear
    }
    get multisample() {
        return this.framebuffer.multisample
    }
    set multisample(t) {
        this.framebuffer.multisample = t
    }
    resize(t, e) {
        ;(this.framebuffer.resize(t * this.resolution, e * this.resolution),
            this.setRealSize(this.framebuffer.width, this.framebuffer.height))
    }
    dispose() {
        ;(this.framebuffer.dispose(), super.dispose())
    }
    destroy() {
        ;(super.destroy(),
            this.framebuffer.destroyDepthTexture(),
            (this.framebuffer = null))
    }
}
class ri extends ls {
    constructor(t) {
        const e = t,
            i = e.naturalWidth || e.videoWidth || e.displayWidth || e.width,
            r = e.naturalHeight || e.videoHeight || e.displayHeight || e.height
        ;(super(i, r), (this.source = t), (this.noSubImage = !1))
    }
    static crossOrigin(t, e, i) {
        i === void 0 && !e.startsWith('data:')
            ? (t.crossOrigin = bg(e))
            : i !== !1 &&
              (t.crossOrigin = typeof i == 'string' ? i : 'anonymous')
    }
    upload(t, e, i, r) {
        const n = t.gl,
            a = e.realWidth,
            o = e.realHeight
        if (
            ((r = r || this.source),
            typeof HTMLImageElement < 'u' && r instanceof HTMLImageElement)
        ) {
            if (!r.complete || r.naturalWidth === 0) return !1
        } else if (
            typeof HTMLVideoElement < 'u' &&
            r instanceof HTMLVideoElement &&
            r.readyState <= 1
        )
            return !1
        return (
            n.pixelStorei(
                n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                e.alphaMode === Zt.UNPACK,
            ),
            !this.noSubImage &&
            e.target === n.TEXTURE_2D &&
            i.width === a &&
            i.height === o
                ? n.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, e.format, i.type, r)
                : ((i.width = a),
                  (i.height = o),
                  n.texImage2D(
                      e.target,
                      0,
                      i.internalFormat,
                      e.format,
                      i.type,
                      r,
                  )),
            !0
        )
    }
    update() {
        if (this.destroyed) return
        const t = this.source,
            e = t.naturalWidth || t.videoWidth || t.width,
            i = t.naturalHeight || t.videoHeight || t.height
        ;(this.resize(e, i), super.update())
    }
    dispose() {
        this.source = null
    }
}
class zd extends ri {
    constructor(t, e) {
        if (((e = e || {}), typeof t == 'string')) {
            const i = new Image()
            ;(ri.crossOrigin(i, t, e.crossorigin), (i.src = t), (t = i))
        }
        ;(super(t),
            !t.complete &&
                this._width &&
                this._height &&
                ((this._width = 0), (this._height = 0)),
            (this.url = t.src),
            (this._process = null),
            (this.preserveBitmap = !1),
            (this.createBitmap =
                (e.createBitmap ?? Y.CREATE_IMAGE_BITMAP) &&
                !!globalThis.createImageBitmap),
            (this.alphaMode =
                typeof e.alphaMode == 'number' ? e.alphaMode : null),
            (this.bitmap = null),
            (this._load = null),
            e.autoLoad !== !1 && this.load())
    }
    load(t) {
        return this._load
            ? this._load
            : (t !== void 0 && (this.createBitmap = t),
              (this._load = new Promise((e, i) => {
                  const r = this.source
                  this.url = r.src
                  const n = () => {
                      this.destroyed ||
                          ((r.onload = null),
                          (r.onerror = null),
                          this.update(),
                          (this._load = null),
                          this.createBitmap ? e(this.process()) : e(this))
                  }
                  r.complete && r.src
                      ? n()
                      : ((r.onload = n),
                        (r.onerror = a => {
                            ;(i(a), this.onError.emit(a))
                        }))
              })),
              this._load)
    }
    process() {
        const t = this.source
        if (this._process !== null) return this._process
        if (this.bitmap !== null || !globalThis.createImageBitmap)
            return Promise.resolve(this)
        const e = globalThis.createImageBitmap,
            i = !t.crossOrigin || t.crossOrigin === 'anonymous'
        return (
            (this._process = fetch(t.src, { mode: i ? 'cors' : 'no-cors' })
                .then(r => r.blob())
                .then(r =>
                    e(r, 0, 0, t.width, t.height, {
                        premultiplyAlpha:
                            this.alphaMode === null ||
                            this.alphaMode === Zt.UNPACK
                                ? 'premultiply'
                                : 'none',
                    }),
                )
                .then(r =>
                    this.destroyed
                        ? Promise.reject()
                        : ((this.bitmap = r),
                          this.update(),
                          (this._process = null),
                          Promise.resolve(this)),
                )),
            this._process
        )
    }
    upload(t, e, i) {
        if (
            (typeof this.alphaMode == 'number' &&
                (e.alphaMode = this.alphaMode),
            !this.createBitmap)
        )
            return super.upload(t, e, i)
        if (!this.bitmap && (this.process(), !this.bitmap)) return !1
        if ((super.upload(t, e, i, this.bitmap), !this.preserveBitmap)) {
            let r = !0
            const n = e._glTextures
            for (const a in n) {
                const o = n[a]
                if (o !== i && o.dirtyId !== e.dirtyId) {
                    r = !1
                    break
                }
            }
            r &&
                (this.bitmap.close && this.bitmap.close(), (this.bitmap = null))
        }
        return !0
    }
    dispose() {
        ;((this.source.onload = null),
            (this.source.onerror = null),
            super.dispose(),
            this.bitmap && (this.bitmap.close(), (this.bitmap = null)),
            (this._process = null),
            (this._load = null))
    }
    static test(t) {
        return (
            typeof HTMLImageElement < 'u' &&
            (typeof t == 'string' || t instanceof HTMLImageElement)
        )
    }
}
class Xh {
    constructor() {
        ;((this.x0 = 0),
            (this.y0 = 0),
            (this.x1 = 1),
            (this.y1 = 0),
            (this.x2 = 1),
            (this.y2 = 1),
            (this.x3 = 0),
            (this.y3 = 1),
            (this.uvsFloat32 = new Float32Array(8)))
    }
    set(t, e, i) {
        const r = e.width,
            n = e.height
        if (i) {
            const a = t.width / 2 / r,
                o = t.height / 2 / n,
                h = t.x / r + a,
                l = t.y / n + o
            ;((i = St.add(i, St.NW)),
                (this.x0 = h + a * St.uX(i)),
                (this.y0 = l + o * St.uY(i)),
                (i = St.add(i, 2)),
                (this.x1 = h + a * St.uX(i)),
                (this.y1 = l + o * St.uY(i)),
                (i = St.add(i, 2)),
                (this.x2 = h + a * St.uX(i)),
                (this.y2 = l + o * St.uY(i)),
                (i = St.add(i, 2)),
                (this.x3 = h + a * St.uX(i)),
                (this.y3 = l + o * St.uY(i)))
        } else
            ((this.x0 = t.x / r),
                (this.y0 = t.y / n),
                (this.x1 = (t.x + t.width) / r),
                (this.y1 = t.y / n),
                (this.x2 = (t.x + t.width) / r),
                (this.y2 = (t.y + t.height) / n),
                (this.x3 = t.x / r),
                (this.y3 = (t.y + t.height) / n))
        ;((this.uvsFloat32[0] = this.x0),
            (this.uvsFloat32[1] = this.y0),
            (this.uvsFloat32[2] = this.x1),
            (this.uvsFloat32[3] = this.y1),
            (this.uvsFloat32[4] = this.x2),
            (this.uvsFloat32[5] = this.y2),
            (this.uvsFloat32[6] = this.x3),
            (this.uvsFloat32[7] = this.y3))
    }
}
Xh.prototype.toString = function () {
    return `[@pixi/core:TextureUvs x0=${this.x0} y0=${this.y0} x1=${this.x1} y1=${this.y1} x2=${this.x2} y2=${this.y2} x3=${this.x3} y3=${this.y3}]`
}
const Ec = new Xh()
function ks(s) {
    ;((s.destroy = function () {}),
        (s.on = function () {}),
        (s.once = function () {}),
        (s.emit = function () {}))
}
class j extends vs {
    constructor(t, e, i, r, n, a, o) {
        if (
            (super(),
            (this.noFrame = !1),
            e || ((this.noFrame = !0), (e = new dt(0, 0, 1, 1))),
            t instanceof j && (t = t.baseTexture),
            (this.baseTexture = t),
            (this._frame = e),
            (this.trim = r),
            (this.valid = !1),
            (this.destroyed = !1),
            (this._uvs = Ec),
            (this.uvMatrix = null),
            (this.orig = i || e),
            (this._rotate = Number(n || 0)),
            n === !0)
        )
            this._rotate = 2
        else if (this._rotate % 2 !== 0)
            throw new Error(
                'attempt to use diamond-shaped UVs. If you are sure, set rotation manually',
            )
        ;((this.defaultAnchor = a ? new ut(a.x, a.y) : new ut(0, 0)),
            (this.defaultBorders = o),
            (this._updateID = 0),
            (this.textureCacheIds = []),
            t.valid
                ? this.noFrame
                    ? t.valid && this.onBaseTextureUpdated(t)
                    : (this.frame = e)
                : t.once('loaded', this.onBaseTextureUpdated, this),
            this.noFrame && t.on('update', this.onBaseTextureUpdated, this))
    }
    update() {
        this.baseTexture.resource && this.baseTexture.resource.update()
    }
    onBaseTextureUpdated(t) {
        if (this.noFrame) {
            if (!this.baseTexture.valid) return
            ;((this._frame.width = t.width),
                (this._frame.height = t.height),
                (this.valid = !0),
                this.updateUvs())
        } else this.frame = this._frame
        this.emit('update', this)
    }
    destroy(t) {
        if (this.baseTexture) {
            if (t) {
                const { resource: e } = this.baseTexture
                ;(e?.url && Ie[e.url] && j.removeFromCache(e.url),
                    this.baseTexture.destroy())
            }
            ;(this.baseTexture.off('loaded', this.onBaseTextureUpdated, this),
                this.baseTexture.off('update', this.onBaseTextureUpdated, this),
                (this.baseTexture = null))
        }
        ;((this._frame = null),
            (this._uvs = null),
            (this.trim = null),
            (this.orig = null),
            (this.valid = !1),
            j.removeFromCache(this),
            (this.textureCacheIds = null),
            (this.destroyed = !0),
            this.emit('destroyed', this),
            this.removeAllListeners())
    }
    clone() {
        const t = this._frame.clone(),
            e = this._frame === this.orig ? t : this.orig.clone(),
            i = new j(
                this.baseTexture,
                !this.noFrame && t,
                e,
                this.trim?.clone(),
                this.rotate,
                this.defaultAnchor,
                this.defaultBorders,
            )
        return (this.noFrame && (i._frame = t), i)
    }
    updateUvs() {
        ;(this._uvs === Ec && (this._uvs = new Xh()),
            this._uvs.set(this._frame, this.baseTexture, this.rotate),
            this._updateID++)
    }
    static from(t, e = {}, i = Y.STRICT_TEXTURE_CACHE) {
        const r = typeof t == 'string'
        let n = null
        if (r) n = t
        else if (t instanceof lt) {
            if (!t.cacheId) {
                const o = e?.pixiIdPrefix || 'pixiid'
                ;((t.cacheId = `${o}-${Zi()}`), lt.addToCache(t, t.cacheId))
            }
            n = t.cacheId
        } else {
            if (!t._pixiId) {
                const o = e?.pixiIdPrefix || 'pixiid'
                t._pixiId = `${o}_${Zi()}`
            }
            n = t._pixiId
        }
        let a = Ie[n]
        if (r && i && !a)
            throw new Error(
                `The cacheId "${n}" does not exist in TextureCache.`,
            )
        return (
            !a && !(t instanceof lt)
                ? (e.resolution || (e.resolution = ii(t)),
                  (a = new j(new lt(t, e))),
                  (a.baseTexture.cacheId = n),
                  lt.addToCache(a.baseTexture, n),
                  j.addToCache(a, n))
                : !a && t instanceof lt && ((a = new j(t)), j.addToCache(a, n)),
            a
        )
    }
    static fromURL(t, e) {
        const i = Object.assign({ autoLoad: !1 }, e?.resourceOptions),
            r = j.from(t, Object.assign({ resourceOptions: i }, e), !1),
            n = r.baseTexture.resource
        return r.baseTexture.valid
            ? Promise.resolve(r)
            : n.load().then(() => Promise.resolve(r))
    }
    static fromBuffer(t, e, i, r) {
        return new j(lt.fromBuffer(t, e, i, r))
    }
    static fromLoader(t, e, i, r) {
        const n = new lt(
                t,
                Object.assign(
                    {
                        scaleMode: lt.defaultOptions.scaleMode,
                        resolution: ii(e),
                    },
                    r,
                ),
            ),
            { resource: a } = n
        a instanceof zd && (a.url = e)
        const o = new j(n)
        return (
            i || (i = e),
            lt.addToCache(o.baseTexture, i),
            j.addToCache(o, i),
            i !== e && (lt.addToCache(o.baseTexture, e), j.addToCache(o, e)),
            o.baseTexture.valid
                ? Promise.resolve(o)
                : new Promise(h => {
                      o.baseTexture.once('loaded', () => h(o))
                  })
        )
    }
    static addToCache(t, e) {
        e &&
            (t.textureCacheIds.includes(e) || t.textureCacheIds.push(e),
            Ie[e] &&
                Ie[e] !== t &&
                console.warn(
                    `Texture added to the cache with an id [${e}] that already had an entry`,
                ),
            (Ie[e] = t))
    }
    static removeFromCache(t) {
        if (typeof t == 'string') {
            const e = Ie[t]
            if (e) {
                const i = e.textureCacheIds.indexOf(t)
                return (
                    i > -1 && e.textureCacheIds.splice(i, 1),
                    delete Ie[t],
                    e
                )
            }
        } else if (t?.textureCacheIds) {
            for (let e = 0; e < t.textureCacheIds.length; ++e)
                Ie[t.textureCacheIds[e]] === t &&
                    delete Ie[t.textureCacheIds[e]]
            return ((t.textureCacheIds.length = 0), t)
        }
        return null
    }
    get resolution() {
        return this.baseTexture.resolution
    }
    get frame() {
        return this._frame
    }
    set frame(t) {
        ;((this._frame = t), (this.noFrame = !1))
        const { x: e, y: i, width: r, height: n } = t,
            a = e + r > this.baseTexture.width,
            o = i + n > this.baseTexture.height
        if (a || o) {
            const h = a && o ? 'and' : 'or',
                l = `X: ${e} + ${r} = ${e + r} > ${this.baseTexture.width}`,
                u = `Y: ${i} + ${n} = ${i + n} > ${this.baseTexture.height}`
            throw new Error(
                `Texture Error: frame does not fit inside the base Texture dimensions: ${l} ${h} ${u}`,
            )
        }
        ;((this.valid = r && n && this.baseTexture.valid),
            !this.trim && !this.rotate && (this.orig = t),
            this.valid && this.updateUvs())
    }
    get rotate() {
        return this._rotate
    }
    set rotate(t) {
        ;((this._rotate = t), this.valid && this.updateUvs())
    }
    get width() {
        return this.orig.width
    }
    get height() {
        return this.orig.height
    }
    castToBaseTexture() {
        return this.baseTexture
    }
    static get EMPTY() {
        return (
            j._EMPTY ||
                ((j._EMPTY = new j(new lt())),
                ks(j._EMPTY),
                ks(j._EMPTY.baseTexture)),
            j._EMPTY
        )
    }
    static get WHITE() {
        if (!j._WHITE) {
            const t = Y.ADAPTER.createCanvas(16, 16),
                e = t.getContext('2d')
            ;((t.width = 16),
                (t.height = 16),
                (e.fillStyle = 'white'),
                e.fillRect(0, 0, 16, 16),
                (j._WHITE = new j(lt.from(t))),
                ks(j._WHITE),
                ks(j._WHITE.baseTexture))
        }
        return j._WHITE
    }
}
class er extends j {
    constructor(t, e) {
        ;(super(t, e),
            (this.valid = !0),
            (this.filterFrame = null),
            (this.filterPoolKey = null),
            this.updateUvs())
    }
    get framebuffer() {
        return this.baseTexture.framebuffer
    }
    get multisample() {
        return this.framebuffer.multisample
    }
    set multisample(t) {
        this.framebuffer.multisample = t
    }
    resize(t, e, i = !0) {
        const r = this.baseTexture.resolution,
            n = Math.round(t * r) / r,
            a = Math.round(e * r) / r
        ;((this.valid = n > 0 && a > 0),
            (this._frame.width = this.orig.width = n),
            (this._frame.height = this.orig.height = a),
            i && this.baseTexture.resize(n, a),
            this.updateUvs())
    }
    setResolution(t) {
        const { baseTexture: e } = this
        e.resolution !== t &&
            (e.setResolution(t), this.resize(e.width, e.height, !1))
    }
    static create(t) {
        return new er(new Hd(t))
    }
}
class Vd {
    constructor(t) {
        ;((this.texturePool = {}),
            (this.textureOptions = t || {}),
            (this.enableFullScreen = !1),
            (this._pixelsWidth = 0),
            (this._pixelsHeight = 0))
    }
    createTexture(t, e, i = Ft.NONE) {
        const r = new Hd(
            Object.assign(
                { width: t, height: e, resolution: 1, multisample: i },
                this.textureOptions,
            ),
        )
        return new er(r)
    }
    getOptimalTexture(t, e, i = 1, r = Ft.NONE) {
        let n
        ;((t = Math.max(Math.ceil(t * i - 1e-6), 1)),
            (e = Math.max(Math.ceil(e * i - 1e-6), 1)),
            !this.enableFullScreen ||
            t !== this._pixelsWidth ||
            e !== this._pixelsHeight
                ? ((t = dn(t)),
                  (e = dn(e)),
                  (n = (((t & 65535) << 16) | (e & 65535)) >>> 0),
                  r > 1 && (n += r * 4294967296))
                : (n = r > 1 ? -r : -1),
            this.texturePool[n] || (this.texturePool[n] = []))
        let a = this.texturePool[n].pop()
        return (
            a || (a = this.createTexture(t, e, r)),
            (a.filterPoolKey = n),
            a.setResolution(i),
            a
        )
    }
    getFilterTexture(t, e, i) {
        const r = this.getOptimalTexture(
            t.width,
            t.height,
            e || t.resolution,
            i || Ft.NONE,
        )
        return ((r.filterFrame = t.filterFrame), r)
    }
    returnTexture(t) {
        const e = t.filterPoolKey
        ;((t.filterFrame = null), this.texturePool[e].push(t))
    }
    returnFilterTexture(t) {
        this.returnTexture(t)
    }
    clear(t) {
        if (((t = t !== !1), t))
            for (const e in this.texturePool) {
                const i = this.texturePool[e]
                if (i) for (let r = 0; r < i.length; r++) i[r].destroy(!0)
            }
        this.texturePool = {}
    }
    setScreenSize(t) {
        if (
            !(t.width === this._pixelsWidth && t.height === this._pixelsHeight)
        ) {
            this.enableFullScreen = t.width > 0 && t.height > 0
            for (const e in this.texturePool) {
                if (!(Number(e) < 0)) continue
                const i = this.texturePool[e]
                if (i) for (let r = 0; r < i.length; r++) i[r].destroy(!0)
                this.texturePool[e] = []
            }
            ;((this._pixelsWidth = t.width), (this._pixelsHeight = t.height))
        }
    }
}
Vd.SCREEN_KEY = -1
class Jg extends Ti {
    constructor() {
        ;(super(),
            this.addAttribute(
                'aVertexPosition',
                new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
            ).addIndex([0, 1, 3, 2]))
    }
}
class Xd extends Ti {
    constructor() {
        ;(super(),
            (this.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1])),
            (this.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])),
            (this.vertexBuffer = new Bt(this.vertices)),
            (this.uvBuffer = new Bt(this.uvs)),
            this.addAttribute('aVertexPosition', this.vertexBuffer)
                .addAttribute('aTextureCoord', this.uvBuffer)
                .addIndex([0, 1, 2, 0, 2, 3]))
    }
    map(t, e) {
        let i = 0,
            r = 0
        return (
            (this.uvs[0] = i),
            (this.uvs[1] = r),
            (this.uvs[2] = i + e.width / t.width),
            (this.uvs[3] = r),
            (this.uvs[4] = i + e.width / t.width),
            (this.uvs[5] = r + e.height / t.height),
            (this.uvs[6] = i),
            (this.uvs[7] = r + e.height / t.height),
            (i = e.x),
            (r = e.y),
            (this.vertices[0] = i),
            (this.vertices[1] = r),
            (this.vertices[2] = i + e.width),
            (this.vertices[3] = r),
            (this.vertices[4] = i + e.width),
            (this.vertices[5] = r + e.height),
            (this.vertices[6] = i),
            (this.vertices[7] = r + e.height),
            this.invalidate(),
            this
        )
    }
    invalidate() {
        return (this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this)
    }
}
class t_ {
    constructor() {
        ;((this.renderTexture = null),
            (this.target = null),
            (this.legacy = !1),
            (this.resolution = 1),
            (this.multisample = Ft.NONE),
            (this.sourceFrame = new dt()),
            (this.destinationFrame = new dt()),
            (this.bindingSourceFrame = new dt()),
            (this.bindingDestinationFrame = new dt()),
            (this.filters = []),
            (this.transform = null))
    }
    clear() {
        ;((this.target = null),
            (this.filters = null),
            (this.renderTexture = null))
    }
}
const Ns = [new ut(), new ut(), new ut(), new ut()],
    fo = new Et()
class Wd {
    constructor(t) {
        ;((this.renderer = t),
            (this.defaultFilterStack = [{}]),
            (this.texturePool = new Vd()),
            (this.statePool = []),
            (this.quad = new Jg()),
            (this.quadUv = new Xd()),
            (this.tempRect = new dt()),
            (this.activeState = {}),
            (this.globalUniforms = new Se(
                {
                    outputFrame: new dt(),
                    inputSize: new Float32Array(4),
                    inputPixel: new Float32Array(4),
                    inputClamp: new Float32Array(4),
                    resolution: 1,
                    filterArea: new Float32Array(4),
                    filterClamp: new Float32Array(4),
                },
                !0,
            )),
            (this.forceClear = !1),
            (this.useMaxPadding = !1))
    }
    init() {
        this.texturePool.setScreenSize(this.renderer.view)
    }
    push(t, e) {
        const i = this.renderer,
            r = this.defaultFilterStack,
            n = this.statePool.pop() || new t_(),
            a = i.renderTexture
        let o, h
        if (a.current) {
            const g = a.current
            ;((o = g.resolution), (h = g.multisample))
        } else ((o = i.resolution), (h = i.multisample))
        let l = e[0].resolution || o,
            u = e[0].multisample ?? h,
            c = e[0].padding,
            d = e[0].autoFit,
            f = e[0].legacy ?? !0
        for (let g = 1; g < e.length; g++) {
            const _ = e[g]
            ;((l = Math.min(l, _.resolution || o)),
                (u = Math.min(u, _.multisample ?? h)),
                (c = this.useMaxPadding
                    ? Math.max(c, _.padding)
                    : c + _.padding),
                (d = d && _.autoFit),
                (f = f || (_.legacy ?? !0)))
        }
        ;(r.length === 1 &&
            (this.defaultFilterStack[0].renderTexture = a.current),
            r.push(n),
            (n.resolution = l),
            (n.multisample = u),
            (n.legacy = f),
            (n.target = t),
            n.sourceFrame.copyFrom(t.filterArea || t.getBounds(!0)),
            n.sourceFrame.pad(c))
        const m = this.tempRect.copyFrom(a.sourceFrame)
        ;(i.projection.transform &&
            this.transformAABB(fo.copyFrom(i.projection.transform).invert(), m),
            d
                ? (n.sourceFrame.fit(m),
                  (n.sourceFrame.width <= 0 || n.sourceFrame.height <= 0) &&
                      ((n.sourceFrame.width = 0), (n.sourceFrame.height = 0)))
                : n.sourceFrame.intersects(m) ||
                  ((n.sourceFrame.width = 0), (n.sourceFrame.height = 0)),
            this.roundFrame(
                n.sourceFrame,
                a.current ? a.current.resolution : i.resolution,
                a.sourceFrame,
                a.destinationFrame,
                i.projection.transform,
            ),
            (n.renderTexture = this.getOptimalFilterTexture(
                n.sourceFrame.width,
                n.sourceFrame.height,
                l,
                u,
            )),
            (n.filters = e),
            (n.destinationFrame.width = n.renderTexture.width),
            (n.destinationFrame.height = n.renderTexture.height))
        const p = this.tempRect
        ;((p.x = 0),
            (p.y = 0),
            (p.width = n.sourceFrame.width),
            (p.height = n.sourceFrame.height),
            (n.renderTexture.filterFrame = n.sourceFrame),
            n.bindingSourceFrame.copyFrom(a.sourceFrame),
            n.bindingDestinationFrame.copyFrom(a.destinationFrame),
            (n.transform = i.projection.transform),
            (i.projection.transform = null),
            a.bind(n.renderTexture, n.sourceFrame, p),
            i.framebuffer.clear(0, 0, 0, 0))
    }
    pop() {
        const t = this.defaultFilterStack,
            e = t.pop(),
            i = e.filters
        this.activeState = e
        const r = this.globalUniforms.uniforms
        ;((r.outputFrame = e.sourceFrame), (r.resolution = e.resolution))
        const n = r.inputSize,
            a = r.inputPixel,
            o = r.inputClamp
        if (
            ((n[0] = e.destinationFrame.width),
            (n[1] = e.destinationFrame.height),
            (n[2] = 1 / n[0]),
            (n[3] = 1 / n[1]),
            (a[0] = Math.round(n[0] * e.resolution)),
            (a[1] = Math.round(n[1] * e.resolution)),
            (a[2] = 1 / a[0]),
            (a[3] = 1 / a[1]),
            (o[0] = 0.5 * a[2]),
            (o[1] = 0.5 * a[3]),
            (o[2] = e.sourceFrame.width * n[2] - 0.5 * a[2]),
            (o[3] = e.sourceFrame.height * n[3] - 0.5 * a[3]),
            e.legacy)
        ) {
            const l = r.filterArea
            ;((l[0] = e.destinationFrame.width),
                (l[1] = e.destinationFrame.height),
                (l[2] = e.sourceFrame.x),
                (l[3] = e.sourceFrame.y),
                (r.filterClamp = r.inputClamp))
        }
        this.globalUniforms.update()
        const h = t[t.length - 1]
        if ((this.renderer.framebuffer.blit(), i.length === 1))
            (i[0].apply(this, e.renderTexture, h.renderTexture, Fe.BLEND, e),
                this.returnFilterTexture(e.renderTexture))
        else {
            let l = e.renderTexture,
                u = this.getOptimalFilterTexture(
                    l.width,
                    l.height,
                    e.resolution,
                )
            u.filterFrame = l.filterFrame
            let c = 0
            for (c = 0; c < i.length - 1; ++c) {
                ;(c === 1 &&
                    e.multisample > 1 &&
                    ((u = this.getOptimalFilterTexture(
                        l.width,
                        l.height,
                        e.resolution,
                    )),
                    (u.filterFrame = l.filterFrame)),
                    i[c].apply(this, l, u, Fe.CLEAR, e))
                const d = l
                ;((l = u), (u = d))
            }
            ;(i[c].apply(this, l, h.renderTexture, Fe.BLEND, e),
                c > 1 &&
                    e.multisample > 1 &&
                    this.returnFilterTexture(e.renderTexture),
                this.returnFilterTexture(l),
                this.returnFilterTexture(u))
        }
        ;(e.clear(), this.statePool.push(e))
    }
    bindAndClear(t, e = Fe.CLEAR) {
        const { renderTexture: i, state: r } = this.renderer
        if (
            (t ===
            this.defaultFilterStack[this.defaultFilterStack.length - 1]
                .renderTexture
                ? (this.renderer.projection.transform =
                      this.activeState.transform)
                : (this.renderer.projection.transform = null),
            t?.filterFrame)
        ) {
            const a = this.tempRect
            ;((a.x = 0),
                (a.y = 0),
                (a.width = t.filterFrame.width),
                (a.height = t.filterFrame.height),
                i.bind(t, t.filterFrame, a))
        } else
            t !==
            this.defaultFilterStack[this.defaultFilterStack.length - 1]
                .renderTexture
                ? i.bind(t)
                : this.renderer.renderTexture.bind(
                      t,
                      this.activeState.bindingSourceFrame,
                      this.activeState.bindingDestinationFrame,
                  )
        const n = r.stateId & 1 || this.forceClear
        ;(e === Fe.CLEAR || (e === Fe.BLIT && n)) &&
            this.renderer.framebuffer.clear(0, 0, 0, 0)
    }
    applyFilter(t, e, i, r) {
        const n = this.renderer
        ;(n.state.set(t.state),
            this.bindAndClear(i, r),
            (t.uniforms.uSampler = e),
            (t.uniforms.filterGlobals = this.globalUniforms),
            n.shader.bind(t),
            (t.legacy = !!t.program.attributeData.aTextureCoord),
            t.legacy
                ? (this.quadUv.map(e._frame, e.filterFrame),
                  n.geometry.bind(this.quadUv),
                  n.geometry.draw(Ue.TRIANGLES))
                : (n.geometry.bind(this.quad),
                  n.geometry.draw(Ue.TRIANGLE_STRIP)))
    }
    calculateSpriteMatrix(t, e) {
        const { sourceFrame: i, destinationFrame: r } = this.activeState,
            { orig: n } = e._texture,
            a = t.set(r.width, 0, 0, r.height, i.x, i.y),
            o = e.worldTransform.copyTo(Et.TEMP_MATRIX)
        return (
            o.invert(),
            a.prepend(o),
            a.scale(1 / n.width, 1 / n.height),
            a.translate(e.anchor.x, e.anchor.y),
            a
        )
    }
    destroy() {
        ;((this.renderer = null), this.texturePool.clear(!1))
    }
    getOptimalFilterTexture(t, e, i = 1, r = Ft.NONE) {
        return this.texturePool.getOptimalTexture(t, e, i, r)
    }
    getFilterTexture(t, e, i) {
        if (typeof t == 'number') {
            const n = t
            ;((t = e), (e = n))
        }
        t = t || this.activeState.renderTexture
        const r = this.texturePool.getOptimalTexture(
            t.width,
            t.height,
            e || t.resolution,
            i || Ft.NONE,
        )
        return ((r.filterFrame = t.filterFrame), r)
    }
    returnFilterTexture(t) {
        this.texturePool.returnTexture(t)
    }
    emptyPool() {
        this.texturePool.clear(!0)
    }
    resize() {
        this.texturePool.setScreenSize(this.renderer.view)
    }
    transformAABB(t, e) {
        const i = Ns[0],
            r = Ns[1],
            n = Ns[2],
            a = Ns[3]
        ;(i.set(e.left, e.top),
            r.set(e.left, e.bottom),
            n.set(e.right, e.top),
            a.set(e.right, e.bottom),
            t.apply(i, i),
            t.apply(r, r),
            t.apply(n, n),
            t.apply(a, a))
        const o = Math.min(i.x, r.x, n.x, a.x),
            h = Math.min(i.y, r.y, n.y, a.y),
            l = Math.max(i.x, r.x, n.x, a.x),
            u = Math.max(i.y, r.y, n.y, a.y)
        ;((e.x = o), (e.y = h), (e.width = l - o), (e.height = u - h))
    }
    roundFrame(t, e, i, r, n) {
        if (!(t.width <= 0 || t.height <= 0 || i.width <= 0 || i.height <= 0)) {
            if (n) {
                const { a, b: o, c: h, d: l } = n
                if (
                    (Math.abs(o) > 1e-4 || Math.abs(h) > 1e-4) &&
                    (Math.abs(a) > 1e-4 || Math.abs(l) > 1e-4)
                )
                    return
            }
            ;((n = n ? fo.copyFrom(n) : fo.identity()),
                n
                    .translate(-i.x, -i.y)
                    .scale(r.width / i.width, r.height / i.height)
                    .translate(r.x, r.y),
                this.transformAABB(n, t),
                t.ceil(e),
                this.transformAABB(n.invert(), t))
        }
    }
}
Wd.extension = { type: $.RendererSystem, name: 'filter' }
Q.add(Wd)
class e_ {
    constructor(t) {
        ;((this.framebuffer = t),
            (this.stencil = null),
            (this.dirtyId = -1),
            (this.dirtyFormat = -1),
            (this.dirtySize = -1),
            (this.multisample = Ft.NONE),
            (this.msaaBuffer = null),
            (this.blitFramebuffer = null),
            (this.mipLevel = 0))
    }
}
const i_ = new dt()
class $d {
    constructor(t) {
        ;((this.renderer = t),
            (this.managedFramebuffers = []),
            (this.unknownFramebuffer = new Qo(10, 10)),
            (this.msaaSamples = null))
    }
    contextChange() {
        this.disposeAll(!0)
        const t = (this.gl = this.renderer.gl)
        if (
            ((this.CONTEXT_UID = this.renderer.CONTEXT_UID),
            (this.current = this.unknownFramebuffer),
            (this.viewport = new dt()),
            (this.hasMRT = !0),
            (this.writeDepthTexture = !0),
            this.renderer.context.webGLVersion === 1)
        ) {
            let e = this.renderer.context.extensions.drawBuffers,
                i = this.renderer.context.extensions.depthTexture
            ;(Y.PREFER_ENV === tr.WEBGL_LEGACY && ((e = null), (i = null)),
                e
                    ? (t.drawBuffers = r => e.drawBuffersWEBGL(r))
                    : ((this.hasMRT = !1), (t.drawBuffers = () => {})),
                i || (this.writeDepthTexture = !1))
        } else
            this.msaaSamples = t.getInternalformatParameter(
                t.RENDERBUFFER,
                t.RGBA8,
                t.SAMPLES,
            )
    }
    bind(t, e, i = 0) {
        const { gl: r } = this
        if (t) {
            const n =
                t.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(t)
            ;(this.current !== t &&
                ((this.current = t),
                r.bindFramebuffer(r.FRAMEBUFFER, n.framebuffer)),
                n.mipLevel !== i &&
                    (t.dirtyId++, t.dirtyFormat++, (n.mipLevel = i)),
                n.dirtyId !== t.dirtyId &&
                    ((n.dirtyId = t.dirtyId),
                    n.dirtyFormat !== t.dirtyFormat
                        ? ((n.dirtyFormat = t.dirtyFormat),
                          (n.dirtySize = t.dirtySize),
                          this.updateFramebuffer(t, i))
                        : n.dirtySize !== t.dirtySize &&
                          ((n.dirtySize = t.dirtySize),
                          this.resizeFramebuffer(t))))
            for (let a = 0; a < t.colorTextures.length; a++) {
                const o = t.colorTextures[a]
                this.renderer.texture.unbind(o.parentTextureArray || o)
            }
            if (
                (t.depthTexture && this.renderer.texture.unbind(t.depthTexture),
                e)
            ) {
                const a = e.width >> i,
                    o = e.height >> i,
                    h = a / e.width
                this.setViewport(e.x * h, e.y * h, a, o)
            } else {
                const a = t.width >> i,
                    o = t.height >> i
                this.setViewport(0, 0, a, o)
            }
        } else
            (this.current &&
                ((this.current = null), r.bindFramebuffer(r.FRAMEBUFFER, null)),
                e
                    ? this.setViewport(e.x, e.y, e.width, e.height)
                    : this.setViewport(
                          0,
                          0,
                          this.renderer.width,
                          this.renderer.height,
                      ))
    }
    setViewport(t, e, i, r) {
        const n = this.viewport
        ;((t = Math.round(t)),
            (e = Math.round(e)),
            (i = Math.round(i)),
            (r = Math.round(r)),
            (n.width !== i || n.height !== r || n.x !== t || n.y !== e) &&
                ((n.x = t),
                (n.y = e),
                (n.width = i),
                (n.height = r),
                this.gl.viewport(t, e, i, r)))
    }
    get size() {
        return this.current
            ? {
                  x: 0,
                  y: 0,
                  width: this.current.width,
                  height: this.current.height,
              }
            : {
                  x: 0,
                  y: 0,
                  width: this.renderer.width,
                  height: this.renderer.height,
              }
    }
    clear(t, e, i, r, n = ko.COLOR | ko.DEPTH) {
        const { gl: a } = this
        ;(a.clearColor(t, e, i, r), a.clear(n))
    }
    initFramebuffer(t) {
        const { gl: e } = this,
            i = new e_(e.createFramebuffer())
        return (
            (i.multisample = this.detectSamples(t.multisample)),
            (t.glFramebuffers[this.CONTEXT_UID] = i),
            this.managedFramebuffers.push(t),
            t.disposeRunner.add(this),
            i
        )
    }
    resizeFramebuffer(t) {
        const { gl: e } = this,
            i = t.glFramebuffers[this.CONTEXT_UID]
        if (i.stencil) {
            e.bindRenderbuffer(e.RENDERBUFFER, i.stencil)
            let a
            ;(this.renderer.context.webGLVersion === 1
                ? (a = e.DEPTH_STENCIL)
                : t.depth && t.stencil
                  ? (a = e.DEPTH24_STENCIL8)
                  : t.depth
                    ? (a = e.DEPTH_COMPONENT24)
                    : (a = e.STENCIL_INDEX8),
                i.msaaBuffer
                    ? e.renderbufferStorageMultisample(
                          e.RENDERBUFFER,
                          i.multisample,
                          a,
                          t.width,
                          t.height,
                      )
                    : e.renderbufferStorage(
                          e.RENDERBUFFER,
                          a,
                          t.width,
                          t.height,
                      ))
        }
        const r = t.colorTextures
        let n = r.length
        e.drawBuffers || (n = Math.min(n, 1))
        for (let a = 0; a < n; a++) {
            const o = r[a],
                h = o.parentTextureArray || o
            ;(this.renderer.texture.bind(h, 0),
                a === 0 &&
                    i.msaaBuffer &&
                    (e.bindRenderbuffer(e.RENDERBUFFER, i.msaaBuffer),
                    e.renderbufferStorageMultisample(
                        e.RENDERBUFFER,
                        i.multisample,
                        h._glTextures[this.CONTEXT_UID].internalFormat,
                        t.width,
                        t.height,
                    )))
        }
        t.depthTexture &&
            this.writeDepthTexture &&
            this.renderer.texture.bind(t.depthTexture, 0)
    }
    updateFramebuffer(t, e) {
        const { gl: i } = this,
            r = t.glFramebuffers[this.CONTEXT_UID],
            n = t.colorTextures
        let a = n.length
        ;(i.drawBuffers || (a = Math.min(a, 1)),
            r.multisample > 1 && this.canMultisampleFramebuffer(t)
                ? (r.msaaBuffer = r.msaaBuffer || i.createRenderbuffer())
                : r.msaaBuffer &&
                  (i.deleteRenderbuffer(r.msaaBuffer),
                  (r.msaaBuffer = null),
                  r.blitFramebuffer &&
                      (r.blitFramebuffer.dispose(),
                      (r.blitFramebuffer = null))))
        const o = []
        for (let h = 0; h < a; h++) {
            const l = n[h],
                u = l.parentTextureArray || l
            ;(this.renderer.texture.bind(u, 0),
                h === 0 && r.msaaBuffer
                    ? (i.bindRenderbuffer(i.RENDERBUFFER, r.msaaBuffer),
                      i.renderbufferStorageMultisample(
                          i.RENDERBUFFER,
                          r.multisample,
                          u._glTextures[this.CONTEXT_UID].internalFormat,
                          t.width,
                          t.height,
                      ),
                      i.framebufferRenderbuffer(
                          i.FRAMEBUFFER,
                          i.COLOR_ATTACHMENT0,
                          i.RENDERBUFFER,
                          r.msaaBuffer,
                      ))
                    : (i.framebufferTexture2D(
                          i.FRAMEBUFFER,
                          i.COLOR_ATTACHMENT0 + h,
                          l.target,
                          u._glTextures[this.CONTEXT_UID].texture,
                          e,
                      ),
                      o.push(i.COLOR_ATTACHMENT0 + h)))
        }
        if (
            (o.length > 1 && i.drawBuffers(o),
            t.depthTexture && this.writeDepthTexture)
        ) {
            const h = t.depthTexture
            ;(this.renderer.texture.bind(h, 0),
                i.framebufferTexture2D(
                    i.FRAMEBUFFER,
                    i.DEPTH_ATTACHMENT,
                    i.TEXTURE_2D,
                    h._glTextures[this.CONTEXT_UID].texture,
                    e,
                ))
        }
        if (
            (t.stencil || t.depth) &&
            !(t.depthTexture && this.writeDepthTexture)
        ) {
            r.stencil = r.stencil || i.createRenderbuffer()
            let h, l
            ;(this.renderer.context.webGLVersion === 1
                ? ((h = i.DEPTH_STENCIL_ATTACHMENT), (l = i.DEPTH_STENCIL))
                : t.depth && t.stencil
                  ? ((h = i.DEPTH_STENCIL_ATTACHMENT), (l = i.DEPTH24_STENCIL8))
                  : t.depth
                    ? ((h = i.DEPTH_ATTACHMENT), (l = i.DEPTH_COMPONENT24))
                    : ((h = i.STENCIL_ATTACHMENT), (l = i.STENCIL_INDEX8)),
                i.bindRenderbuffer(i.RENDERBUFFER, r.stencil),
                r.msaaBuffer
                    ? i.renderbufferStorageMultisample(
                          i.RENDERBUFFER,
                          r.multisample,
                          l,
                          t.width,
                          t.height,
                      )
                    : i.renderbufferStorage(
                          i.RENDERBUFFER,
                          l,
                          t.width,
                          t.height,
                      ),
                i.framebufferRenderbuffer(
                    i.FRAMEBUFFER,
                    h,
                    i.RENDERBUFFER,
                    r.stencil,
                ))
        } else
            r.stencil && (i.deleteRenderbuffer(r.stencil), (r.stencil = null))
    }
    canMultisampleFramebuffer(t) {
        return (
            this.renderer.context.webGLVersion !== 1 &&
            t.colorTextures.length <= 1 &&
            !t.depthTexture
        )
    }
    detectSamples(t) {
        const { msaaSamples: e } = this
        let i = Ft.NONE
        if (t <= 1 || e === null) return i
        for (let r = 0; r < e.length; r++)
            if (e[r] <= t) {
                i = e[r]
                break
            }
        return (i === 1 && (i = Ft.NONE), i)
    }
    blit(t, e, i) {
        const { current: r, renderer: n, gl: a, CONTEXT_UID: o } = this
        if (n.context.webGLVersion !== 2 || !r) return
        const h = r.glFramebuffers[o]
        if (!h) return
        if (!t) {
            if (!h.msaaBuffer) return
            const u = r.colorTextures[0]
            if (!u) return
            ;(h.blitFramebuffer ||
                ((h.blitFramebuffer = new Qo(r.width, r.height)),
                h.blitFramebuffer.addColorTexture(0, u)),
                (t = h.blitFramebuffer),
                t.colorTextures[0] !== u &&
                    ((t.colorTextures[0] = u), t.dirtyId++, t.dirtyFormat++),
                (t.width !== r.width || t.height !== r.height) &&
                    ((t.width = r.width),
                    (t.height = r.height),
                    t.dirtyId++,
                    t.dirtySize++))
        }
        ;(e || ((e = i_), (e.width = r.width), (e.height = r.height)),
            i || (i = e))
        const l = e.width === i.width && e.height === i.height
        ;(this.bind(t),
            a.bindFramebuffer(a.READ_FRAMEBUFFER, h.framebuffer),
            a.blitFramebuffer(
                e.left,
                e.top,
                e.right,
                e.bottom,
                i.left,
                i.top,
                i.right,
                i.bottom,
                a.COLOR_BUFFER_BIT,
                l ? a.NEAREST : a.LINEAR,
            ),
            a.bindFramebuffer(
                a.READ_FRAMEBUFFER,
                t.glFramebuffers[this.CONTEXT_UID].framebuffer,
            ))
    }
    disposeFramebuffer(t, e) {
        const i = t.glFramebuffers[this.CONTEXT_UID],
            r = this.gl
        if (!i) return
        delete t.glFramebuffers[this.CONTEXT_UID]
        const n = this.managedFramebuffers.indexOf(t)
        ;(n >= 0 && this.managedFramebuffers.splice(n, 1),
            t.disposeRunner.remove(this),
            e ||
                (r.deleteFramebuffer(i.framebuffer),
                i.msaaBuffer && r.deleteRenderbuffer(i.msaaBuffer),
                i.stencil && r.deleteRenderbuffer(i.stencil)),
            i.blitFramebuffer && this.disposeFramebuffer(i.blitFramebuffer, e))
    }
    disposeAll(t) {
        const e = this.managedFramebuffers
        this.managedFramebuffers = []
        for (let i = 0; i < e.length; i++) this.disposeFramebuffer(e[i], t)
    }
    forceStencil() {
        const t = this.current
        if (!t) return
        const e = t.glFramebuffers[this.CONTEXT_UID]
        if (!e || (e.stencil && t.stencil)) return
        t.stencil = !0
        const i = t.width,
            r = t.height,
            n = this.gl,
            a = (e.stencil = n.createRenderbuffer())
        n.bindRenderbuffer(n.RENDERBUFFER, a)
        let o, h
        ;(this.renderer.context.webGLVersion === 1
            ? ((o = n.DEPTH_STENCIL_ATTACHMENT), (h = n.DEPTH_STENCIL))
            : t.depth
              ? ((o = n.DEPTH_STENCIL_ATTACHMENT), (h = n.DEPTH24_STENCIL8))
              : ((o = n.STENCIL_ATTACHMENT), (h = n.STENCIL_INDEX8)),
            e.msaaBuffer
                ? n.renderbufferStorageMultisample(
                      n.RENDERBUFFER,
                      e.multisample,
                      h,
                      i,
                      r,
                  )
                : n.renderbufferStorage(n.RENDERBUFFER, h, i, r),
            n.framebufferRenderbuffer(n.FRAMEBUFFER, o, n.RENDERBUFFER, a))
    }
    reset() {
        ;((this.current = this.unknownFramebuffer), (this.viewport = new dt()))
    }
    destroy() {
        this.renderer = null
    }
}
$d.extension = { type: $.RendererSystem, name: 'framebuffer' }
Q.add($d)
const po = { 5126: 4, 5123: 2, 5121: 1 }
class jd {
    constructor(t) {
        ;((this.renderer = t),
            (this._activeGeometry = null),
            (this._activeVao = null),
            (this.hasVao = !0),
            (this.hasInstance = !0),
            (this.canUseUInt32ElementIndex = !1),
            (this.managedGeometries = {}))
    }
    contextChange() {
        this.disposeAll(!0)
        const t = (this.gl = this.renderer.gl),
            e = this.renderer.context
        if (
            ((this.CONTEXT_UID = this.renderer.CONTEXT_UID),
            e.webGLVersion !== 2)
        ) {
            let i = this.renderer.context.extensions.vertexArrayObject
            ;(Y.PREFER_ENV === tr.WEBGL_LEGACY && (i = null),
                i
                    ? ((t.createVertexArray = () => i.createVertexArrayOES()),
                      (t.bindVertexArray = r => i.bindVertexArrayOES(r)),
                      (t.deleteVertexArray = r => i.deleteVertexArrayOES(r)))
                    : ((this.hasVao = !1),
                      (t.createVertexArray = () => null),
                      (t.bindVertexArray = () => null),
                      (t.deleteVertexArray = () => null)))
        }
        if (e.webGLVersion !== 2) {
            const i = t.getExtension('ANGLE_instanced_arrays')
            i
                ? ((t.vertexAttribDivisor = (r, n) =>
                      i.vertexAttribDivisorANGLE(r, n)),
                  (t.drawElementsInstanced = (r, n, a, o, h) =>
                      i.drawElementsInstancedANGLE(r, n, a, o, h)),
                  (t.drawArraysInstanced = (r, n, a, o) =>
                      i.drawArraysInstancedANGLE(r, n, a, o)))
                : (this.hasInstance = !1)
        }
        this.canUseUInt32ElementIndex =
            e.webGLVersion === 2 || !!e.extensions.uint32ElementIndex
    }
    bind(t, e) {
        e = e || this.renderer.shader.shader
        const { gl: i } = this
        let r = t.glVertexArrayObjects[this.CONTEXT_UID],
            n = !1
        r ||
            ((this.managedGeometries[t.id] = t),
            t.disposeRunner.add(this),
            (t.glVertexArrayObjects[this.CONTEXT_UID] = r = {}),
            (n = !0))
        const a = r[e.program.id] || this.initGeometryVao(t, e, n)
        ;((this._activeGeometry = t),
            this._activeVao !== a &&
                ((this._activeVao = a),
                this.hasVao
                    ? i.bindVertexArray(a)
                    : this.activateVao(t, e.program)),
            this.updateBuffers())
    }
    reset() {
        this.unbind()
    }
    updateBuffers() {
        const t = this._activeGeometry,
            e = this.renderer.buffer
        for (let i = 0; i < t.buffers.length; i++) {
            const r = t.buffers[i]
            e.update(r)
        }
    }
    checkCompatibility(t, e) {
        const i = t.attributes,
            r = e.attributeData
        for (const n in r)
            if (!i[n])
                throw new Error(
                    `shader and geometry incompatible, geometry missing the "${n}" attribute`,
                )
    }
    getSignature(t, e) {
        const i = t.attributes,
            r = e.attributeData,
            n = ['g', t.id]
        for (const a in i) r[a] && n.push(a, r[a].location)
        return n.join('-')
    }
    initGeometryVao(t, e, i = !0) {
        const r = this.gl,
            n = this.CONTEXT_UID,
            a = this.renderer.buffer,
            o = e.program
        ;(o.glPrograms[n] || this.renderer.shader.generateProgram(e),
            this.checkCompatibility(t, o))
        const h = this.getSignature(t, o),
            l = t.glVertexArrayObjects[this.CONTEXT_UID]
        let u = l[h]
        if (u) return ((l[o.id] = u), u)
        const c = t.buffers,
            d = t.attributes,
            f = {},
            m = {}
        for (const p in c) ((f[p] = 0), (m[p] = 0))
        for (const p in d)
            (!d[p].size && o.attributeData[p]
                ? (d[p].size = o.attributeData[p].size)
                : d[p].size ||
                  console.warn(
                      `PIXI Geometry attribute '${p}' size cannot be determined (likely the bound shader does not have the attribute)`,
                  ),
                (f[d[p].buffer] += d[p].size * po[d[p].type]))
        for (const p in d) {
            const g = d[p],
                _ = g.size
            ;(g.stride === void 0 &&
                (f[g.buffer] === _ * po[g.type]
                    ? (g.stride = 0)
                    : (g.stride = f[g.buffer])),
                g.start === void 0 &&
                    ((g.start = m[g.buffer]), (m[g.buffer] += _ * po[g.type])))
        }
        ;((u = r.createVertexArray()), r.bindVertexArray(u))
        for (let p = 0; p < c.length; p++) {
            const g = c[p]
            ;(a.bind(g), i && g._glBuffers[n].refCount++)
        }
        return (
            this.activateVao(t, o),
            (l[o.id] = u),
            (l[h] = u),
            r.bindVertexArray(null),
            a.unbind(ze.ARRAY_BUFFER),
            u
        )
    }
    disposeGeometry(t, e) {
        if (!this.managedGeometries[t.id]) return
        delete this.managedGeometries[t.id]
        const i = t.glVertexArrayObjects[this.CONTEXT_UID],
            r = this.gl,
            n = t.buffers,
            a = this.renderer?.buffer
        if ((t.disposeRunner.remove(this), !!i)) {
            if (a)
                for (let o = 0; o < n.length; o++) {
                    const h = n[o]._glBuffers[this.CONTEXT_UID]
                    h &&
                        (h.refCount--,
                        h.refCount === 0 && !e && a.dispose(n[o], e))
                }
            if (!e) {
                for (const o in i)
                    if (o[0] === 'g') {
                        const h = i[o]
                        ;(this._activeVao === h && this.unbind(),
                            r.deleteVertexArray(h))
                    }
            }
            delete t.glVertexArrayObjects[this.CONTEXT_UID]
        }
    }
    disposeAll(t) {
        const e = Object.keys(this.managedGeometries)
        for (let i = 0; i < e.length; i++)
            this.disposeGeometry(this.managedGeometries[e[i]], t)
    }
    activateVao(t, e) {
        const i = this.gl,
            r = this.CONTEXT_UID,
            n = this.renderer.buffer,
            a = t.buffers,
            o = t.attributes
        t.indexBuffer && n.bind(t.indexBuffer)
        let h = null
        for (const l in o) {
            const u = o[l],
                c = a[u.buffer],
                d = c._glBuffers[r]
            if (e.attributeData[l]) {
                h !== d && (n.bind(c), (h = d))
                const f = e.attributeData[l].location
                if (
                    (i.enableVertexAttribArray(f),
                    i.vertexAttribPointer(
                        f,
                        u.size,
                        u.type || i.FLOAT,
                        u.normalized,
                        u.stride,
                        u.start,
                    ),
                    u.instance)
                )
                    if (this.hasInstance) i.vertexAttribDivisor(f, u.divisor)
                    else
                        throw new Error(
                            'geometry error, GPU Instancing is not supported on this device',
                        )
            }
        }
    }
    draw(t, e, i, r) {
        const { gl: n } = this,
            a = this._activeGeometry
        if (a.indexBuffer) {
            const o = a.indexBuffer.data.BYTES_PER_ELEMENT,
                h = o === 2 ? n.UNSIGNED_SHORT : n.UNSIGNED_INT
            o === 2 || (o === 4 && this.canUseUInt32ElementIndex)
                ? a.instanced
                    ? n.drawElementsInstanced(
                          t,
                          e || a.indexBuffer.data.length,
                          h,
                          (i || 0) * o,
                          r || 1,
                      )
                    : n.drawElements(
                          t,
                          e || a.indexBuffer.data.length,
                          h,
                          (i || 0) * o,
                      )
                : console.warn('unsupported index buffer type: uint32')
        } else
            a.instanced
                ? n.drawArraysInstanced(t, i, e || a.getSize(), r || 1)
                : n.drawArrays(t, i, e || a.getSize())
        return this
    }
    unbind() {
        ;(this.gl.bindVertexArray(null),
            (this._activeVao = null),
            (this._activeGeometry = null))
    }
    destroy() {
        this.renderer = null
    }
}
jd.extension = { type: $.RendererSystem, name: 'geometry' }
Q.add(jd)
const Ac = new Et()
class qd {
    constructor(t, e) {
        ;((this._texture = t),
            (this.mapCoord = new Et()),
            (this.uClampFrame = new Float32Array(4)),
            (this.uClampOffset = new Float32Array(2)),
            (this._textureID = -1),
            (this._updateID = 0),
            (this.clampOffset = 0),
            (this.clampMargin = typeof e > 'u' ? 0.5 : e),
            (this.isSimple = !1))
    }
    get texture() {
        return this._texture
    }
    set texture(t) {
        ;((this._texture = t), (this._textureID = -1))
    }
    multiplyUvs(t, e) {
        e === void 0 && (e = t)
        const i = this.mapCoord
        for (let r = 0; r < t.length; r += 2) {
            const n = t[r],
                a = t[r + 1]
            ;((e[r] = n * i.a + a * i.c + i.tx),
                (e[r + 1] = n * i.b + a * i.d + i.ty))
        }
        return e
    }
    update(t) {
        const e = this._texture
        if (!e || !e.valid || (!t && this._textureID === e._updateID)) return !1
        ;((this._textureID = e._updateID), this._updateID++)
        const i = e._uvs
        this.mapCoord.set(
            i.x1 - i.x0,
            i.y1 - i.y0,
            i.x3 - i.x0,
            i.y3 - i.y0,
            i.x0,
            i.y0,
        )
        const r = e.orig,
            n = e.trim
        n &&
            (Ac.set(
                r.width / n.width,
                0,
                0,
                r.height / n.height,
                -n.x / n.width,
                -n.y / n.height,
            ),
            this.mapCoord.append(Ac))
        const a = e.baseTexture,
            o = this.uClampFrame,
            h = this.clampMargin / a.resolution,
            l = this.clampOffset
        return (
            (o[0] = (e._frame.x + h + l) / a.width),
            (o[1] = (e._frame.y + h + l) / a.height),
            (o[2] = (e._frame.x + e._frame.width - h + l) / a.width),
            (o[3] = (e._frame.y + e._frame.height - h + l) / a.height),
            (this.uClampOffset[0] = l / a.realWidth),
            (this.uClampOffset[1] = l / a.realHeight),
            (this.isSimple =
                e._frame.width === a.width &&
                e._frame.height === a.height &&
                e.rotate === 0),
            !0
        )
    }
}
var r_ = `varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform sampler2D mask;
uniform float alpha;
uniform float npmAlpha;
uniform vec4 maskClamp;

void main(void)
{
    float clip = step(3.5,
        step(maskClamp.x, vMaskCoord.x) +
        step(maskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, maskClamp.z) +
        step(vMaskCoord.y, maskClamp.w));

    vec4 original = texture2D(uSampler, vTextureCoord);
    vec4 masky = texture2D(mask, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    original *= (alphaMul * masky.r * alpha * clip);

    gl_FragColor = original;
}
`,
    s_ = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 otherMatrix;

varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;
}
`
class n_ extends qt {
    constructor(t, e, i) {
        let r = null
        ;(typeof t != 'string' &&
            e === void 0 &&
            i === void 0 &&
            ((r = t), (t = void 0), (e = void 0), (i = void 0)),
            super(t || s_, e || r_, i),
            (this.maskSprite = r),
            (this.maskMatrix = new Et()))
    }
    get maskSprite() {
        return this._maskSprite
    }
    set maskSprite(t) {
        ;((this._maskSprite = t),
            this._maskSprite && (this._maskSprite.renderable = !1))
    }
    apply(t, e, i, r) {
        const n = this._maskSprite,
            a = n._texture
        a.valid &&
            (a.uvMatrix || (a.uvMatrix = new qd(a, 0)),
            a.uvMatrix.update(),
            (this.uniforms.npmAlpha = a.baseTexture.alphaMode ? 0 : 1),
            (this.uniforms.mask = a),
            (this.uniforms.otherMatrix = t
                .calculateSpriteMatrix(this.maskMatrix, n)
                .prepend(a.uvMatrix.mapCoord)),
            (this.uniforms.alpha = n.worldAlpha),
            (this.uniforms.maskClamp = a.uvMatrix.uClampFrame),
            t.applyFilter(this, e, i, r))
    }
}
class a_ {
    constructor(t = null) {
        ;((this.type = Nt.NONE),
            (this.autoDetect = !0),
            (this.maskObject = t || null),
            (this.pooled = !1),
            (this.isMaskData = !0),
            (this.resolution = null),
            (this.multisample = qt.defaultMultisample),
            (this.enabled = !0),
            (this.colorMask = 15),
            (this._filters = null),
            (this._stencilCounter = 0),
            (this._scissorCounter = 0),
            (this._scissorRect = null),
            (this._scissorRectLocal = null),
            (this._colorMask = 15),
            (this._target = null))
    }
    get filter() {
        return this._filters ? this._filters[0] : null
    }
    set filter(t) {
        t
            ? this._filters
                ? (this._filters[0] = t)
                : (this._filters = [t])
            : (this._filters = null)
    }
    reset() {
        ;(this.pooled &&
            ((this.maskObject = null),
            (this.type = Nt.NONE),
            (this.autoDetect = !0)),
            (this._target = null),
            (this._scissorRectLocal = null))
    }
    copyCountersOrReset(t) {
        t
            ? ((this._stencilCounter = t._stencilCounter),
              (this._scissorCounter = t._scissorCounter),
              (this._scissorRect = t._scissorRect))
            : ((this._stencilCounter = 0),
              (this._scissorCounter = 0),
              (this._scissorRect = null))
    }
}
class Yd {
    constructor(t) {
        ;((this.renderer = t),
            (this.enableScissor = !0),
            (this.alphaMaskPool = []),
            (this.maskDataPool = []),
            (this.maskStack = []),
            (this.alphaMaskIndex = 0))
    }
    setMaskStack(t) {
        ;((this.maskStack = t),
            this.renderer.scissor.setMaskStack(t),
            this.renderer.stencil.setMaskStack(t))
    }
    push(t, e) {
        let i = e
        if (!i.isMaskData) {
            const n = this.maskDataPool.pop() || new a_()
            ;((n.pooled = !0), (n.maskObject = e), (i = n))
        }
        const r =
            this.maskStack.length !== 0
                ? this.maskStack[this.maskStack.length - 1]
                : null
        if (
            (i.copyCountersOrReset(r),
            (i._colorMask = r ? r._colorMask : 15),
            i.autoDetect && this.detect(i),
            (i._target = t),
            i.type !== Nt.SPRITE && this.maskStack.push(i),
            i.enabled)
        )
            switch (i.type) {
                case Nt.SCISSOR:
                    this.renderer.scissor.push(i)
                    break
                case Nt.STENCIL:
                    this.renderer.stencil.push(i)
                    break
                case Nt.SPRITE:
                    ;(i.copyCountersOrReset(null), this.pushSpriteMask(i))
                    break
                case Nt.COLOR:
                    this.pushColorMask(i)
                    break
            }
        i.type === Nt.SPRITE && this.maskStack.push(i)
    }
    pop(t) {
        const e = this.maskStack.pop()
        if (!(!e || e._target !== t)) {
            if (e.enabled)
                switch (e.type) {
                    case Nt.SCISSOR:
                        this.renderer.scissor.pop(e)
                        break
                    case Nt.STENCIL:
                        this.renderer.stencil.pop(e.maskObject)
                        break
                    case Nt.SPRITE:
                        this.popSpriteMask(e)
                        break
                    case Nt.COLOR:
                        this.popColorMask(e)
                        break
                }
            if (
                (e.reset(),
                e.pooled && this.maskDataPool.push(e),
                this.maskStack.length !== 0)
            ) {
                const i = this.maskStack[this.maskStack.length - 1]
                i.type === Nt.SPRITE &&
                    i._filters &&
                    (i._filters[0].maskSprite = i.maskObject)
            }
        }
    }
    detect(t) {
        const e = t.maskObject
        e
            ? e.isSprite
                ? (t.type = Nt.SPRITE)
                : this.enableScissor && this.renderer.scissor.testScissor(t)
                  ? (t.type = Nt.SCISSOR)
                  : (t.type = Nt.STENCIL)
            : (t.type = Nt.COLOR)
    }
    pushSpriteMask(t) {
        const { maskObject: e } = t,
            i = t._target
        let r = t._filters
        ;(r ||
            ((r = this.alphaMaskPool[this.alphaMaskIndex]),
            r || (r = this.alphaMaskPool[this.alphaMaskIndex] = [new n_()])),
            (r[0].resolution = t.resolution),
            (r[0].multisample = t.multisample),
            (r[0].maskSprite = e))
        const n = i.filterArea
        ;((i.filterArea = e.getBounds(!0)),
            this.renderer.filter.push(i, r),
            (i.filterArea = n),
            t._filters || this.alphaMaskIndex++)
    }
    popSpriteMask(t) {
        ;(this.renderer.filter.pop(),
            t._filters
                ? (t._filters[0].maskSprite = null)
                : (this.alphaMaskIndex--,
                  (this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite =
                      null)))
    }
    pushColorMask(t) {
        const e = t._colorMask,
            i = (t._colorMask = e & t.colorMask)
        i !== e &&
            this.renderer.gl.colorMask(
                (i & 1) !== 0,
                (i & 2) !== 0,
                (i & 4) !== 0,
                (i & 8) !== 0,
            )
    }
    popColorMask(t) {
        const e = t._colorMask,
            i =
                this.maskStack.length > 0
                    ? this.maskStack[this.maskStack.length - 1]._colorMask
                    : 15
        i !== e &&
            this.renderer.gl.colorMask(
                (i & 1) !== 0,
                (i & 2) !== 0,
                (i & 4) !== 0,
                (i & 8) !== 0,
            )
    }
    destroy() {
        this.renderer = null
    }
}
Yd.extension = { type: $.RendererSystem, name: 'mask' }
Q.add(Yd)
class Kd {
    constructor(t) {
        ;((this.renderer = t), (this.maskStack = []), (this.glConst = 0))
    }
    getStackLength() {
        return this.maskStack.length
    }
    setMaskStack(t) {
        const { gl: e } = this.renderer,
            i = this.getStackLength()
        this.maskStack = t
        const r = this.getStackLength()
        r !== i &&
            (r === 0
                ? e.disable(this.glConst)
                : (e.enable(this.glConst), this._useCurrent()))
    }
    _useCurrent() {}
    destroy() {
        ;((this.renderer = null), (this.maskStack = null))
    }
}
const Sc = new Et(),
    Cc = [],
    Zd = class tn extends Kd {
        constructor(t) {
            ;(super(t),
                (this.glConst =
                    Y.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST))
        }
        getStackLength() {
            const t = this.maskStack[this.maskStack.length - 1]
            return t ? t._scissorCounter : 0
        }
        calcScissorRect(t) {
            if (t._scissorRectLocal) return
            const e = t._scissorRect,
                { maskObject: i } = t,
                { renderer: r } = this,
                n = r.renderTexture,
                a = i.getBounds(!0, Cc.pop() ?? new dt())
            ;(this.roundFrameToPixels(
                a,
                n.current ? n.current.resolution : r.resolution,
                n.sourceFrame,
                n.destinationFrame,
                r.projection.transform,
            ),
                e && a.fit(e),
                (t._scissorRectLocal = a))
        }
        static isMatrixRotated(t) {
            if (!t) return !1
            const { a: e, b: i, c: r, d: n } = t
            return (
                (Math.abs(i) > 1e-4 || Math.abs(r) > 1e-4) &&
                (Math.abs(e) > 1e-4 || Math.abs(n) > 1e-4)
            )
        }
        testScissor(t) {
            const { maskObject: e } = t
            if (
                !e.isFastRect ||
                !e.isFastRect() ||
                tn.isMatrixRotated(e.worldTransform) ||
                tn.isMatrixRotated(this.renderer.projection.transform)
            )
                return !1
            this.calcScissorRect(t)
            const i = t._scissorRectLocal
            return i.width > 0 && i.height > 0
        }
        roundFrameToPixels(t, e, i, r, n) {
            tn.isMatrixRotated(n) ||
                ((n = n ? Sc.copyFrom(n) : Sc.identity()),
                n
                    .translate(-i.x, -i.y)
                    .scale(r.width / i.width, r.height / i.height)
                    .translate(r.x, r.y),
                this.renderer.filter.transformAABB(n, t),
                t.fit(r),
                (t.x = Math.round(t.x * e)),
                (t.y = Math.round(t.y * e)),
                (t.width = Math.round(t.width * e)),
                (t.height = Math.round(t.height * e)))
        }
        push(t) {
            t._scissorRectLocal || this.calcScissorRect(t)
            const { gl: e } = this.renderer
            ;(t._scissorRect || e.enable(e.SCISSOR_TEST),
                t._scissorCounter++,
                (t._scissorRect = t._scissorRectLocal),
                this._useCurrent())
        }
        pop(t) {
            const { gl: e } = this.renderer
            ;(t && Cc.push(t._scissorRectLocal),
                this.getStackLength() > 0
                    ? this._useCurrent()
                    : e.disable(e.SCISSOR_TEST))
        }
        _useCurrent() {
            const t = this.maskStack[this.maskStack.length - 1]._scissorRect
            let e
            ;(this.renderer.renderTexture.current
                ? (e = t.y)
                : (e = this.renderer.height - t.height - t.y),
                this.renderer.gl.scissor(t.x, e, t.width, t.height))
        }
    }
Zd.extension = { type: $.RendererSystem, name: 'scissor' }
let o_ = Zd
Q.add(o_)
class Qd extends Kd {
    constructor(t) {
        ;(super(t),
            (this.glConst = Y.ADAPTER.getWebGLRenderingContext().STENCIL_TEST))
    }
    getStackLength() {
        const t = this.maskStack[this.maskStack.length - 1]
        return t ? t._stencilCounter : 0
    }
    push(t) {
        const e = t.maskObject,
            { gl: i } = this.renderer,
            r = t._stencilCounter
        ;(r === 0 &&
            (this.renderer.framebuffer.forceStencil(),
            i.clearStencil(0),
            i.clear(i.STENCIL_BUFFER_BIT),
            i.enable(i.STENCIL_TEST)),
            t._stencilCounter++)
        const n = t._colorMask
        ;(n !== 0 && ((t._colorMask = 0), i.colorMask(!1, !1, !1, !1)),
            i.stencilFunc(i.EQUAL, r, 4294967295),
            i.stencilOp(i.KEEP, i.KEEP, i.INCR),
            (e.renderable = !0),
            e.render(this.renderer),
            this.renderer.batch.flush(),
            (e.renderable = !1),
            n !== 0 &&
                ((t._colorMask = n),
                i.colorMask(
                    (n & 1) !== 0,
                    (n & 2) !== 0,
                    (n & 4) !== 0,
                    (n & 8) !== 0,
                )),
            this._useCurrent())
    }
    pop(t) {
        const e = this.renderer.gl
        if (this.getStackLength() === 0) e.disable(e.STENCIL_TEST)
        else {
            const i =
                    this.maskStack.length !== 0
                        ? this.maskStack[this.maskStack.length - 1]
                        : null,
                r = i ? i._colorMask : 15
            ;(r !== 0 && ((i._colorMask = 0), e.colorMask(!1, !1, !1, !1)),
                e.stencilOp(e.KEEP, e.KEEP, e.DECR),
                (t.renderable = !0),
                t.render(this.renderer),
                this.renderer.batch.flush(),
                (t.renderable = !1),
                r !== 0 &&
                    ((i._colorMask = r),
                    e.colorMask(
                        (r & 1) !== 0,
                        (r & 2) !== 0,
                        (r & 4) !== 0,
                        (r & 8) !== 0,
                    )),
                this._useCurrent())
        }
    }
    _useCurrent() {
        const t = this.renderer.gl
        ;(t.stencilFunc(t.EQUAL, this.getStackLength(), 4294967295),
            t.stencilOp(t.KEEP, t.KEEP, t.KEEP))
    }
}
Qd.extension = { type: $.RendererSystem, name: 'stencil' }
Q.add(Qd)
class Jd {
    constructor(t) {
        ;((this.renderer = t),
            (this.plugins = {}),
            Object.defineProperties(this.plugins, {
                extract: {
                    enumerable: !1,
                    get() {
                        return (
                            ft(
                                '7.0.0',
                                'renderer.plugins.extract has moved to renderer.extract',
                            ),
                            t.extract
                        )
                    },
                },
                prepare: {
                    enumerable: !1,
                    get() {
                        return (
                            ft(
                                '7.0.0',
                                'renderer.plugins.prepare has moved to renderer.prepare',
                            ),
                            t.prepare
                        )
                    },
                },
                interaction: {
                    enumerable: !1,
                    get() {
                        return (
                            ft(
                                '7.0.0',
                                'renderer.plugins.interaction has been deprecated, use renderer.events',
                            ),
                            t.events
                        )
                    },
                },
            }))
    }
    init() {
        const t = this.rendererPlugins
        for (const e in t) this.plugins[e] = new t[e](this.renderer)
    }
    destroy() {
        for (const t in this.plugins)
            (this.plugins[t].destroy(), (this.plugins[t] = null))
    }
}
Jd.extension = {
    type: [$.RendererSystem, $.CanvasRendererSystem],
    name: '_plugin',
}
Q.add(Jd)
class tf {
    constructor(t) {
        ;((this.renderer = t),
            (this.destinationFrame = null),
            (this.sourceFrame = null),
            (this.defaultFrame = null),
            (this.projectionMatrix = new Et()),
            (this.transform = null))
    }
    update(t, e, i, r) {
        ;((this.destinationFrame =
            t || this.destinationFrame || this.defaultFrame),
            (this.sourceFrame = e || this.sourceFrame || t),
            this.calculateProjection(
                this.destinationFrame,
                this.sourceFrame,
                i,
                r,
            ),
            this.transform && this.projectionMatrix.append(this.transform))
        const n = this.renderer
        ;((n.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix),
            n.globalUniforms.update(),
            n.shader.shader &&
                n.shader.syncUniformGroup(n.shader.shader.uniforms.globals))
    }
    calculateProjection(t, e, i, r) {
        const n = this.projectionMatrix,
            a = r ? -1 : 1
        ;(n.identity(),
            (n.a = (1 / e.width) * 2),
            (n.d = a * ((1 / e.height) * 2)),
            (n.tx = -1 - e.x * n.a),
            (n.ty = -a - e.y * n.d))
    }
    setTransform(t) {}
    destroy() {
        this.renderer = null
    }
}
tf.extension = { type: $.RendererSystem, name: 'projection' }
Q.add(tf)
const h_ = new Vh(),
    Pc = new dt()
class ef {
    constructor(t) {
        ;((this.renderer = t), (this._tempMatrix = new Et()))
    }
    generateTexture(t, e) {
        const { region: i, ...r } = e || {},
            n = i?.copyTo(Pc) || t.getLocalBounds(Pc, !0),
            a = r.resolution || this.renderer.resolution
        ;((n.width = Math.max(n.width, 1 / a)),
            (n.height = Math.max(n.height, 1 / a)),
            (r.width = n.width),
            (r.height = n.height),
            (r.resolution = a),
            r.multisample ?? (r.multisample = this.renderer.multisample))
        const o = er.create(r)
        ;((this._tempMatrix.tx = -n.x), (this._tempMatrix.ty = -n.y))
        const h = t.transform
        return (
            (t.transform = h_),
            this.renderer.render(t, {
                renderTexture: o,
                transform: this._tempMatrix,
                skipUpdateTransform: !!t.parent,
                blit: !0,
            }),
            (t.transform = h),
            o
        )
    }
    destroy() {}
}
ef.extension = {
    type: [$.RendererSystem, $.CanvasRendererSystem],
    name: 'textureGenerator',
}
Q.add(ef)
const Ii = new dt(),
    $r = new dt()
class rf {
    constructor(t) {
        ;((this.renderer = t),
            (this.defaultMaskStack = []),
            (this.current = null),
            (this.sourceFrame = new dt()),
            (this.destinationFrame = new dt()),
            (this.viewportFrame = new dt()))
    }
    contextChange() {
        const t = this.renderer?.gl.getContextAttributes()
        this._rendererPremultipliedAlpha = !!(
            t &&
            t.alpha &&
            t.premultipliedAlpha
        )
    }
    bind(t = null, e, i) {
        const r = this.renderer
        this.current = t
        let n, a, o
        t
            ? ((n = t.baseTexture),
              (o = n.resolution),
              e ||
                  ((Ii.width = t.frame.width),
                  (Ii.height = t.frame.height),
                  (e = Ii)),
              i ||
                  (($r.x = t.frame.x),
                  ($r.y = t.frame.y),
                  ($r.width = e.width),
                  ($r.height = e.height),
                  (i = $r)),
              (a = n.framebuffer))
            : ((o = r.resolution),
              e ||
                  ((Ii.width = r._view.screen.width),
                  (Ii.height = r._view.screen.height),
                  (e = Ii)),
              i || ((i = Ii), (i.width = e.width), (i.height = e.height)))
        const h = this.viewportFrame
        ;((h.x = i.x * o),
            (h.y = i.y * o),
            (h.width = i.width * o),
            (h.height = i.height * o),
            t || (h.y = r.view.height - (h.y + h.height)),
            h.ceil(),
            this.renderer.framebuffer.bind(a, h),
            this.renderer.projection.update(i, e, o, !a),
            t
                ? this.renderer.mask.setMaskStack(n.maskStack)
                : this.renderer.mask.setMaskStack(this.defaultMaskStack),
            this.sourceFrame.copyFrom(e),
            this.destinationFrame.copyFrom(i))
    }
    clear(t, e) {
        const i = this.current
                ? this.current.baseTexture.clear
                : this.renderer.background.backgroundColor,
            r = Tt.shared.setValue(t || i)
        ;((this.current && this.current.baseTexture.alphaMode > 0) ||
            (!this.current && this._rendererPremultipliedAlpha)) &&
            r.premultiply(r.alpha)
        const n = this.destinationFrame,
            a = this.current
                ? this.current.baseTexture
                : this.renderer._view.screen,
            o = n.width !== a.width || n.height !== a.height
        if (o) {
            let { x: h, y: l, width: u, height: c } = this.viewportFrame
            ;((h = Math.round(h)),
                (l = Math.round(l)),
                (u = Math.round(u)),
                (c = Math.round(c)),
                this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST),
                this.renderer.gl.scissor(h, l, u, c))
        }
        ;(this.renderer.framebuffer.clear(r.red, r.green, r.blue, r.alpha, e),
            o && this.renderer.scissor.pop())
    }
    resize() {
        this.bind(null)
    }
    reset() {
        this.bind(null)
    }
    destroy() {
        this.renderer = null
    }
}
rf.extension = { type: $.RendererSystem, name: 'renderTexture' }
Q.add(rf)
class l_ {
    constructor(t, e) {
        ;((this.program = t),
            (this.uniformData = e),
            (this.uniformGroups = {}),
            (this.uniformDirtyGroups = {}),
            (this.uniformBufferBindings = {}))
    }
    destroy() {
        ;((this.uniformData = null),
            (this.uniformGroups = null),
            (this.uniformDirtyGroups = null),
            (this.uniformBufferBindings = null),
            (this.program = null))
    }
}
function u_(s, t) {
    const e = {},
        i = t.getProgramParameter(s, t.ACTIVE_ATTRIBUTES)
    for (let r = 0; r < i; r++) {
        const n = t.getActiveAttrib(s, r)
        if (n.name.startsWith('gl_')) continue
        const a = Ud(t, n.type),
            o = {
                type: a,
                name: n.name,
                size: Nd(a),
                location: t.getAttribLocation(s, n.name),
            }
        e[n.name] = o
    }
    return e
}
function c_(s, t) {
    const e = {},
        i = t.getProgramParameter(s, t.ACTIVE_UNIFORMS)
    for (let r = 0; r < i; r++) {
        const n = t.getActiveUniform(s, r),
            a = n.name.replace(/\[.*?\]$/, ''),
            o = !!n.name.match(/\[.*?\]$/),
            h = Ud(t, n.type)
        e[a] = {
            name: a,
            index: r,
            type: h,
            size: n.size,
            isArray: o,
            value: Ld(h, n.size),
        }
    }
    return e
}
function d_(s, t) {
    const e = vc(s, s.VERTEX_SHADER, t.vertexSrc),
        i = vc(s, s.FRAGMENT_SHADER, t.fragmentSrc),
        r = s.createProgram()
    ;(s.attachShader(r, e), s.attachShader(r, i))
    const n = t.extra?.transformFeedbackVaryings
    if (
        (n &&
            (typeof s.transformFeedbackVaryings != 'function'
                ? console.warn(
                      'TransformFeedback is not supported but TransformFeedbackVaryings are given.',
                  )
                : s.transformFeedbackVaryings(
                      r,
                      n.names,
                      n.bufferMode === 'separate'
                          ? s.SEPARATE_ATTRIBS
                          : s.INTERLEAVED_ATTRIBS,
                  )),
        s.linkProgram(r),
        s.getProgramParameter(r, s.LINK_STATUS) || Hg(s, r, e, i),
        (t.attributeData = u_(r, s)),
        (t.uniformData = c_(r, s)),
        !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(t.vertexSrc))
    ) {
        const o = Object.keys(t.attributeData)
        o.sort((h, l) => (h > l ? 1 : -1))
        for (let h = 0; h < o.length; h++)
            ((t.attributeData[o[h]].location = h),
                s.bindAttribLocation(r, h, o[h]))
        s.linkProgram(r)
    }
    ;(s.deleteShader(e), s.deleteShader(i))
    const a = {}
    for (const o in t.uniformData) {
        const h = t.uniformData[o]
        a[o] = {
            location: s.getUniformLocation(r, o),
            value: Ld(h.type, h.size),
        }
    }
    return new l_(r, a)
}
function f_(s, t, e, i, r) {
    e.buffer.update(r)
}
const p_ = {
        float: `
        data[offset] = v;
    `,
        vec2: `
        data[offset] = v[0];
        data[offset+1] = v[1];
    `,
        vec3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

    `,
        vec4: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];
        data[offset+3] = v[3];
    `,
        mat2: `
        data[offset] = v[0];
        data[offset+1] = v[1];

        data[offset+4] = v[2];
        data[offset+5] = v[3];
    `,
        mat3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];

        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];
    `,
        mat4: `
        for(var i = 0; i < 16; i++)
        {
            data[offset + i] = v[i];
        }
    `,
    },
    sf = {
        float: 4,
        vec2: 8,
        vec3: 12,
        vec4: 16,
        int: 4,
        ivec2: 8,
        ivec3: 12,
        ivec4: 16,
        uint: 4,
        uvec2: 8,
        uvec3: 12,
        uvec4: 16,
        bool: 4,
        bvec2: 8,
        bvec3: 12,
        bvec4: 16,
        mat2: 16 * 2,
        mat3: 16 * 3,
        mat4: 16 * 4,
    }
function m_(s) {
    const t = s.map(n => ({ data: n, offset: 0, dataLen: 0, dirty: 0 }))
    let e = 0,
        i = 0,
        r = 0
    for (let n = 0; n < t.length; n++) {
        const a = t[n]
        if (
            ((e = sf[a.data.type]),
            a.data.size > 1 && (e = Math.max(e, 16) * a.data.size),
            (a.dataLen = e),
            i % e !== 0 && i < 16)
        ) {
            const o = (i % e) % 16
            ;((i += o), (r += o))
        }
        i + e > 16
            ? ((r = Math.ceil(r / 16) * 16), (a.offset = r), (r += e), (i = e))
            : ((a.offset = r), (i += e), (r += e))
    }
    return ((r = Math.ceil(r / 16) * 16), { uboElements: t, size: r })
}
function g_(s, t) {
    const e = []
    for (const i in s) t[i] && e.push(t[i])
    return (e.sort((i, r) => i.index - r.index), e)
}
function __(s, t) {
    if (!s.autoManage) return { size: 0, syncFunc: f_ }
    const e = g_(s.uniforms, t),
        { uboElements: i, size: r } = m_(e),
        n = [
            `
    var v = null;
    var v2 = null;
    var cv = null;
    var t = 0;
    var gl = renderer.gl
    var index = 0;
    var data = buffer.data;
    `,
        ]
    for (let a = 0; a < i.length; a++) {
        const o = i[a],
            h = s.uniforms[o.data.name],
            l = o.data.name
        let u = !1
        for (let c = 0; c < Ar.length; c++) {
            const d = Ar[c]
            if (d.codeUbo && d.test(o.data, h)) {
                ;(n.push(
                    `offset = ${o.offset / 4};`,
                    Ar[c].codeUbo(o.data.name, h),
                ),
                    (u = !0))
                break
            }
        }
        if (!u)
            if (o.data.size > 1) {
                const c = Nd(o.data.type),
                    d = Math.max(sf[o.data.type] / 16, 1),
                    f = c / d,
                    m = (4 - (f % 4)) % 4
                n.push(`
                cv = ud.${l}.value;
                v = uv.${l};
                offset = ${o.offset / 4};

                t = 0;

                for(var i=0; i < ${o.data.size * d}; i++)
                {
                    for(var j = 0; j < ${f}; j++)
                    {
                        data[offset++] = v[t++];
                    }
                    offset += ${m};
                }

                `)
            } else {
                const c = p_[o.data.type]
                n.push(`
                cv = ud.${l}.value;
                v = uv.${l};
                offset = ${o.offset / 4};
                ${c};
                `)
            }
    }
    return (
        n.push(`
       renderer.buffer.update(buffer);
    `),
        {
            size: r,
            syncFunc: new Function(
                'ud',
                'uv',
                'renderer',
                'syncData',
                'buffer',
                n.join(`
`),
            ),
        }
    )
}
let y_ = 0
const Us = { textureCount: 0, uboCount: 0 }
class nf {
    constructor(t) {
        ;((this.destroyed = !1),
            (this.renderer = t),
            this.systemCheck(),
            (this.gl = null),
            (this.shader = null),
            (this.program = null),
            (this.cache = {}),
            (this._uboCache = {}),
            (this.id = y_++))
    }
    systemCheck() {
        if (!Vg())
            throw new Error(
                'Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.',
            )
    }
    contextChange(t) {
        ;((this.gl = t), this.reset())
    }
    bind(t, e) {
        ;(t.disposeRunner.add(this),
            (t.uniforms.globals = this.renderer.globalUniforms))
        const i = t.program,
            r =
                i.glPrograms[this.renderer.CONTEXT_UID] ||
                this.generateProgram(t)
        return (
            (this.shader = t),
            this.program !== i &&
                ((this.program = i), this.gl.useProgram(r.program)),
            e ||
                ((Us.textureCount = 0),
                (Us.uboCount = 0),
                this.syncUniformGroup(t.uniformGroup, Us)),
            r
        )
    }
    setUniforms(t) {
        const e = this.shader.program,
            i = e.glPrograms[this.renderer.CONTEXT_UID]
        e.syncUniforms(i.uniformData, t, this.renderer)
    }
    syncUniformGroup(t, e) {
        const i = this.getGlProgram()
        ;(!t.static || t.dirtyId !== i.uniformDirtyGroups[t.id]) &&
            ((i.uniformDirtyGroups[t.id] = t.dirtyId),
            this.syncUniforms(t, i, e))
    }
    syncUniforms(t, e, i) {
        ;(t.syncUniforms[this.shader.program.id] || this.createSyncGroups(t))(
            e.uniformData,
            t.uniforms,
            this.renderer,
            i,
        )
    }
    createSyncGroups(t) {
        const e = this.getSignature(t, this.shader.program.uniformData, 'u')
        return (
            this.cache[e] ||
                (this.cache[e] = Ng(t, this.shader.program.uniformData)),
            (t.syncUniforms[this.shader.program.id] = this.cache[e]),
            t.syncUniforms[this.shader.program.id]
        )
    }
    syncUniformBufferGroup(t, e) {
        const i = this.getGlProgram()
        if (!t.static || t.dirtyId !== 0 || !i.uniformGroups[t.id]) {
            t.dirtyId = 0
            const r =
                i.uniformGroups[t.id] || this.createSyncBufferGroup(t, i, e)
            ;(t.buffer.update(),
                r(i.uniformData, t.uniforms, this.renderer, Us, t.buffer))
        }
        this.renderer.buffer.bindBufferBase(
            t.buffer,
            i.uniformBufferBindings[e],
        )
    }
    createSyncBufferGroup(t, e, i) {
        const { gl: r } = this.renderer
        this.renderer.buffer.bind(t.buffer)
        const n = this.gl.getUniformBlockIndex(e.program, i)
        ;((e.uniformBufferBindings[i] = this.shader.uniformBindCount),
            r.uniformBlockBinding(e.program, n, this.shader.uniformBindCount),
            this.shader.uniformBindCount++)
        const a = this.getSignature(t, this.shader.program.uniformData, 'ubo')
        let o = this._uboCache[a]
        if (
            (o ||
                (o = this._uboCache[a] =
                    __(t, this.shader.program.uniformData)),
            t.autoManage)
        ) {
            const h = new Float32Array(o.size / 4)
            t.buffer.update(h)
        }
        return ((e.uniformGroups[t.id] = o.syncFunc), e.uniformGroups[t.id])
    }
    getSignature(t, e, i) {
        const r = t.uniforms,
            n = [`${i}-`]
        for (const a in r) (n.push(a), e[a] && n.push(e[a].type))
        return n.join('-')
    }
    getGlProgram() {
        return this.shader
            ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID]
            : null
    }
    generateProgram(t) {
        const e = this.gl,
            i = t.program,
            r = d_(e, i)
        return ((i.glPrograms[this.renderer.CONTEXT_UID] = r), r)
    }
    reset() {
        ;((this.program = null), (this.shader = null))
    }
    disposeShader(t) {
        this.shader === t && (this.shader = null)
    }
    destroy() {
        ;((this.renderer = null), (this.destroyed = !0))
    }
}
nf.extension = { type: $.RendererSystem, name: 'shader' }
Q.add(nf)
class _n {
    constructor(t) {
        this.renderer = t
    }
    run(t) {
        const { renderer: e } = this
        ;(e.runners.init.emit(e.options),
            t.hello &&
                console.log(
                    `PixiJS 7.4.3 - ${e.rendererLogId} - https://pixijs.com`,
                ),
            e.resize(e.screen.width, e.screen.height))
    }
    destroy() {}
}
;((_n.defaultOptions = { hello: !1 }),
    (_n.extension = {
        type: [$.RendererSystem, $.CanvasRendererSystem],
        name: 'startup',
    }))
Q.add(_n)
function v_(s, t = []) {
    return (
        (t[ot.NORMAL] = [s.ONE, s.ONE_MINUS_SRC_ALPHA]),
        (t[ot.ADD] = [s.ONE, s.ONE]),
        (t[ot.MULTIPLY] = [
            s.DST_COLOR,
            s.ONE_MINUS_SRC_ALPHA,
            s.ONE,
            s.ONE_MINUS_SRC_ALPHA,
        ]),
        (t[ot.SCREEN] = [
            s.ONE,
            s.ONE_MINUS_SRC_COLOR,
            s.ONE,
            s.ONE_MINUS_SRC_ALPHA,
        ]),
        (t[ot.OVERLAY] = [s.ONE, s.ONE_MINUS_SRC_ALPHA]),
        (t[ot.DARKEN] = [s.ONE, s.ONE_MINUS_SRC_ALPHA]),
        (t[ot.LIGHTEN] = [s.ONE, s.ONE_MINUS_SRC_ALPHA]),
        (t[ot.COLOR_DODGE] = [s.ONE, s.ONE_MINUS_SRC_ALPHA]),
        (t[ot.COLOR_BURN] = [s.ONE, s.ONE_MINUS_SRC_ALPHA]),
        (t[ot.HARD_LIGHT] = [s.ONE, s.ONE_MINUS_SRC_ALPHA]),
        (t[ot.SOFT_LIGHT] = [s.ONE, s.ONE_MINUS_SRC_ALPHA]),
        (t[ot.DIFFERENCE] = [s.ONE, s.ONE_MINUS_SRC_ALPHA]),
        (t[ot.EXCLUSION] = [s.ONE, s.ONE_MINUS_SRC_ALPHA]),
        (t[ot.HUE] = [s.ONE, s.ONE_MINUS_SRC_ALPHA]),
        (t[ot.SATURATION] = [s.ONE, s.ONE_MINUS_SRC_ALPHA]),
        (t[ot.COLOR] = [s.ONE, s.ONE_MINUS_SRC_ALPHA]),
        (t[ot.LUMINOSITY] = [s.ONE, s.ONE_MINUS_SRC_ALPHA]),
        (t[ot.NONE] = [0, 0]),
        (t[ot.NORMAL_NPM] = [
            s.SRC_ALPHA,
            s.ONE_MINUS_SRC_ALPHA,
            s.ONE,
            s.ONE_MINUS_SRC_ALPHA,
        ]),
        (t[ot.ADD_NPM] = [s.SRC_ALPHA, s.ONE, s.ONE, s.ONE]),
        (t[ot.SCREEN_NPM] = [
            s.SRC_ALPHA,
            s.ONE_MINUS_SRC_COLOR,
            s.ONE,
            s.ONE_MINUS_SRC_ALPHA,
        ]),
        (t[ot.SRC_IN] = [s.DST_ALPHA, s.ZERO]),
        (t[ot.SRC_OUT] = [s.ONE_MINUS_DST_ALPHA, s.ZERO]),
        (t[ot.SRC_ATOP] = [s.DST_ALPHA, s.ONE_MINUS_SRC_ALPHA]),
        (t[ot.DST_OVER] = [s.ONE_MINUS_DST_ALPHA, s.ONE]),
        (t[ot.DST_IN] = [s.ZERO, s.SRC_ALPHA]),
        (t[ot.DST_OUT] = [s.ZERO, s.ONE_MINUS_SRC_ALPHA]),
        (t[ot.DST_ATOP] = [s.ONE_MINUS_DST_ALPHA, s.SRC_ALPHA]),
        (t[ot.XOR] = [s.ONE_MINUS_DST_ALPHA, s.ONE_MINUS_SRC_ALPHA]),
        (t[ot.SUBTRACT] = [
            s.ONE,
            s.ONE,
            s.ONE,
            s.ONE,
            s.FUNC_REVERSE_SUBTRACT,
            s.FUNC_ADD,
        ]),
        t
    )
}
const x_ = 0,
    b_ = 1,
    w_ = 2,
    T_ = 3,
    E_ = 4,
    A_ = 5,
    af = class Jo {
        constructor() {
            ;((this.gl = null),
                (this.stateId = 0),
                (this.polygonOffset = 0),
                (this.blendMode = ot.NONE),
                (this._blendEq = !1),
                (this.map = []),
                (this.map[x_] = this.setBlend),
                (this.map[b_] = this.setOffset),
                (this.map[w_] = this.setCullFace),
                (this.map[T_] = this.setDepthTest),
                (this.map[E_] = this.setFrontFace),
                (this.map[A_] = this.setDepthMask),
                (this.checks = []),
                (this.defaultState = new $e()),
                (this.defaultState.blend = !0))
        }
        contextChange(t) {
            ;((this.gl = t),
                (this.blendModes = v_(t)),
                this.set(this.defaultState),
                this.reset())
        }
        set(t) {
            if (((t = t || this.defaultState), this.stateId !== t.data)) {
                let e = this.stateId ^ t.data,
                    i = 0
                for (; e; )
                    (e & 1 && this.map[i].call(this, !!(t.data & (1 << i))),
                        (e = e >> 1),
                        i++)
                this.stateId = t.data
            }
            for (let e = 0; e < this.checks.length; e++) this.checks[e](this, t)
        }
        forceState(t) {
            t = t || this.defaultState
            for (let e = 0; e < this.map.length; e++)
                this.map[e].call(this, !!(t.data & (1 << e)))
            for (let e = 0; e < this.checks.length; e++) this.checks[e](this, t)
            this.stateId = t.data
        }
        setBlend(t) {
            ;(this.updateCheck(Jo.checkBlendMode, t),
                this.gl[t ? 'enable' : 'disable'](this.gl.BLEND))
        }
        setOffset(t) {
            ;(this.updateCheck(Jo.checkPolygonOffset, t),
                this.gl[t ? 'enable' : 'disable'](this.gl.POLYGON_OFFSET_FILL))
        }
        setDepthTest(t) {
            this.gl[t ? 'enable' : 'disable'](this.gl.DEPTH_TEST)
        }
        setDepthMask(t) {
            this.gl.depthMask(t)
        }
        setCullFace(t) {
            this.gl[t ? 'enable' : 'disable'](this.gl.CULL_FACE)
        }
        setFrontFace(t) {
            this.gl.frontFace(this.gl[t ? 'CW' : 'CCW'])
        }
        setBlendMode(t) {
            if (t === this.blendMode) return
            this.blendMode = t
            const e = this.blendModes[t],
                i = this.gl
            ;(e.length === 2
                ? i.blendFunc(e[0], e[1])
                : i.blendFuncSeparate(e[0], e[1], e[2], e[3]),
                e.length === 6
                    ? ((this._blendEq = !0),
                      i.blendEquationSeparate(e[4], e[5]))
                    : this._blendEq &&
                      ((this._blendEq = !1),
                      i.blendEquationSeparate(i.FUNC_ADD, i.FUNC_ADD)))
        }
        setPolygonOffset(t, e) {
            this.gl.polygonOffset(t, e)
        }
        reset() {
            ;(this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1),
                this.forceState(this.defaultState),
                (this._blendEq = !0),
                (this.blendMode = -1),
                this.setBlendMode(0))
        }
        updateCheck(t, e) {
            const i = this.checks.indexOf(t)
            e && i === -1
                ? this.checks.push(t)
                : !e && i !== -1 && this.checks.splice(i, 1)
        }
        static checkBlendMode(t, e) {
            t.setBlendMode(e.blendMode)
        }
        static checkPolygonOffset(t, e) {
            t.setPolygonOffset(1, e.polygonOffset)
        }
        destroy() {
            this.gl = null
        }
    }
af.extension = { type: $.RendererSystem, name: 'state' }
let S_ = af
Q.add(S_)
class C_ extends vs {
    constructor() {
        ;(super(...arguments), (this.runners = {}), (this._systemsHash = {}))
    }
    setup(t) {
        this.addRunners(...t.runners)
        const e = (t.priority ?? []).filter(r => t.systems[r]),
            i = [...e, ...Object.keys(t.systems).filter(r => !e.includes(r))]
        for (const r of i) this.addSystem(t.systems[r], r)
    }
    addRunners(...t) {
        t.forEach(e => {
            this.runners[e] = new Ae(e)
        })
    }
    addSystem(t, e) {
        const i = new t(this)
        if (this[e])
            throw new Error(`Whoops! The name "${e}" is already in use`)
        ;((this[e] = i), (this._systemsHash[e] = i))
        for (const r in this.runners) this.runners[r].add(i)
        return this
    }
    emitWithCustomOptions(t, e) {
        const i = Object.keys(this._systemsHash)
        t.items.forEach(r => {
            const n = i.find(a => this._systemsHash[a] === r)
            r[t.name](e[n])
        })
    }
    destroy() {
        ;(Object.values(this.runners).forEach(t => {
            t.destroy()
        }),
            (this._systemsHash = {}))
    }
}
const Qr = class en {
    constructor(t) {
        ;((this.renderer = t),
            (this.count = 0),
            (this.checkCount = 0),
            (this.maxIdle = en.defaultMaxIdle),
            (this.checkCountMax = en.defaultCheckCountMax),
            (this.mode = en.defaultMode))
    }
    postrender() {
        this.renderer.objectRenderer.renderingToScreen &&
            (this.count++,
            this.mode !== Uh.MANUAL &&
                (this.checkCount++,
                this.checkCount > this.checkCountMax &&
                    ((this.checkCount = 0), this.run())))
    }
    run() {
        const t = this.renderer.texture,
            e = t.managedTextures
        let i = !1
        for (let r = 0; r < e.length; r++) {
            const n = e[r]
            n.resource &&
                this.count - n.touched > this.maxIdle &&
                (t.destroyTexture(n, !0), (e[r] = null), (i = !0))
        }
        if (i) {
            let r = 0
            for (let n = 0; n < e.length; n++) e[n] !== null && (e[r++] = e[n])
            e.length = r
        }
    }
    unload(t) {
        const e = this.renderer.texture,
            i = t._texture
        i && !i.framebuffer && e.destroyTexture(i)
        for (let r = t.children.length - 1; r >= 0; r--)
            this.unload(t.children[r])
    }
    destroy() {
        this.renderer = null
    }
}
;((Qr.defaultMode = Uh.AUTO),
    (Qr.defaultMaxIdle = 60 * 60),
    (Qr.defaultCheckCountMax = 60 * 10),
    (Qr.extension = { type: $.RendererSystem, name: 'textureGC' }))
let Gi = Qr
Q.add(Gi)
class mo {
    constructor(t) {
        ;((this.texture = t),
            (this.width = -1),
            (this.height = -1),
            (this.dirtyId = -1),
            (this.dirtyStyleId = -1),
            (this.mipmap = !1),
            (this.wrapMode = 33071),
            (this.type = at.UNSIGNED_BYTE),
            (this.internalFormat = X.RGBA),
            (this.samplerType = 0))
    }
}
function P_(s) {
    let t
    return (
        'WebGL2RenderingContext' in globalThis &&
        s instanceof globalThis.WebGL2RenderingContext
            ? (t = {
                  [s.RGB]: q.FLOAT,
                  [s.RGBA]: q.FLOAT,
                  [s.ALPHA]: q.FLOAT,
                  [s.LUMINANCE]: q.FLOAT,
                  [s.LUMINANCE_ALPHA]: q.FLOAT,
                  [s.R8]: q.FLOAT,
                  [s.R8_SNORM]: q.FLOAT,
                  [s.RG8]: q.FLOAT,
                  [s.RG8_SNORM]: q.FLOAT,
                  [s.RGB8]: q.FLOAT,
                  [s.RGB8_SNORM]: q.FLOAT,
                  [s.RGB565]: q.FLOAT,
                  [s.RGBA4]: q.FLOAT,
                  [s.RGB5_A1]: q.FLOAT,
                  [s.RGBA8]: q.FLOAT,
                  [s.RGBA8_SNORM]: q.FLOAT,
                  [s.RGB10_A2]: q.FLOAT,
                  [s.RGB10_A2UI]: q.FLOAT,
                  [s.SRGB8]: q.FLOAT,
                  [s.SRGB8_ALPHA8]: q.FLOAT,
                  [s.R16F]: q.FLOAT,
                  [s.RG16F]: q.FLOAT,
                  [s.RGB16F]: q.FLOAT,
                  [s.RGBA16F]: q.FLOAT,
                  [s.R32F]: q.FLOAT,
                  [s.RG32F]: q.FLOAT,
                  [s.RGB32F]: q.FLOAT,
                  [s.RGBA32F]: q.FLOAT,
                  [s.R11F_G11F_B10F]: q.FLOAT,
                  [s.RGB9_E5]: q.FLOAT,
                  [s.R8I]: q.INT,
                  [s.R8UI]: q.UINT,
                  [s.R16I]: q.INT,
                  [s.R16UI]: q.UINT,
                  [s.R32I]: q.INT,
                  [s.R32UI]: q.UINT,
                  [s.RG8I]: q.INT,
                  [s.RG8UI]: q.UINT,
                  [s.RG16I]: q.INT,
                  [s.RG16UI]: q.UINT,
                  [s.RG32I]: q.INT,
                  [s.RG32UI]: q.UINT,
                  [s.RGB8I]: q.INT,
                  [s.RGB8UI]: q.UINT,
                  [s.RGB16I]: q.INT,
                  [s.RGB16UI]: q.UINT,
                  [s.RGB32I]: q.INT,
                  [s.RGB32UI]: q.UINT,
                  [s.RGBA8I]: q.INT,
                  [s.RGBA8UI]: q.UINT,
                  [s.RGBA16I]: q.INT,
                  [s.RGBA16UI]: q.UINT,
                  [s.RGBA32I]: q.INT,
                  [s.RGBA32UI]: q.UINT,
                  [s.DEPTH_COMPONENT16]: q.FLOAT,
                  [s.DEPTH_COMPONENT24]: q.FLOAT,
                  [s.DEPTH_COMPONENT32F]: q.FLOAT,
                  [s.DEPTH_STENCIL]: q.FLOAT,
                  [s.DEPTH24_STENCIL8]: q.FLOAT,
                  [s.DEPTH32F_STENCIL8]: q.FLOAT,
              })
            : (t = {
                  [s.RGB]: q.FLOAT,
                  [s.RGBA]: q.FLOAT,
                  [s.ALPHA]: q.FLOAT,
                  [s.LUMINANCE]: q.FLOAT,
                  [s.LUMINANCE_ALPHA]: q.FLOAT,
                  [s.DEPTH_STENCIL]: q.FLOAT,
              }),
        t
    )
}
function R_(s) {
    let t
    return (
        'WebGL2RenderingContext' in globalThis &&
        s instanceof globalThis.WebGL2RenderingContext
            ? (t = {
                  [at.UNSIGNED_BYTE]: {
                      [X.RGBA]: s.RGBA8,
                      [X.RGB]: s.RGB8,
                      [X.RG]: s.RG8,
                      [X.RED]: s.R8,
                      [X.RGBA_INTEGER]: s.RGBA8UI,
                      [X.RGB_INTEGER]: s.RGB8UI,
                      [X.RG_INTEGER]: s.RG8UI,
                      [X.RED_INTEGER]: s.R8UI,
                      [X.ALPHA]: s.ALPHA,
                      [X.LUMINANCE]: s.LUMINANCE,
                      [X.LUMINANCE_ALPHA]: s.LUMINANCE_ALPHA,
                  },
                  [at.BYTE]: {
                      [X.RGBA]: s.RGBA8_SNORM,
                      [X.RGB]: s.RGB8_SNORM,
                      [X.RG]: s.RG8_SNORM,
                      [X.RED]: s.R8_SNORM,
                      [X.RGBA_INTEGER]: s.RGBA8I,
                      [X.RGB_INTEGER]: s.RGB8I,
                      [X.RG_INTEGER]: s.RG8I,
                      [X.RED_INTEGER]: s.R8I,
                  },
                  [at.UNSIGNED_SHORT]: {
                      [X.RGBA_INTEGER]: s.RGBA16UI,
                      [X.RGB_INTEGER]: s.RGB16UI,
                      [X.RG_INTEGER]: s.RG16UI,
                      [X.RED_INTEGER]: s.R16UI,
                      [X.DEPTH_COMPONENT]: s.DEPTH_COMPONENT16,
                  },
                  [at.SHORT]: {
                      [X.RGBA_INTEGER]: s.RGBA16I,
                      [X.RGB_INTEGER]: s.RGB16I,
                      [X.RG_INTEGER]: s.RG16I,
                      [X.RED_INTEGER]: s.R16I,
                  },
                  [at.UNSIGNED_INT]: {
                      [X.RGBA_INTEGER]: s.RGBA32UI,
                      [X.RGB_INTEGER]: s.RGB32UI,
                      [X.RG_INTEGER]: s.RG32UI,
                      [X.RED_INTEGER]: s.R32UI,
                      [X.DEPTH_COMPONENT]: s.DEPTH_COMPONENT24,
                  },
                  [at.INT]: {
                      [X.RGBA_INTEGER]: s.RGBA32I,
                      [X.RGB_INTEGER]: s.RGB32I,
                      [X.RG_INTEGER]: s.RG32I,
                      [X.RED_INTEGER]: s.R32I,
                  },
                  [at.FLOAT]: {
                      [X.RGBA]: s.RGBA32F,
                      [X.RGB]: s.RGB32F,
                      [X.RG]: s.RG32F,
                      [X.RED]: s.R32F,
                      [X.DEPTH_COMPONENT]: s.DEPTH_COMPONENT32F,
                  },
                  [at.HALF_FLOAT]: {
                      [X.RGBA]: s.RGBA16F,
                      [X.RGB]: s.RGB16F,
                      [X.RG]: s.RG16F,
                      [X.RED]: s.R16F,
                  },
                  [at.UNSIGNED_SHORT_5_6_5]: { [X.RGB]: s.RGB565 },
                  [at.UNSIGNED_SHORT_4_4_4_4]: { [X.RGBA]: s.RGBA4 },
                  [at.UNSIGNED_SHORT_5_5_5_1]: { [X.RGBA]: s.RGB5_A1 },
                  [at.UNSIGNED_INT_2_10_10_10_REV]: {
                      [X.RGBA]: s.RGB10_A2,
                      [X.RGBA_INTEGER]: s.RGB10_A2UI,
                  },
                  [at.UNSIGNED_INT_10F_11F_11F_REV]: {
                      [X.RGB]: s.R11F_G11F_B10F,
                  },
                  [at.UNSIGNED_INT_5_9_9_9_REV]: { [X.RGB]: s.RGB9_E5 },
                  [at.UNSIGNED_INT_24_8]: {
                      [X.DEPTH_STENCIL]: s.DEPTH24_STENCIL8,
                  },
                  [at.FLOAT_32_UNSIGNED_INT_24_8_REV]: {
                      [X.DEPTH_STENCIL]: s.DEPTH32F_STENCIL8,
                  },
              })
            : (t = {
                  [at.UNSIGNED_BYTE]: {
                      [X.RGBA]: s.RGBA,
                      [X.RGB]: s.RGB,
                      [X.ALPHA]: s.ALPHA,
                      [X.LUMINANCE]: s.LUMINANCE,
                      [X.LUMINANCE_ALPHA]: s.LUMINANCE_ALPHA,
                  },
                  [at.UNSIGNED_SHORT_5_6_5]: { [X.RGB]: s.RGB },
                  [at.UNSIGNED_SHORT_4_4_4_4]: { [X.RGBA]: s.RGBA },
                  [at.UNSIGNED_SHORT_5_5_5_1]: { [X.RGBA]: s.RGBA },
              }),
        t
    )
}
class of {
    constructor(t) {
        ;((this.renderer = t),
            (this.boundTextures = []),
            (this.currentLocation = -1),
            (this.managedTextures = []),
            (this._unknownBoundTextures = !1),
            (this.unknownTexture = new lt()),
            (this.hasIntegerTextures = !1))
    }
    contextChange() {
        const t = (this.gl = this.renderer.gl)
        ;((this.CONTEXT_UID = this.renderer.CONTEXT_UID),
            (this.webGLVersion = this.renderer.context.webGLVersion),
            (this.internalFormats = R_(t)),
            (this.samplerTypes = P_(t)))
        const e = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)
        this.boundTextures.length = e
        for (let r = 0; r < e; r++) this.boundTextures[r] = null
        this.emptyTextures = {}
        const i = new mo(t.createTexture())
        ;(t.bindTexture(t.TEXTURE_2D, i.texture),
            t.texImage2D(
                t.TEXTURE_2D,
                0,
                t.RGBA,
                1,
                1,
                0,
                t.RGBA,
                t.UNSIGNED_BYTE,
                new Uint8Array(4),
            ),
            (this.emptyTextures[t.TEXTURE_2D] = i),
            (this.emptyTextures[t.TEXTURE_CUBE_MAP] = new mo(
                t.createTexture(),
            )),
            t.bindTexture(
                t.TEXTURE_CUBE_MAP,
                this.emptyTextures[t.TEXTURE_CUBE_MAP].texture,
            ))
        for (let r = 0; r < 6; r++)
            t.texImage2D(
                t.TEXTURE_CUBE_MAP_POSITIVE_X + r,
                0,
                t.RGBA,
                1,
                1,
                0,
                t.RGBA,
                t.UNSIGNED_BYTE,
                null,
            )
        ;(t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MAG_FILTER, t.LINEAR),
            t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MIN_FILTER, t.LINEAR))
        for (let r = 0; r < this.boundTextures.length; r++) this.bind(null, r)
    }
    bind(t, e = 0) {
        const { gl: i } = this
        if (((t = t?.castToBaseTexture()), t?.valid && !t.parentTextureArray)) {
            t.touched = this.renderer.textureGC.count
            const r = t._glTextures[this.CONTEXT_UID] || this.initTexture(t)
            ;(this.boundTextures[e] !== t &&
                (this.currentLocation !== e &&
                    ((this.currentLocation = e),
                    i.activeTexture(i.TEXTURE0 + e)),
                i.bindTexture(t.target, r.texture)),
                r.dirtyId !== t.dirtyId
                    ? (this.currentLocation !== e &&
                          ((this.currentLocation = e),
                          i.activeTexture(i.TEXTURE0 + e)),
                      this.updateTexture(t))
                    : r.dirtyStyleId !== t.dirtyStyleId &&
                      this.updateTextureStyle(t),
                (this.boundTextures[e] = t))
        } else
            (this.currentLocation !== e &&
                ((this.currentLocation = e), i.activeTexture(i.TEXTURE0 + e)),
                i.bindTexture(
                    i.TEXTURE_2D,
                    this.emptyTextures[i.TEXTURE_2D].texture,
                ),
                (this.boundTextures[e] = null))
    }
    reset() {
        ;((this._unknownBoundTextures = !0),
            (this.hasIntegerTextures = !1),
            (this.currentLocation = -1))
        for (let t = 0; t < this.boundTextures.length; t++)
            this.boundTextures[t] = this.unknownTexture
    }
    unbind(t) {
        const { gl: e, boundTextures: i } = this
        if (this._unknownBoundTextures) {
            this._unknownBoundTextures = !1
            for (let r = 0; r < i.length; r++)
                i[r] === this.unknownTexture && this.bind(null, r)
        }
        for (let r = 0; r < i.length; r++)
            i[r] === t &&
                (this.currentLocation !== r &&
                    (e.activeTexture(e.TEXTURE0 + r),
                    (this.currentLocation = r)),
                e.bindTexture(t.target, this.emptyTextures[t.target].texture),
                (i[r] = null))
    }
    ensureSamplerType(t) {
        const { boundTextures: e, hasIntegerTextures: i, CONTEXT_UID: r } = this
        if (i)
            for (let n = t - 1; n >= 0; --n) {
                const a = e[n]
                a &&
                    a._glTextures[r].samplerType !== q.FLOAT &&
                    this.renderer.texture.unbind(a)
            }
    }
    initTexture(t) {
        const e = new mo(this.gl.createTexture())
        return (
            (e.dirtyId = -1),
            (t._glTextures[this.CONTEXT_UID] = e),
            this.managedTextures.push(t),
            t.on('dispose', this.destroyTexture, this),
            e
        )
    }
    initTextureType(t, e) {
        ;((e.internalFormat =
            this.internalFormats[t.type]?.[t.format] ?? t.format),
            (e.samplerType = this.samplerTypes[e.internalFormat] ?? q.FLOAT),
            this.webGLVersion === 2 && t.type === at.HALF_FLOAT
                ? (e.type = this.gl.HALF_FLOAT)
                : (e.type = t.type))
    }
    updateTexture(t) {
        const e = t._glTextures[this.CONTEXT_UID]
        if (!e) return
        const i = this.renderer
        if ((this.initTextureType(t, e), t.resource?.upload(i, t, e)))
            e.samplerType !== q.FLOAT && (this.hasIntegerTextures = !0)
        else {
            const r = t.realWidth,
                n = t.realHeight,
                a = i.gl
            ;(e.width !== r || e.height !== n || e.dirtyId < 0) &&
                ((e.width = r),
                (e.height = n),
                a.texImage2D(
                    t.target,
                    0,
                    e.internalFormat,
                    r,
                    n,
                    0,
                    t.format,
                    e.type,
                    null,
                ))
        }
        ;(t.dirtyStyleId !== e.dirtyStyleId && this.updateTextureStyle(t),
            (e.dirtyId = t.dirtyId))
    }
    destroyTexture(t, e) {
        const { gl: i } = this
        if (
            ((t = t.castToBaseTexture()),
            t._glTextures[this.CONTEXT_UID] &&
                (this.unbind(t),
                i.deleteTexture(t._glTextures[this.CONTEXT_UID].texture),
                t.off('dispose', this.destroyTexture, this),
                delete t._glTextures[this.CONTEXT_UID],
                !e))
        ) {
            const r = this.managedTextures.indexOf(t)
            r !== -1 && Er(this.managedTextures, r, 1)
        }
    }
    updateTextureStyle(t) {
        const e = t._glTextures[this.CONTEXT_UID]
        e &&
            ((t.mipmap === Xe.POW2 || this.webGLVersion !== 2) &&
            !t.isPowerOfTwo
                ? (e.mipmap = !1)
                : (e.mipmap = t.mipmap >= 1),
            this.webGLVersion !== 2 && !t.isPowerOfTwo
                ? (e.wrapMode = xi.CLAMP)
                : (e.wrapMode = t.wrapMode),
            t.resource?.style(this.renderer, t, e) || this.setStyle(t, e),
            (e.dirtyStyleId = t.dirtyStyleId))
    }
    setStyle(t, e) {
        const i = this.gl
        if (
            (e.mipmap &&
                t.mipmap !== Xe.ON_MANUAL &&
                i.generateMipmap(t.target),
            i.texParameteri(t.target, i.TEXTURE_WRAP_S, e.wrapMode),
            i.texParameteri(t.target, i.TEXTURE_WRAP_T, e.wrapMode),
            e.mipmap)
        ) {
            i.texParameteri(
                t.target,
                i.TEXTURE_MIN_FILTER,
                t.scaleMode === Ze.LINEAR
                    ? i.LINEAR_MIPMAP_LINEAR
                    : i.NEAREST_MIPMAP_NEAREST,
            )
            const r = this.renderer.context.extensions.anisotropicFiltering
            if (r && t.anisotropicLevel > 0 && t.scaleMode === Ze.LINEAR) {
                const n = Math.min(
                    t.anisotropicLevel,
                    i.getParameter(r.MAX_TEXTURE_MAX_ANISOTROPY_EXT),
                )
                i.texParameterf(t.target, r.TEXTURE_MAX_ANISOTROPY_EXT, n)
            }
        } else
            i.texParameteri(
                t.target,
                i.TEXTURE_MIN_FILTER,
                t.scaleMode === Ze.LINEAR ? i.LINEAR : i.NEAREST,
            )
        i.texParameteri(
            t.target,
            i.TEXTURE_MAG_FILTER,
            t.scaleMode === Ze.LINEAR ? i.LINEAR : i.NEAREST,
        )
    }
    destroy() {
        this.renderer = null
    }
}
of.extension = { type: $.RendererSystem, name: 'texture' }
Q.add(of)
class hf {
    constructor(t) {
        this.renderer = t
    }
    contextChange() {
        ;((this.gl = this.renderer.gl),
            (this.CONTEXT_UID = this.renderer.CONTEXT_UID))
    }
    bind(t) {
        const { gl: e, CONTEXT_UID: i } = this,
            r = t._glTransformFeedbacks[i] || this.createGLTransformFeedback(t)
        e.bindTransformFeedback(e.TRANSFORM_FEEDBACK, r)
    }
    unbind() {
        const { gl: t } = this
        t.bindTransformFeedback(t.TRANSFORM_FEEDBACK, null)
    }
    beginTransformFeedback(t, e) {
        const { gl: i, renderer: r } = this
        ;(e && r.shader.bind(e), i.beginTransformFeedback(t))
    }
    endTransformFeedback() {
        const { gl: t } = this
        t.endTransformFeedback()
    }
    createGLTransformFeedback(t) {
        const { gl: e, renderer: i, CONTEXT_UID: r } = this,
            n = e.createTransformFeedback()
        ;((t._glTransformFeedbacks[r] = n),
            e.bindTransformFeedback(e.TRANSFORM_FEEDBACK, n))
        for (let a = 0; a < t.buffers.length; a++) {
            const o = t.buffers[a]
            o &&
                (i.buffer.update(o),
                o._glBuffers[r].refCount++,
                e.bindBufferBase(
                    e.TRANSFORM_FEEDBACK_BUFFER,
                    a,
                    o._glBuffers[r].buffer || null,
                ))
        }
        return (
            e.bindTransformFeedback(e.TRANSFORM_FEEDBACK, null),
            t.disposeRunner.add(this),
            n
        )
    }
    disposeTransformFeedback(t, e) {
        const i = t._glTransformFeedbacks[this.CONTEXT_UID],
            r = this.gl
        t.disposeRunner.remove(this)
        const n = this.renderer.buffer
        if (n)
            for (let a = 0; a < t.buffers.length; a++) {
                const o = t.buffers[a]
                if (!o) continue
                const h = o._glBuffers[this.CONTEXT_UID]
                h && (h.refCount--, h.refCount === 0 && !e && n.dispose(o, e))
            }
        i &&
            (e || r.deleteTransformFeedback(i),
            delete t._glTransformFeedbacks[this.CONTEXT_UID])
    }
    destroy() {
        this.renderer = null
    }
}
hf.extension = { type: $.RendererSystem, name: 'transformFeedback' }
Q.add(hf)
class yn {
    constructor(t) {
        this.renderer = t
    }
    init(t) {
        ;((this.screen = new dt(0, 0, t.width, t.height)),
            (this.element = t.view || Y.ADAPTER.createCanvas()),
            (this.resolution = t.resolution || Y.RESOLUTION),
            (this.autoDensity = !!t.autoDensity))
    }
    resizeView(t, e) {
        ;((this.element.width = Math.round(t * this.resolution)),
            (this.element.height = Math.round(e * this.resolution)))
        const i = this.element.width / this.resolution,
            r = this.element.height / this.resolution
        ;((this.screen.width = i),
            (this.screen.height = r),
            this.autoDensity &&
                ((this.element.style.width = `${i}px`),
                (this.element.style.height = `${r}px`)),
            this.renderer.emit('resize', i, r),
            this.renderer.runners.resize.emit(
                this.screen.width,
                this.screen.height,
            ))
    }
    destroy(t) {
        ;(t && this.element.parentNode?.removeChild(this.element),
            (this.renderer = null),
            (this.element = null),
            (this.screen = null))
    }
}
;((yn.defaultOptions = {
    width: 800,
    height: 600,
    resolution: void 0,
    autoDensity: !1,
}),
    (yn.extension = {
        type: [$.RendererSystem, $.CanvasRendererSystem],
        name: '_view',
    }))
Q.add(yn)
Y.PREFER_ENV = tr.WEBGL2
Y.STRICT_TEXTURE_CACHE = !1
Y.RENDER_OPTIONS = {
    ...gn.defaultOptions,
    ...mn.defaultOptions,
    ...yn.defaultOptions,
    ..._n.defaultOptions,
}
Object.defineProperties(Y, {
    WRAP_MODE: {
        get() {
            return lt.defaultOptions.wrapMode
        },
        set(s) {
            ;(ft(
                '7.1.0',
                'settings.WRAP_MODE is deprecated, use BaseTexture.defaultOptions.wrapMode',
            ),
                (lt.defaultOptions.wrapMode = s))
        },
    },
    SCALE_MODE: {
        get() {
            return lt.defaultOptions.scaleMode
        },
        set(s) {
            ;(ft(
                '7.1.0',
                'settings.SCALE_MODE is deprecated, use BaseTexture.defaultOptions.scaleMode',
            ),
                (lt.defaultOptions.scaleMode = s))
        },
    },
    MIPMAP_TEXTURES: {
        get() {
            return lt.defaultOptions.mipmap
        },
        set(s) {
            ;(ft(
                '7.1.0',
                'settings.MIPMAP_TEXTURES is deprecated, use BaseTexture.defaultOptions.mipmap',
            ),
                (lt.defaultOptions.mipmap = s))
        },
    },
    ANISOTROPIC_LEVEL: {
        get() {
            return lt.defaultOptions.anisotropicLevel
        },
        set(s) {
            ;(ft(
                '7.1.0',
                'settings.ANISOTROPIC_LEVEL is deprecated, use BaseTexture.defaultOptions.anisotropicLevel',
            ),
                (lt.defaultOptions.anisotropicLevel = s))
        },
    },
    FILTER_RESOLUTION: {
        get() {
            return (
                ft(
                    '7.1.0',
                    'settings.FILTER_RESOLUTION is deprecated, use Filter.defaultResolution',
                ),
                qt.defaultResolution
            )
        },
        set(s) {
            qt.defaultResolution = s
        },
    },
    FILTER_MULTISAMPLE: {
        get() {
            return (
                ft(
                    '7.1.0',
                    'settings.FILTER_MULTISAMPLE is deprecated, use Filter.defaultMultisample',
                ),
                qt.defaultMultisample
            )
        },
        set(s) {
            qt.defaultMultisample = s
        },
    },
    SPRITE_MAX_TEXTURES: {
        get() {
            return Ui.defaultMaxTextures
        },
        set(s) {
            ;(ft(
                '7.1.0',
                'settings.SPRITE_MAX_TEXTURES is deprecated, use BatchRenderer.defaultMaxTextures',
            ),
                (Ui.defaultMaxTextures = s))
        },
    },
    SPRITE_BATCH_SIZE: {
        get() {
            return Ui.defaultBatchSize
        },
        set(s) {
            ;(ft(
                '7.1.0',
                'settings.SPRITE_BATCH_SIZE is deprecated, use BatchRenderer.defaultBatchSize',
            ),
                (Ui.defaultBatchSize = s))
        },
    },
    CAN_UPLOAD_SAME_BUFFER: {
        get() {
            return Ui.canUploadSameBuffer
        },
        set(s) {
            ;(ft(
                '7.1.0',
                'settings.CAN_UPLOAD_SAME_BUFFER is deprecated, use BatchRenderer.canUploadSameBuffer',
            ),
                (Ui.canUploadSameBuffer = s))
        },
    },
    GC_MODE: {
        get() {
            return Gi.defaultMode
        },
        set(s) {
            ;(ft(
                '7.1.0',
                'settings.GC_MODE is deprecated, use TextureGCSystem.defaultMode',
            ),
                (Gi.defaultMode = s))
        },
    },
    GC_MAX_IDLE: {
        get() {
            return Gi.defaultMaxIdle
        },
        set(s) {
            ;(ft(
                '7.1.0',
                'settings.GC_MAX_IDLE is deprecated, use TextureGCSystem.defaultMaxIdle',
            ),
                (Gi.defaultMaxIdle = s))
        },
    },
    GC_MAX_CHECK_COUNT: {
        get() {
            return Gi.defaultCheckCountMax
        },
        set(s) {
            ;(ft(
                '7.1.0',
                'settings.GC_MAX_CHECK_COUNT is deprecated, use TextureGCSystem.defaultCheckCountMax',
            ),
                (Gi.defaultCheckCountMax = s))
        },
    },
    PRECISION_VERTEX: {
        get() {
            return ti.defaultVertexPrecision
        },
        set(s) {
            ;(ft(
                '7.1.0',
                'settings.PRECISION_VERTEX is deprecated, use Program.defaultVertexPrecision',
            ),
                (ti.defaultVertexPrecision = s))
        },
    },
    PRECISION_FRAGMENT: {
        get() {
            return ti.defaultFragmentPrecision
        },
        set(s) {
            ;(ft(
                '7.1.0',
                'settings.PRECISION_FRAGMENT is deprecated, use Program.defaultFragmentPrecision',
            ),
                (ti.defaultFragmentPrecision = s))
        },
    },
})
var Qi = (s => (
    (s[(s.INTERACTION = 50)] = 'INTERACTION'),
    (s[(s.HIGH = 25)] = 'HIGH'),
    (s[(s.NORMAL = 0)] = 'NORMAL'),
    (s[(s.LOW = -25)] = 'LOW'),
    (s[(s.UTILITY = -50)] = 'UTILITY'),
    s
))(Qi || {})
class go {
    constructor(t, e = null, i = 0, r = !1) {
        ;((this.next = null),
            (this.previous = null),
            (this._destroyed = !1),
            (this.fn = t),
            (this.context = e),
            (this.priority = i),
            (this.once = r))
    }
    match(t, e = null) {
        return this.fn === t && this.context === e
    }
    emit(t) {
        this.fn && (this.context ? this.fn.call(this.context, t) : this.fn(t))
        const e = this.next
        return (
            this.once && this.destroy(!0),
            this._destroyed && (this.next = null),
            e
        )
    }
    connect(t) {
        ;((this.previous = t),
            t.next && (t.next.previous = this),
            (this.next = t.next),
            (t.next = this))
    }
    destroy(t = !1) {
        ;((this._destroyed = !0),
            (this.fn = null),
            (this.context = null),
            this.previous && (this.previous.next = this.next),
            this.next && (this.next.previous = this.previous))
        const e = this.next
        return ((this.next = t ? null : e), (this.previous = null), e)
    }
}
const lf = class se {
    constructor() {
        ;((this.autoStart = !1),
            (this.deltaTime = 1),
            (this.lastTime = -1),
            (this.speed = 1),
            (this.started = !1),
            (this._requestId = null),
            (this._maxElapsedMS = 100),
            (this._minElapsedMS = 0),
            (this._protected = !1),
            (this._lastFrame = -1),
            (this._head = new go(null, null, 1 / 0)),
            (this.deltaMS = 1 / se.targetFPMS),
            (this.elapsedMS = 1 / se.targetFPMS),
            (this._tick = t => {
                ;((this._requestId = null),
                    this.started &&
                        (this.update(t),
                        this.started &&
                            this._requestId === null &&
                            this._head.next &&
                            (this._requestId = requestAnimationFrame(
                                this._tick,
                            ))))
            }))
    }
    _requestIfNeeded() {
        this._requestId === null &&
            this._head.next &&
            ((this.lastTime = performance.now()),
            (this._lastFrame = this.lastTime),
            (this._requestId = requestAnimationFrame(this._tick)))
    }
    _cancelIfNeeded() {
        this._requestId !== null &&
            (cancelAnimationFrame(this._requestId), (this._requestId = null))
    }
    _startIfPossible() {
        this.started ? this._requestIfNeeded() : this.autoStart && this.start()
    }
    add(t, e, i = Qi.NORMAL) {
        return this._addListener(new go(t, e, i))
    }
    addOnce(t, e, i = Qi.NORMAL) {
        return this._addListener(new go(t, e, i, !0))
    }
    _addListener(t) {
        let e = this._head.next,
            i = this._head
        if (!e) t.connect(i)
        else {
            for (; e; ) {
                if (t.priority > e.priority) {
                    t.connect(i)
                    break
                }
                ;((i = e), (e = e.next))
            }
            t.previous || t.connect(i)
        }
        return (this._startIfPossible(), this)
    }
    remove(t, e) {
        let i = this._head.next
        for (; i; ) i.match(t, e) ? (i = i.destroy()) : (i = i.next)
        return (this._head.next || this._cancelIfNeeded(), this)
    }
    get count() {
        if (!this._head) return 0
        let t = 0,
            e = this._head
        for (; (e = e.next); ) t++
        return t
    }
    start() {
        this.started || ((this.started = !0), this._requestIfNeeded())
    }
    stop() {
        this.started && ((this.started = !1), this._cancelIfNeeded())
    }
    destroy() {
        if (!this._protected) {
            this.stop()
            let t = this._head.next
            for (; t; ) t = t.destroy(!0)
            ;(this._head.destroy(), (this._head = null))
        }
    }
    update(t = performance.now()) {
        let e
        if (t > this.lastTime) {
            if (
                ((e = this.elapsedMS = t - this.lastTime),
                e > this._maxElapsedMS && (e = this._maxElapsedMS),
                (e *= this.speed),
                this._minElapsedMS)
            ) {
                const n = (t - this._lastFrame) | 0
                if (n < this._minElapsedMS) return
                this._lastFrame = t - (n % this._minElapsedMS)
            }
            ;((this.deltaMS = e),
                (this.deltaTime = this.deltaMS * se.targetFPMS))
            const i = this._head
            let r = i.next
            for (; r; ) r = r.emit(this.deltaTime)
            i.next || this._cancelIfNeeded()
        } else this.deltaTime = this.deltaMS = this.elapsedMS = 0
        this.lastTime = t
    }
    get FPS() {
        return 1e3 / this.elapsedMS
    }
    get minFPS() {
        return 1e3 / this._maxElapsedMS
    }
    set minFPS(t) {
        const e = Math.min(this.maxFPS, t),
            i = Math.min(Math.max(0, e) / 1e3, se.targetFPMS)
        this._maxElapsedMS = 1 / i
    }
    get maxFPS() {
        return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0
    }
    set maxFPS(t) {
        if (t === 0) this._minElapsedMS = 0
        else {
            const e = Math.max(this.minFPS, t)
            this._minElapsedMS = 1 / (e / 1e3)
        }
    }
    static get shared() {
        if (!se._shared) {
            const t = (se._shared = new se())
            ;((t.autoStart = !0), (t._protected = !0))
        }
        return se._shared
    }
    static get system() {
        if (!se._system) {
            const t = (se._system = new se())
            ;((t.autoStart = !0), (t._protected = !0))
        }
        return se._system
    }
}
lf.targetFPMS = 0.06
let Yt = lf
Object.defineProperties(Y, {
    TARGET_FPMS: {
        get() {
            return Yt.targetFPMS
        },
        set(s) {
            ;(ft(
                '7.1.0',
                'settings.TARGET_FPMS is deprecated, use Ticker.targetFPMS',
            ),
                (Yt.targetFPMS = s))
        },
    },
})
class uf {
    static init(t) {
        ;((t = Object.assign({ autoStart: !0, sharedTicker: !1 }, t)),
            Object.defineProperty(this, 'ticker', {
                set(e) {
                    ;(this._ticker && this._ticker.remove(this.render, this),
                        (this._ticker = e),
                        e && e.add(this.render, this, Qi.LOW))
                },
                get() {
                    return this._ticker
                },
            }),
            (this.stop = () => {
                this._ticker.stop()
            }),
            (this.start = () => {
                this._ticker.start()
            }),
            (this._ticker = null),
            (this.ticker = t.sharedTicker ? Yt.shared : new Yt()),
            t.autoStart && this.start())
    }
    static destroy() {
        if (this._ticker) {
            const t = this._ticker
            ;((this.ticker = null), t.destroy())
        }
    }
}
uf.extension = $.Application
Q.add(uf)
const cf = []
Q.handleByList($.Renderer, cf)
function I_(s) {
    for (const t of cf) if (t.test(s)) return new t(s)
    throw new Error('Unable to auto-detect a suitable renderer.')
}
var M_ = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
    vTextureCoord = aTextureCoord;
}`,
    D_ = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`
const B_ = M_,
    df = D_
class ff {
    constructor(t) {
        this.renderer = t
    }
    contextChange(t) {
        let e
        if (this.renderer.context.webGLVersion === 1) {
            const i = t.getParameter(t.FRAMEBUFFER_BINDING)
            ;(t.bindFramebuffer(t.FRAMEBUFFER, null),
                (e = t.getParameter(t.SAMPLES)),
                t.bindFramebuffer(t.FRAMEBUFFER, i))
        } else {
            const i = t.getParameter(t.DRAW_FRAMEBUFFER_BINDING)
            ;(t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
                (e = t.getParameter(t.SAMPLES)),
                t.bindFramebuffer(t.DRAW_FRAMEBUFFER, i))
        }
        e >= Ft.HIGH
            ? (this.multisample = Ft.HIGH)
            : e >= Ft.MEDIUM
              ? (this.multisample = Ft.MEDIUM)
              : e >= Ft.LOW
                ? (this.multisample = Ft.LOW)
                : (this.multisample = Ft.NONE)
    }
    destroy() {}
}
ff.extension = { type: $.RendererSystem, name: '_multisample' }
Q.add(ff)
class O_ {
    constructor(t) {
        ;((this.buffer = t || null),
            (this.updateID = -1),
            (this.byteLength = -1),
            (this.refCount = 0))
    }
}
class pf {
    constructor(t) {
        ;((this.renderer = t),
            (this.managedBuffers = {}),
            (this.boundBufferBases = {}))
    }
    destroy() {
        this.renderer = null
    }
    contextChange() {
        ;(this.disposeAll(!0),
            (this.gl = this.renderer.gl),
            (this.CONTEXT_UID = this.renderer.CONTEXT_UID))
    }
    bind(t) {
        const { gl: e, CONTEXT_UID: i } = this,
            r = t._glBuffers[i] || this.createGLBuffer(t)
        e.bindBuffer(t.type, r.buffer)
    }
    unbind(t) {
        const { gl: e } = this
        e.bindBuffer(t, null)
    }
    bindBufferBase(t, e) {
        const { gl: i, CONTEXT_UID: r } = this
        if (this.boundBufferBases[e] !== t) {
            const n = t._glBuffers[r] || this.createGLBuffer(t)
            ;((this.boundBufferBases[e] = t),
                i.bindBufferBase(i.UNIFORM_BUFFER, e, n.buffer))
        }
    }
    bindBufferRange(t, e, i) {
        const { gl: r, CONTEXT_UID: n } = this
        i = i || 0
        const a = t._glBuffers[n] || this.createGLBuffer(t)
        r.bindBufferRange(r.UNIFORM_BUFFER, e || 0, a.buffer, i * 256, 256)
    }
    update(t) {
        const { gl: e, CONTEXT_UID: i } = this,
            r = t._glBuffers[i] || this.createGLBuffer(t)
        if (t._updateID !== r.updateID)
            if (
                ((r.updateID = t._updateID),
                e.bindBuffer(t.type, r.buffer),
                r.byteLength >= t.data.byteLength)
            )
                e.bufferSubData(t.type, 0, t.data)
            else {
                const n = t.static ? e.STATIC_DRAW : e.DYNAMIC_DRAW
                ;((r.byteLength = t.data.byteLength),
                    e.bufferData(t.type, t.data, n))
            }
    }
    dispose(t, e) {
        if (!this.managedBuffers[t.id]) return
        delete this.managedBuffers[t.id]
        const i = t._glBuffers[this.CONTEXT_UID],
            r = this.gl
        ;(t.disposeRunner.remove(this),
            i &&
                (e || r.deleteBuffer(i.buffer),
                delete t._glBuffers[this.CONTEXT_UID]))
    }
    disposeAll(t) {
        const e = Object.keys(this.managedBuffers)
        for (let i = 0; i < e.length; i++)
            this.dispose(this.managedBuffers[e[i]], t)
    }
    createGLBuffer(t) {
        const { CONTEXT_UID: e, gl: i } = this
        return (
            (t._glBuffers[e] = new O_(i.createBuffer())),
            (this.managedBuffers[t.id] = t),
            t.disposeRunner.add(this),
            t._glBuffers[e]
        )
    }
}
pf.extension = { type: $.RendererSystem, name: 'buffer' }
Q.add(pf)
class mf {
    constructor(t) {
        this.renderer = t
    }
    render(t, e) {
        const i = this.renderer
        let r, n, a, o
        if (
            (e &&
                ((r = e.renderTexture),
                (n = e.clear),
                (a = e.transform),
                (o = e.skipUpdateTransform)),
            (this.renderingToScreen = !r),
            i.runners.prerender.emit(),
            i.emit('prerender'),
            (i.projection.transform = a),
            !i.context.isLost)
        ) {
            if ((r || (this.lastObjectRendered = t), !o)) {
                const h = t.enableTempParent()
                ;(t.updateTransform(), t.disableTempParent(h))
            }
            ;(i.renderTexture.bind(r),
                i.batch.currentRenderer.start(),
                (n ?? i.background.clearBeforeRender) &&
                    i.renderTexture.clear(),
                t.render(i),
                i.batch.currentRenderer.flush(),
                r && (e.blit && i.framebuffer.blit(), r.baseTexture.update()),
                i.runners.postrender.emit(),
                (i.projection.transform = null),
                i.emit('postrender'))
        }
    }
    destroy() {
        ;((this.renderer = null), (this.lastObjectRendered = null))
    }
}
mf.extension = { type: $.RendererSystem, name: 'objectRenderer' }
Q.add(mf)
const rn = class th extends C_ {
    constructor(t) {
        ;(super(),
            (this.type = _d.WEBGL),
            (t = Object.assign({}, Y.RENDER_OPTIONS, t)),
            (this.gl = null),
            (this.CONTEXT_UID = 0),
            (this.globalUniforms = new Se({ projectionMatrix: new Et() }, !0)))
        const e = {
            runners: [
                'init',
                'destroy',
                'contextChange',
                'resolutionChange',
                'reset',
                'update',
                'postrender',
                'prerender',
                'resize',
            ],
            systems: th.__systems,
            priority: [
                '_view',
                'textureGenerator',
                'background',
                '_plugin',
                'startup',
                'context',
                'state',
                'texture',
                'buffer',
                'geometry',
                'framebuffer',
                'transformFeedback',
                'mask',
                'scissor',
                'stencil',
                'projection',
                'textureGC',
                'filter',
                'renderTexture',
                'batch',
                'objectRenderer',
                '_multisample',
            ],
        }
        ;(this.setup(e),
            'useContextAlpha' in t &&
                (ft(
                    '7.0.0',
                    'options.useContextAlpha is deprecated, use options.premultipliedAlpha and options.backgroundAlpha instead',
                ),
                (t.premultipliedAlpha =
                    t.useContextAlpha && t.useContextAlpha !== 'notMultiplied'),
                (t.backgroundAlpha =
                    t.useContextAlpha === !1 ? 1 : t.backgroundAlpha)),
            (this._plugin.rendererPlugins = th.__plugins),
            (this.options = t),
            this.startup.run(this.options))
    }
    static test(t) {
        return t?.forceCanvas ? !1 : rg()
    }
    render(t, e) {
        this.objectRenderer.render(t, e)
    }
    resize(t, e) {
        this._view.resizeView(t, e)
    }
    reset() {
        return (this.runners.reset.emit(), this)
    }
    clear() {
        ;(this.renderTexture.bind(), this.renderTexture.clear())
    }
    destroy(t = !1) {
        ;(this.runners.destroy.items.reverse(),
            this.emitWithCustomOptions(this.runners.destroy, { _view: t }),
            super.destroy())
    }
    get plugins() {
        return this._plugin.plugins
    }
    get multisample() {
        return this._multisample.multisample
    }
    get width() {
        return this._view.element.width
    }
    get height() {
        return this._view.element.height
    }
    get resolution() {
        return this._view.resolution
    }
    set resolution(t) {
        ;((this._view.resolution = t), this.runners.resolutionChange.emit(t))
    }
    get autoDensity() {
        return this._view.autoDensity
    }
    get view() {
        return this._view.element
    }
    get screen() {
        return this._view.screen
    }
    get lastObjectRendered() {
        return this.objectRenderer.lastObjectRendered
    }
    get renderingToScreen() {
        return this.objectRenderer.renderingToScreen
    }
    get rendererLogId() {
        return `WebGL ${this.context.webGLVersion}`
    }
    get clearBeforeRender() {
        return (
            ft(
                '7.0.0',
                'renderer.clearBeforeRender has been deprecated, please use renderer.background.clearBeforeRender instead.',
            ),
            this.background.clearBeforeRender
        )
    }
    get useContextAlpha() {
        return (
            ft(
                '7.0.0',
                'renderer.useContextAlpha has been deprecated, please use renderer.context.premultipliedAlpha instead.',
            ),
            this.context.useContextAlpha
        )
    }
    get preserveDrawingBuffer() {
        return (
            ft(
                '7.0.0',
                'renderer.preserveDrawingBuffer has been deprecated, we cannot truly know this unless pixi created the context',
            ),
            this.context.preserveDrawingBuffer
        )
    }
    get backgroundColor() {
        return (
            ft(
                '7.0.0',
                'renderer.backgroundColor has been deprecated, use renderer.background.color instead.',
            ),
            this.background.color
        )
    }
    set backgroundColor(t) {
        ;(ft(
            '7.0.0',
            'renderer.backgroundColor has been deprecated, use renderer.background.color instead.',
        ),
            (this.background.color = t))
    }
    get backgroundAlpha() {
        return (
            ft(
                '7.0.0',
                'renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead.',
            ),
            this.background.alpha
        )
    }
    set backgroundAlpha(t) {
        ;(ft(
            '7.0.0',
            'renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead.',
        ),
            (this.background.alpha = t))
    }
    get powerPreference() {
        return (
            ft(
                '7.0.0',
                'renderer.powerPreference has been deprecated, we can only know this if pixi creates the context',
            ),
            this.context.powerPreference
        )
    }
    generateTexture(t, e) {
        return this.textureGenerator.generateTexture(t, e)
    }
}
;((rn.extension = { type: $.Renderer, priority: 1 }),
    (rn.__plugins = {}),
    (rn.__systems = {}))
let Wh = rn
Q.handleByMap($.RendererPlugin, Wh.__plugins)
Q.handleByMap($.RendererSystem, Wh.__systems)
Q.add(Wh)
class gf extends ls {
    constructor(t, e) {
        const { width: i, height: r } = e || {}
        ;(super(i, r), (this.items = []), (this.itemDirtyIds = []))
        for (let n = 0; n < t; n++) {
            const a = new lt()
            ;(this.items.push(a), this.itemDirtyIds.push(-2))
        }
        ;((this.length = t), (this._load = null), (this.baseTexture = null))
    }
    initFromArray(t, e) {
        for (let i = 0; i < this.length; i++)
            t[i] &&
                (t[i].castToBaseTexture
                    ? this.addBaseTextureAt(t[i].castToBaseTexture(), i)
                    : t[i] instanceof ls
                      ? this.addResourceAt(t[i], i)
                      : this.addResourceAt(Bd(t[i], e), i))
    }
    dispose() {
        for (let t = 0, e = this.length; t < e; t++) this.items[t].destroy()
        ;((this.items = null), (this.itemDirtyIds = null), (this._load = null))
    }
    addResourceAt(t, e) {
        if (!this.items[e]) throw new Error(`Index ${e} is out of bounds`)
        return (
            t.valid && !this.valid && this.resize(t.width, t.height),
            this.items[e].setResource(t),
            this
        )
    }
    bind(t) {
        if (this.baseTexture !== null)
            throw new Error('Only one base texture per TextureArray is allowed')
        super.bind(t)
        for (let e = 0; e < this.length; e++)
            ((this.items[e].parentTextureArray = t),
                this.items[e].on('update', t.update, t))
    }
    unbind(t) {
        super.unbind(t)
        for (let e = 0; e < this.length; e++)
            ((this.items[e].parentTextureArray = null),
                this.items[e].off('update', t.update, t))
    }
    load() {
        if (this._load) return this._load
        const t = this.items
            .map(e => e.resource)
            .filter(e => e)
            .map(e => e.load())
        return (
            (this._load = Promise.all(t).then(() => {
                const { realWidth: e, realHeight: i } = this.items[0]
                return (this.resize(e, i), this.update(), Promise.resolve(this))
            })),
            this._load
        )
    }
}
class F_ extends gf {
    constructor(t, e) {
        const { width: i, height: r } = e || {}
        let n, a
        ;(Array.isArray(t) ? ((n = t), (a = t.length)) : (a = t),
            super(a, { width: i, height: r }),
            n && this.initFromArray(n, e))
    }
    addBaseTextureAt(t, e) {
        if (t.resource) this.addResourceAt(t.resource, e)
        else throw new Error('ArrayResource does not support RenderTexture')
        return this
    }
    bind(t) {
        ;(super.bind(t), (t.target = Tr.TEXTURE_2D_ARRAY))
    }
    upload(t, e, i) {
        const { length: r, itemDirtyIds: n, items: a } = this,
            { gl: o } = t
        i.dirtyId < 0 &&
            o.texImage3D(
                o.TEXTURE_2D_ARRAY,
                0,
                i.internalFormat,
                this._width,
                this._height,
                r,
                0,
                e.format,
                i.type,
                null,
            )
        for (let h = 0; h < r; h++) {
            const l = a[h]
            n[h] < l.dirtyId &&
                ((n[h] = l.dirtyId),
                l.valid &&
                    o.texSubImage3D(
                        o.TEXTURE_2D_ARRAY,
                        0,
                        0,
                        0,
                        h,
                        l.resource.width,
                        l.resource.height,
                        1,
                        e.format,
                        i.type,
                        l.resource.source,
                    ))
        }
        return !0
    }
}
class L_ extends ri {
    constructor(t) {
        super(t)
    }
    static test(t) {
        const { OffscreenCanvas: e } = globalThis
        return e && t instanceof e
            ? !0
            : globalThis.HTMLCanvasElement && t instanceof HTMLCanvasElement
    }
}
const _f = class Jr extends gf {
    constructor(t, e) {
        const { width: i, height: r, autoLoad: n, linkBaseTexture: a } = e || {}
        if (t && t.length !== Jr.SIDES)
            throw new Error(`Invalid length. Got ${t.length}, expected 6`)
        super(6, { width: i, height: r })
        for (let o = 0; o < Jr.SIDES; o++)
            this.items[o].target = Tr.TEXTURE_CUBE_MAP_POSITIVE_X + o
        ;((this.linkBaseTexture = a !== !1),
            t && this.initFromArray(t, e),
            n !== !1 && this.load())
    }
    bind(t) {
        ;(super.bind(t), (t.target = Tr.TEXTURE_CUBE_MAP))
    }
    addBaseTextureAt(t, e, i) {
        if ((i === void 0 && (i = this.linkBaseTexture), !this.items[e]))
            throw new Error(`Index ${e} is out of bounds`)
        if (
            !this.linkBaseTexture ||
            t.parentTextureArray ||
            Object.keys(t._glTextures).length > 0
        )
            if (t.resource) this.addResourceAt(t.resource, e)
            else
                throw new Error(
                    'CubeResource does not support copying of renderTexture.',
                )
        else
            ((t.target = Tr.TEXTURE_CUBE_MAP_POSITIVE_X + e),
                (t.parentTextureArray = this.baseTexture),
                (this.items[e] = t))
        return (
            t.valid && !this.valid && this.resize(t.realWidth, t.realHeight),
            (this.items[e] = t),
            this
        )
    }
    upload(t, e, i) {
        const r = this.itemDirtyIds
        for (let n = 0; n < Jr.SIDES; n++) {
            const a = this.items[n]
            ;(r[n] < a.dirtyId || i.dirtyId < e.dirtyId) &&
                (a.valid && a.resource
                    ? (a.resource.upload(t, a, i), (r[n] = a.dirtyId))
                    : r[n] < -1 &&
                      (t.gl.texImage2D(
                          a.target,
                          0,
                          i.internalFormat,
                          e.realWidth,
                          e.realHeight,
                          0,
                          e.format,
                          i.type,
                          null,
                      ),
                      (r[n] = -1)))
        }
        return !0
    }
    static test(t) {
        return Array.isArray(t) && t.length === Jr.SIDES
    }
}
_f.SIDES = 6
let k_ = _f
class vr extends ri {
    constructor(t, e) {
        e = e || {}
        let i, r, n
        ;(typeof t == 'string'
            ? ((i = vr.EMPTY), (r = t), (n = !0))
            : ((i = t), (r = null), (n = !1)),
            super(i),
            (this.url = r),
            (this.crossOrigin = e.crossOrigin ?? !0),
            (this.alphaMode =
                typeof e.alphaMode == 'number' ? e.alphaMode : null),
            (this.ownsImageBitmap = e.ownsImageBitmap ?? n),
            (this._load = null),
            e.autoLoad !== !1 && this.load())
    }
    load() {
        return this._load
            ? this._load
            : ((this._load = new Promise(async (t, e) => {
                  if (this.url === null) {
                      t(this)
                      return
                  }
                  try {
                      const i = await Y.ADAPTER.fetch(this.url, {
                          mode: this.crossOrigin ? 'cors' : 'no-cors',
                      })
                      if (this.destroyed) return
                      const r = await i.blob()
                      if (this.destroyed) return
                      const n = await createImageBitmap(r, {
                          premultiplyAlpha:
                              this.alphaMode === null ||
                              this.alphaMode === Zt.UNPACK
                                  ? 'premultiply'
                                  : 'none',
                      })
                      if (this.destroyed) {
                          n.close()
                          return
                      }
                      ;((this.source = n), this.update(), t(this))
                  } catch (i) {
                      if (this.destroyed) return
                      ;(e(i), this.onError.emit(i))
                  }
              })),
              this._load)
    }
    upload(t, e, i) {
        return this.source instanceof ImageBitmap
            ? (typeof this.alphaMode == 'number' &&
                  (e.alphaMode = this.alphaMode),
              super.upload(t, e, i))
            : (this.load(), !1)
    }
    dispose() {
        ;(this.ownsImageBitmap &&
            this.source instanceof ImageBitmap &&
            this.source.close(),
            super.dispose(),
            (this._load = null))
    }
    static test(t) {
        return (
            !!globalThis.createImageBitmap &&
            typeof ImageBitmap < 'u' &&
            (typeof t == 'string' || t instanceof ImageBitmap)
        )
    }
    static get EMPTY() {
        return (
            (vr._EMPTY = vr._EMPTY ?? Y.ADAPTER.createCanvas(0, 0)),
            vr._EMPTY
        )
    }
}
const eh = class sn extends ri {
    constructor(t, e) {
        ;((e = e || {}),
            super(Y.ADAPTER.createCanvas()),
            (this._width = 0),
            (this._height = 0),
            (this.svg = t),
            (this.scale = e.scale || 1),
            (this._overrideWidth = e.width),
            (this._overrideHeight = e.height),
            (this._resolve = null),
            (this._crossorigin = e.crossorigin),
            (this._load = null),
            e.autoLoad !== !1 && this.load())
    }
    load() {
        return this._load
            ? this._load
            : ((this._load = new Promise(t => {
                  if (
                      ((this._resolve = () => {
                          ;(this.update(), t(this))
                      }),
                      sn.SVG_XML.test(this.svg.trim()))
                  ) {
                      if (!btoa)
                          throw new Error(
                              "Your browser doesn't support base64 conversions.",
                          )
                      this.svg = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(this.svg)))}`
                  }
                  this._loadSvg()
              })),
              this._load)
    }
    _loadSvg() {
        const t = new Image()
        ;(ri.crossOrigin(t, this.svg, this._crossorigin),
            (t.src = this.svg),
            (t.onerror = e => {
                this._resolve && ((t.onerror = null), this.onError.emit(e))
            }),
            (t.onload = () => {
                if (!this._resolve) return
                const e = t.width,
                    i = t.height
                if (!e || !i)
                    throw new Error(
                        'The SVG image must have width and height defined (in pixels), canvas API needs them.',
                    )
                let r = e * this.scale,
                    n = i * this.scale
                ;((this._overrideWidth || this._overrideHeight) &&
                    ((r =
                        this._overrideWidth || (this._overrideHeight / i) * e),
                    (n =
                        this._overrideHeight || (this._overrideWidth / e) * i)),
                    (r = Math.round(r)),
                    (n = Math.round(n)))
                const a = this.source
                ;((a.width = r),
                    (a.height = n),
                    (a._pixiId = `canvas_${Zi()}`),
                    a.getContext('2d').drawImage(t, 0, 0, e, i, 0, 0, r, n),
                    this._resolve(),
                    (this._resolve = null))
            }))
    }
    static getSize(t) {
        const e = sn.SVG_SIZE.exec(t),
            i = {}
        return (
            e &&
                ((i[e[1]] = Math.round(parseFloat(e[3]))),
                (i[e[5]] = Math.round(parseFloat(e[7])))),
            i
        )
    }
    dispose() {
        ;(super.dispose(), (this._resolve = null), (this._crossorigin = null))
    }
    static test(t, e) {
        return (
            e === 'svg' ||
            (typeof t == 'string' && t.startsWith('data:image/svg+xml')) ||
            (typeof t == 'string' && sn.SVG_XML.test(t))
        )
    }
}
;((eh.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m),
    (eh.SVG_SIZE =
        /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i))
let ih = eh
class N_ extends ri {
    constructor(t) {
        super(t)
    }
    static test(t) {
        return !!globalThis.VideoFrame && t instanceof globalThis.VideoFrame
    }
}
const rh = class sh extends ri {
    constructor(t, e) {
        if (((e = e || {}), !(t instanceof HTMLVideoElement))) {
            const i = document.createElement('video')
            ;(e.autoLoad !== !1 && i.setAttribute('preload', 'auto'),
                e.playsinline !== !1 &&
                    (i.setAttribute('webkit-playsinline', ''),
                    i.setAttribute('playsinline', '')),
                e.muted === !0 && (i.setAttribute('muted', ''), (i.muted = !0)),
                e.loop === !0 && i.setAttribute('loop', ''),
                e.autoPlay !== !1 && i.setAttribute('autoplay', ''),
                typeof t == 'string' && (t = [t]))
            const r = t[0].src || t[0]
            ri.crossOrigin(i, r, e.crossorigin)
            for (let n = 0; n < t.length; ++n) {
                const a = document.createElement('source')
                let { src: o, mime: h } = t[n]
                if (((o = o || t[n]), o.startsWith('data:')))
                    h = o.slice(5, o.indexOf(';'))
                else if (!o.startsWith('blob:')) {
                    const l = o.split('?').shift().toLowerCase(),
                        u = l.slice(l.lastIndexOf('.') + 1)
                    h = h || sh.MIME_TYPES[u] || `video/${u}`
                }
                ;((a.src = o), h && (a.type = h), i.appendChild(a))
            }
            t = i
        }
        ;(super(t),
            (this.noSubImage = !0),
            (this._autoUpdate = !0),
            (this._isConnectedToTicker = !1),
            (this._updateFPS = e.updateFPS || 0),
            (this._msToNextUpdate = 0),
            (this.autoPlay = e.autoPlay !== !1),
            (this._videoFrameRequestCallback =
                this._videoFrameRequestCallback.bind(this)),
            (this._videoFrameRequestCallbackHandle = null),
            (this._load = null),
            (this._resolve = null),
            (this._reject = null),
            (this._onCanPlay = this._onCanPlay.bind(this)),
            (this._onError = this._onError.bind(this)),
            (this._onPlayStart = this._onPlayStart.bind(this)),
            (this._onPlayStop = this._onPlayStop.bind(this)),
            (this._onSeeked = this._onSeeked.bind(this)),
            e.autoLoad !== !1 && this.load())
    }
    update(t = 0) {
        if (!this.destroyed) {
            if (this._updateFPS) {
                const e = Yt.shared.elapsedMS * this.source.playbackRate
                this._msToNextUpdate = Math.floor(this._msToNextUpdate - e)
            }
            ;(!this._updateFPS || this._msToNextUpdate <= 0) &&
                (super.update(),
                (this._msToNextUpdate = this._updateFPS
                    ? Math.floor(1e3 / this._updateFPS)
                    : 0))
        }
    }
    _videoFrameRequestCallback() {
        ;(this.update(),
            this.destroyed
                ? (this._videoFrameRequestCallbackHandle = null)
                : (this._videoFrameRequestCallbackHandle =
                      this.source.requestVideoFrameCallback(
                          this._videoFrameRequestCallback,
                      )))
    }
    load() {
        if (this._load) return this._load
        const t = this.source
        return (
            (t.readyState === t.HAVE_ENOUGH_DATA ||
                t.readyState === t.HAVE_FUTURE_DATA) &&
                t.width &&
                t.height &&
                (t.complete = !0),
            t.addEventListener('play', this._onPlayStart),
            t.addEventListener('pause', this._onPlayStop),
            t.addEventListener('seeked', this._onSeeked),
            this._isSourceReady()
                ? this._onCanPlay()
                : (t.addEventListener('canplay', this._onCanPlay),
                  t.addEventListener('canplaythrough', this._onCanPlay),
                  t.addEventListener('error', this._onError, !0)),
            (this._load = new Promise((e, i) => {
                this.valid
                    ? e(this)
                    : ((this._resolve = e), (this._reject = i), t.load())
            })),
            this._load
        )
    }
    _onError(t) {
        ;(this.source.removeEventListener('error', this._onError, !0),
            this.onError.emit(t),
            this._reject &&
                (this._reject(t),
                (this._reject = null),
                (this._resolve = null)))
    }
    _isSourcePlaying() {
        const t = this.source
        return !t.paused && !t.ended
    }
    _isSourceReady() {
        return this.source.readyState > 2
    }
    _onPlayStart() {
        ;(this.valid || this._onCanPlay(), this._configureAutoUpdate())
    }
    _onPlayStop() {
        this._configureAutoUpdate()
    }
    _onSeeked() {
        this._autoUpdate &&
            !this._isSourcePlaying() &&
            ((this._msToNextUpdate = 0),
            this.update(),
            (this._msToNextUpdate = 0))
    }
    _onCanPlay() {
        const t = this.source
        ;(t.removeEventListener('canplay', this._onCanPlay),
            t.removeEventListener('canplaythrough', this._onCanPlay))
        const e = this.valid
        ;((this._msToNextUpdate = 0),
            this.update(),
            (this._msToNextUpdate = 0),
            !e &&
                this._resolve &&
                (this._resolve(this),
                (this._resolve = null),
                (this._reject = null)),
            this._isSourcePlaying()
                ? this._onPlayStart()
                : this.autoPlay && t.play())
    }
    dispose() {
        this._configureAutoUpdate()
        const t = this.source
        ;(t &&
            (t.removeEventListener('play', this._onPlayStart),
            t.removeEventListener('pause', this._onPlayStop),
            t.removeEventListener('seeked', this._onSeeked),
            t.removeEventListener('canplay', this._onCanPlay),
            t.removeEventListener('canplaythrough', this._onCanPlay),
            t.removeEventListener('error', this._onError, !0),
            t.pause(),
            (t.src = ''),
            t.load()),
            super.dispose())
    }
    get autoUpdate() {
        return this._autoUpdate
    }
    set autoUpdate(t) {
        t !== this._autoUpdate &&
            ((this._autoUpdate = t), this._configureAutoUpdate())
    }
    get updateFPS() {
        return this._updateFPS
    }
    set updateFPS(t) {
        t !== this._updateFPS &&
            ((this._updateFPS = t), this._configureAutoUpdate())
    }
    _configureAutoUpdate() {
        this._autoUpdate && this._isSourcePlaying()
            ? !this._updateFPS && this.source.requestVideoFrameCallback
                ? (this._isConnectedToTicker &&
                      (Yt.shared.remove(this.update, this),
                      (this._isConnectedToTicker = !1),
                      (this._msToNextUpdate = 0)),
                  this._videoFrameRequestCallbackHandle === null &&
                      (this._videoFrameRequestCallbackHandle =
                          this.source.requestVideoFrameCallback(
                              this._videoFrameRequestCallback,
                          )))
                : (this._videoFrameRequestCallbackHandle !== null &&
                      (this.source.cancelVideoFrameCallback(
                          this._videoFrameRequestCallbackHandle,
                      ),
                      (this._videoFrameRequestCallbackHandle = null)),
                  this._isConnectedToTicker ||
                      (Yt.shared.add(this.update, this),
                      (this._isConnectedToTicker = !0),
                      (this._msToNextUpdate = 0)))
            : (this._videoFrameRequestCallbackHandle !== null &&
                  (this.source.cancelVideoFrameCallback(
                      this._videoFrameRequestCallbackHandle,
                  ),
                  (this._videoFrameRequestCallbackHandle = null)),
              this._isConnectedToTicker &&
                  (Yt.shared.remove(this.update, this),
                  (this._isConnectedToTicker = !1),
                  (this._msToNextUpdate = 0)))
    }
    static test(t, e) {
        return (
            (globalThis.HTMLVideoElement && t instanceof HTMLVideoElement) ||
            sh.TYPES.includes(e)
        )
    }
}
;((rh.TYPES = ['mp4', 'm4v', 'webm', 'ogg', 'ogv', 'h264', 'avi', 'mov']),
    (rh.MIME_TYPES = {
        ogv: 'video/ogg',
        mov: 'video/quicktime',
        m4v: 'video/mp4',
    }))
let yf = rh
Vo.push(vr, zd, L_, yf, N_, ih, Fn, k_, F_)
class vn {
    constructor() {
        ;((this.minX = 1 / 0),
            (this.minY = 1 / 0),
            (this.maxX = -1 / 0),
            (this.maxY = -1 / 0),
            (this.rect = null),
            (this.updateID = -1))
    }
    isEmpty() {
        return this.minX > this.maxX || this.minY > this.maxY
    }
    clear() {
        ;((this.minX = 1 / 0),
            (this.minY = 1 / 0),
            (this.maxX = -1 / 0),
            (this.maxY = -1 / 0))
    }
    getRectangle(t) {
        return this.minX > this.maxX || this.minY > this.maxY
            ? dt.EMPTY
            : ((t = t || new dt(0, 0, 1, 1)),
              (t.x = this.minX),
              (t.y = this.minY),
              (t.width = this.maxX - this.minX),
              (t.height = this.maxY - this.minY),
              t)
    }
    addPoint(t) {
        ;((this.minX = Math.min(this.minX, t.x)),
            (this.maxX = Math.max(this.maxX, t.x)),
            (this.minY = Math.min(this.minY, t.y)),
            (this.maxY = Math.max(this.maxY, t.y)))
    }
    addPointMatrix(t, e) {
        const { a: i, b: r, c: n, d: a, tx: o, ty: h } = t,
            l = i * e.x + n * e.y + o,
            u = r * e.x + a * e.y + h
        ;((this.minX = Math.min(this.minX, l)),
            (this.maxX = Math.max(this.maxX, l)),
            (this.minY = Math.min(this.minY, u)),
            (this.maxY = Math.max(this.maxY, u)))
    }
    addQuad(t) {
        let e = this.minX,
            i = this.minY,
            r = this.maxX,
            n = this.maxY,
            a = t[0],
            o = t[1]
        ;((e = a < e ? a : e),
            (i = o < i ? o : i),
            (r = a > r ? a : r),
            (n = o > n ? o : n),
            (a = t[2]),
            (o = t[3]),
            (e = a < e ? a : e),
            (i = o < i ? o : i),
            (r = a > r ? a : r),
            (n = o > n ? o : n),
            (a = t[4]),
            (o = t[5]),
            (e = a < e ? a : e),
            (i = o < i ? o : i),
            (r = a > r ? a : r),
            (n = o > n ? o : n),
            (a = t[6]),
            (o = t[7]),
            (e = a < e ? a : e),
            (i = o < i ? o : i),
            (r = a > r ? a : r),
            (n = o > n ? o : n),
            (this.minX = e),
            (this.minY = i),
            (this.maxX = r),
            (this.maxY = n))
    }
    addFrame(t, e, i, r, n) {
        this.addFrameMatrix(t.worldTransform, e, i, r, n)
    }
    addFrameMatrix(t, e, i, r, n) {
        const a = t.a,
            o = t.b,
            h = t.c,
            l = t.d,
            u = t.tx,
            c = t.ty
        let d = this.minX,
            f = this.minY,
            m = this.maxX,
            p = this.maxY,
            g = a * e + h * i + u,
            _ = o * e + l * i + c
        ;((d = g < d ? g : d),
            (f = _ < f ? _ : f),
            (m = g > m ? g : m),
            (p = _ > p ? _ : p),
            (g = a * r + h * i + u),
            (_ = o * r + l * i + c),
            (d = g < d ? g : d),
            (f = _ < f ? _ : f),
            (m = g > m ? g : m),
            (p = _ > p ? _ : p),
            (g = a * e + h * n + u),
            (_ = o * e + l * n + c),
            (d = g < d ? g : d),
            (f = _ < f ? _ : f),
            (m = g > m ? g : m),
            (p = _ > p ? _ : p),
            (g = a * r + h * n + u),
            (_ = o * r + l * n + c),
            (d = g < d ? g : d),
            (f = _ < f ? _ : f),
            (m = g > m ? g : m),
            (p = _ > p ? _ : p),
            (this.minX = d),
            (this.minY = f),
            (this.maxX = m),
            (this.maxY = p))
    }
    addVertexData(t, e, i) {
        let r = this.minX,
            n = this.minY,
            a = this.maxX,
            o = this.maxY
        for (let h = e; h < i; h += 2) {
            const l = t[h],
                u = t[h + 1]
            ;((r = l < r ? l : r),
                (n = u < n ? u : n),
                (a = l > a ? l : a),
                (o = u > o ? u : o))
        }
        ;((this.minX = r), (this.minY = n), (this.maxX = a), (this.maxY = o))
    }
    addVertices(t, e, i, r) {
        this.addVerticesMatrix(t.worldTransform, e, i, r)
    }
    addVerticesMatrix(t, e, i, r, n = 0, a = n) {
        const o = t.a,
            h = t.b,
            l = t.c,
            u = t.d,
            c = t.tx,
            d = t.ty
        let f = this.minX,
            m = this.minY,
            p = this.maxX,
            g = this.maxY
        for (let _ = i; _ < r; _ += 2) {
            const b = e[_],
                v = e[_ + 1],
                w = o * b + l * v + c,
                x = u * v + h * b + d
            ;((f = Math.min(f, w - n)),
                (p = Math.max(p, w + n)),
                (m = Math.min(m, x - a)),
                (g = Math.max(g, x + a)))
        }
        ;((this.minX = f), (this.minY = m), (this.maxX = p), (this.maxY = g))
    }
    addBounds(t) {
        const e = this.minX,
            i = this.minY,
            r = this.maxX,
            n = this.maxY
        ;((this.minX = t.minX < e ? t.minX : e),
            (this.minY = t.minY < i ? t.minY : i),
            (this.maxX = t.maxX > r ? t.maxX : r),
            (this.maxY = t.maxY > n ? t.maxY : n))
    }
    addBoundsMask(t, e) {
        const i = t.minX > e.minX ? t.minX : e.minX,
            r = t.minY > e.minY ? t.minY : e.minY,
            n = t.maxX < e.maxX ? t.maxX : e.maxX,
            a = t.maxY < e.maxY ? t.maxY : e.maxY
        if (i <= n && r <= a) {
            const o = this.minX,
                h = this.minY,
                l = this.maxX,
                u = this.maxY
            ;((this.minX = i < o ? i : o),
                (this.minY = r < h ? r : h),
                (this.maxX = n > l ? n : l),
                (this.maxY = a > u ? a : u))
        }
    }
    addBoundsMatrix(t, e) {
        this.addFrameMatrix(e, t.minX, t.minY, t.maxX, t.maxY)
    }
    addBoundsArea(t, e) {
        const i = t.minX > e.x ? t.minX : e.x,
            r = t.minY > e.y ? t.minY : e.y,
            n = t.maxX < e.x + e.width ? t.maxX : e.x + e.width,
            a = t.maxY < e.y + e.height ? t.maxY : e.y + e.height
        if (i <= n && r <= a) {
            const o = this.minX,
                h = this.minY,
                l = this.maxX,
                u = this.maxY
            ;((this.minX = i < o ? i : o),
                (this.minY = r < h ? r : h),
                (this.maxX = n > l ? n : l),
                (this.maxY = a > u ? a : u))
        }
    }
    pad(t = 0, e = t) {
        this.isEmpty() ||
            ((this.minX -= t),
            (this.maxX += t),
            (this.minY -= e),
            (this.maxY += e))
    }
    addFramePad(t, e, i, r, n, a) {
        ;((t -= n),
            (e -= a),
            (i += n),
            (r += a),
            (this.minX = this.minX < t ? this.minX : t),
            (this.maxX = this.maxX > i ? this.maxX : i),
            (this.minY = this.minY < e ? this.minY : e),
            (this.maxY = this.maxY > r ? this.maxY : r))
    }
}
class Rt extends vs {
    constructor() {
        ;(super(),
            (this.tempDisplayObjectParent = null),
            (this.transform = new Vh()),
            (this.alpha = 1),
            (this.visible = !0),
            (this.renderable = !0),
            (this.cullable = !1),
            (this.cullArea = null),
            (this.parent = null),
            (this.worldAlpha = 1),
            (this._lastSortedIndex = 0),
            (this._zIndex = 0),
            (this.filterArea = null),
            (this.filters = null),
            (this._enabledFilters = null),
            (this._bounds = new vn()),
            (this._localBounds = null),
            (this._boundsID = 0),
            (this._boundsRect = null),
            (this._localBoundsRect = null),
            (this._mask = null),
            (this._maskRefCount = 0),
            (this._destroyed = !1),
            (this.isSprite = !1),
            (this.isMask = !1))
    }
    static mixin(t) {
        const e = Object.keys(t)
        for (let i = 0; i < e.length; ++i) {
            const r = e[i]
            Object.defineProperty(
                Rt.prototype,
                r,
                Object.getOwnPropertyDescriptor(t, r),
            )
        }
    }
    get destroyed() {
        return this._destroyed
    }
    _recursivePostUpdateTransform() {
        this.parent
            ? (this.parent._recursivePostUpdateTransform(),
              this.transform.updateTransform(this.parent.transform))
            : this.transform.updateTransform(
                  this._tempDisplayObjectParent.transform,
              )
    }
    updateTransform() {
        ;(this._boundsID++,
            this.transform.updateTransform(this.parent.transform),
            (this.worldAlpha = this.alpha * this.parent.worldAlpha))
    }
    getBounds(t, e) {
        return (
            t ||
                (this.parent
                    ? (this._recursivePostUpdateTransform(),
                      this.updateTransform())
                    : ((this.parent = this._tempDisplayObjectParent),
                      this.updateTransform(),
                      (this.parent = null))),
            this._bounds.updateID !== this._boundsID &&
                (this.calculateBounds(),
                (this._bounds.updateID = this._boundsID)),
            e ||
                (this._boundsRect || (this._boundsRect = new dt()),
                (e = this._boundsRect)),
            this._bounds.getRectangle(e)
        )
    }
    getLocalBounds(t) {
        ;(t ||
            (this._localBoundsRect || (this._localBoundsRect = new dt()),
            (t = this._localBoundsRect)),
            this._localBounds || (this._localBounds = new vn()))
        const e = this.transform,
            i = this.parent
        ;((this.parent = null),
            (this._tempDisplayObjectParent.worldAlpha = i?.worldAlpha ?? 1),
            (this.transform = this._tempDisplayObjectParent.transform))
        const r = this._bounds,
            n = this._boundsID
        this._bounds = this._localBounds
        const a = this.getBounds(!1, t)
        return (
            (this.parent = i),
            (this.transform = e),
            (this._bounds = r),
            (this._bounds.updateID += this._boundsID - n),
            a
        )
    }
    toGlobal(t, e, i = !1) {
        return (
            i ||
                (this._recursivePostUpdateTransform(),
                this.parent
                    ? this.displayObjectUpdateTransform()
                    : ((this.parent = this._tempDisplayObjectParent),
                      this.displayObjectUpdateTransform(),
                      (this.parent = null))),
            this.worldTransform.apply(t, e)
        )
    }
    toLocal(t, e, i, r) {
        return (
            e && (t = e.toGlobal(t, i, r)),
            r ||
                (this._recursivePostUpdateTransform(),
                this.parent
                    ? this.displayObjectUpdateTransform()
                    : ((this.parent = this._tempDisplayObjectParent),
                      this.displayObjectUpdateTransform(),
                      (this.parent = null))),
            this.worldTransform.applyInverse(t, i)
        )
    }
    setParent(t) {
        if (!t || !t.addChild)
            throw new Error('setParent: Argument must be a Container')
        return (t.addChild(this), t)
    }
    removeFromParent() {
        this.parent?.removeChild(this)
    }
    setTransform(
        t = 0,
        e = 0,
        i = 1,
        r = 1,
        n = 0,
        a = 0,
        o = 0,
        h = 0,
        l = 0,
    ) {
        return (
            (this.position.x = t),
            (this.position.y = e),
            (this.scale.x = i || 1),
            (this.scale.y = r || 1),
            (this.rotation = n),
            (this.skew.x = a),
            (this.skew.y = o),
            (this.pivot.x = h),
            (this.pivot.y = l),
            this
        )
    }
    destroy(t) {
        ;(this.removeFromParent(),
            (this._destroyed = !0),
            (this.transform = null),
            (this.parent = null),
            (this._bounds = null),
            (this.mask = null),
            (this.cullArea = null),
            (this.filters = null),
            (this.filterArea = null),
            (this.hitArea = null),
            (this.eventMode = 'auto'),
            (this.interactiveChildren = !1),
            this.emit('destroyed'),
            this.removeAllListeners())
    }
    get _tempDisplayObjectParent() {
        return (
            this.tempDisplayObjectParent === null &&
                (this.tempDisplayObjectParent = new U_()),
            this.tempDisplayObjectParent
        )
    }
    enableTempParent() {
        const t = this.parent
        return ((this.parent = this._tempDisplayObjectParent), t)
    }
    disableTempParent(t) {
        this.parent = t
    }
    get x() {
        return this.position.x
    }
    set x(t) {
        this.transform.position.x = t
    }
    get y() {
        return this.position.y
    }
    set y(t) {
        this.transform.position.y = t
    }
    get worldTransform() {
        return this.transform.worldTransform
    }
    get localTransform() {
        return this.transform.localTransform
    }
    get position() {
        return this.transform.position
    }
    set position(t) {
        this.transform.position.copyFrom(t)
    }
    get scale() {
        return this.transform.scale
    }
    set scale(t) {
        this.transform.scale.copyFrom(t)
    }
    get pivot() {
        return this.transform.pivot
    }
    set pivot(t) {
        this.transform.pivot.copyFrom(t)
    }
    get skew() {
        return this.transform.skew
    }
    set skew(t) {
        this.transform.skew.copyFrom(t)
    }
    get rotation() {
        return this.transform.rotation
    }
    set rotation(t) {
        this.transform.rotation = t
    }
    get angle() {
        return this.transform.rotation * Mg
    }
    set angle(t) {
        this.transform.rotation = t * Dg
    }
    get zIndex() {
        return this._zIndex
    }
    set zIndex(t) {
        this._zIndex !== t &&
            ((this._zIndex = t), this.parent && (this.parent.sortDirty = !0))
    }
    get worldVisible() {
        let t = this
        do {
            if (!t.visible) return !1
            t = t.parent
        } while (t)
        return !0
    }
    get mask() {
        return this._mask
    }
    set mask(t) {
        if (this._mask !== t) {
            if (this._mask) {
                const e = this._mask.isMaskData
                    ? this._mask.maskObject
                    : this._mask
                e &&
                    (e._maskRefCount--,
                    e._maskRefCount === 0 &&
                        ((e.renderable = !0), (e.isMask = !1)))
            }
            if (((this._mask = t), this._mask)) {
                const e = this._mask.isMaskData
                    ? this._mask.maskObject
                    : this._mask
                e &&
                    (e._maskRefCount === 0 &&
                        ((e.renderable = !1), (e.isMask = !0)),
                    e._maskRefCount++)
            }
        }
    }
}
class U_ extends Rt {
    constructor() {
        ;(super(...arguments), (this.sortDirty = null))
    }
}
Rt.prototype.displayObjectUpdateTransform = Rt.prototype.updateTransform
const G_ = new Et()
function H_(s, t) {
    return s.zIndex === t.zIndex
        ? s._lastSortedIndex - t._lastSortedIndex
        : s.zIndex - t.zIndex
}
const vf = class nh extends Rt {
    constructor() {
        ;(super(),
            (this.children = []),
            (this.sortableChildren = nh.defaultSortableChildren),
            (this.sortDirty = !1))
    }
    onChildrenChange(t) {}
    addChild(...t) {
        if (t.length > 1) for (let e = 0; e < t.length; e++) this.addChild(t[e])
        else {
            const e = t[0]
            ;(e.parent && e.parent.removeChild(e),
                (e.parent = this),
                (this.sortDirty = !0),
                (e.transform._parentID = -1),
                this.children.push(e),
                this._boundsID++,
                this.onChildrenChange(this.children.length - 1),
                this.emit('childAdded', e, this, this.children.length - 1),
                e.emit('added', this))
        }
        return t[0]
    }
    addChildAt(t, e) {
        if (e < 0 || e > this.children.length)
            throw new Error(
                `${t}addChildAt: The index ${e} supplied is out of bounds ${this.children.length}`,
            )
        return (
            t.parent && t.parent.removeChild(t),
            (t.parent = this),
            (this.sortDirty = !0),
            (t.transform._parentID = -1),
            this.children.splice(e, 0, t),
            this._boundsID++,
            this.onChildrenChange(e),
            t.emit('added', this),
            this.emit('childAdded', t, this, e),
            t
        )
    }
    swapChildren(t, e) {
        if (t === e) return
        const i = this.getChildIndex(t),
            r = this.getChildIndex(e)
        ;((this.children[i] = e),
            (this.children[r] = t),
            this.onChildrenChange(i < r ? i : r))
    }
    getChildIndex(t) {
        const e = this.children.indexOf(t)
        if (e === -1)
            throw new Error(
                'The supplied DisplayObject must be a child of the caller',
            )
        return e
    }
    setChildIndex(t, e) {
        if (e < 0 || e >= this.children.length)
            throw new Error(
                `The index ${e} supplied is out of bounds ${this.children.length}`,
            )
        const i = this.getChildIndex(t)
        ;(Er(this.children, i, 1),
            this.children.splice(e, 0, t),
            this.onChildrenChange(e))
    }
    getChildAt(t) {
        if (t < 0 || t >= this.children.length)
            throw new Error(`getChildAt: Index (${t}) does not exist.`)
        return this.children[t]
    }
    removeChild(...t) {
        if (t.length > 1)
            for (let e = 0; e < t.length; e++) this.removeChild(t[e])
        else {
            const e = t[0],
                i = this.children.indexOf(e)
            if (i === -1) return null
            ;((e.parent = null),
                (e.transform._parentID = -1),
                Er(this.children, i, 1),
                this._boundsID++,
                this.onChildrenChange(i),
                e.emit('removed', this),
                this.emit('childRemoved', e, this, i))
        }
        return t[0]
    }
    removeChildAt(t) {
        const e = this.getChildAt(t)
        return (
            (e.parent = null),
            (e.transform._parentID = -1),
            Er(this.children, t, 1),
            this._boundsID++,
            this.onChildrenChange(t),
            e.emit('removed', this),
            this.emit('childRemoved', e, this, t),
            e
        )
    }
    removeChildren(t = 0, e = this.children.length) {
        const i = t,
            r = e,
            n = r - i
        let a
        if (n > 0 && n <= r) {
            a = this.children.splice(i, n)
            for (let o = 0; o < a.length; ++o)
                ((a[o].parent = null),
                    a[o].transform && (a[o].transform._parentID = -1))
            ;(this._boundsID++, this.onChildrenChange(t))
            for (let o = 0; o < a.length; ++o)
                (a[o].emit('removed', this),
                    this.emit('childRemoved', a[o], this, o))
            return a
        } else if (n === 0 && this.children.length === 0) return []
        throw new RangeError(
            'removeChildren: numeric values are outside the acceptable range.',
        )
    }
    sortChildren() {
        let t = !1
        for (let e = 0, i = this.children.length; e < i; ++e) {
            const r = this.children[e]
            ;((r._lastSortedIndex = e), !t && r.zIndex !== 0 && (t = !0))
        }
        ;(t && this.children.length > 1 && this.children.sort(H_),
            (this.sortDirty = !1))
    }
    updateTransform() {
        ;(this.sortableChildren && this.sortDirty && this.sortChildren(),
            this._boundsID++,
            this.transform.updateTransform(this.parent.transform),
            (this.worldAlpha = this.alpha * this.parent.worldAlpha))
        for (let t = 0, e = this.children.length; t < e; ++t) {
            const i = this.children[t]
            i.visible && i.updateTransform()
        }
    }
    calculateBounds() {
        ;(this._bounds.clear(), this._calculateBounds())
        for (let t = 0; t < this.children.length; t++) {
            const e = this.children[t]
            if (!(!e.visible || !e.renderable))
                if ((e.calculateBounds(), e._mask)) {
                    const i = e._mask.isMaskData ? e._mask.maskObject : e._mask
                    i
                        ? (i.calculateBounds(),
                          this._bounds.addBoundsMask(e._bounds, i._bounds))
                        : this._bounds.addBounds(e._bounds)
                } else
                    e.filterArea
                        ? this._bounds.addBoundsArea(e._bounds, e.filterArea)
                        : this._bounds.addBounds(e._bounds)
        }
        this._bounds.updateID = this._boundsID
    }
    getLocalBounds(t, e = !1) {
        const i = super.getLocalBounds(t)
        if (!e)
            for (let r = 0, n = this.children.length; r < n; ++r) {
                const a = this.children[r]
                a.visible && a.updateTransform()
            }
        return i
    }
    _calculateBounds() {}
    _renderWithCulling(t) {
        const e = t.renderTexture.sourceFrame
        if (!(e.width > 0 && e.height > 0)) return
        let i, r
        this.cullArea
            ? ((i = this.cullArea), (r = this.worldTransform))
            : this._render !== nh.prototype._render && (i = this.getBounds(!0))
        const n = t.projection.transform
        if (
            (n && (r ? ((r = G_.copyFrom(r)), r.prepend(n)) : (r = n)),
            i && e.intersects(i, r))
        )
            this._render(t)
        else if (this.cullArea) return
        for (let a = 0, o = this.children.length; a < o; ++a) {
            const h = this.children[a],
                l = h.cullable
            ;((h.cullable = l || !this.cullArea), h.render(t), (h.cullable = l))
        }
    }
    render(t) {
        if (!(!this.visible || this.worldAlpha <= 0 || !this.renderable))
            if (this._mask || this.filters?.length) this.renderAdvanced(t)
            else if (this.cullable) this._renderWithCulling(t)
            else {
                this._render(t)
                for (let e = 0, i = this.children.length; e < i; ++e)
                    this.children[e].render(t)
            }
    }
    renderAdvanced(t) {
        const e = this.filters,
            i = this._mask
        if (e) {
            ;(this._enabledFilters || (this._enabledFilters = []),
                (this._enabledFilters.length = 0))
            for (let n = 0; n < e.length; n++)
                e[n].enabled && this._enabledFilters.push(e[n])
        }
        const r =
            (e && this._enabledFilters?.length) ||
            (i &&
                (!i.isMaskData ||
                    (i.enabled && (i.autoDetect || i.type !== Nt.NONE))))
        if (
            (r && t.batch.flush(),
            e &&
                this._enabledFilters?.length &&
                t.filter.push(this, this._enabledFilters),
            i && t.mask.push(this, this._mask),
            this.cullable)
        )
            this._renderWithCulling(t)
        else {
            this._render(t)
            for (let n = 0, a = this.children.length; n < a; ++n)
                this.children[n].render(t)
        }
        ;(r && t.batch.flush(),
            i && t.mask.pop(this),
            e && this._enabledFilters?.length && t.filter.pop())
    }
    _render(t) {}
    destroy(t) {
        ;(super.destroy(), (this.sortDirty = !1))
        const e = typeof t == 'boolean' ? t : t?.children,
            i = this.removeChildren(0, this.children.length)
        if (e) for (let r = 0; r < i.length; ++r) i[r].destroy(t)
    }
    get width() {
        return this.scale.x * this.getLocalBounds().width
    }
    set width(t) {
        const e = this.getLocalBounds().width
        ;(e !== 0 ? (this.scale.x = t / e) : (this.scale.x = 1),
            (this._width = t))
    }
    get height() {
        return this.scale.y * this.getLocalBounds().height
    }
    set height(t) {
        const e = this.getLocalBounds().height
        ;(e !== 0 ? (this.scale.y = t / e) : (this.scale.y = 1),
            (this._height = t))
    }
}
vf.defaultSortableChildren = !1
let Kt = vf
Kt.prototype.containerUpdateTransform = Kt.prototype.updateTransform
Object.defineProperties(Y, {
    SORTABLE_CHILDREN: {
        get() {
            return Kt.defaultSortableChildren
        },
        set(s) {
            ;(ft(
                '7.1.0',
                'settings.SORTABLE_CHILDREN is deprecated, use Container.defaultSortableChildren',
            ),
                (Kt.defaultSortableChildren = s))
        },
    },
})
const jr = new ut(),
    z_ = new Uint16Array([0, 1, 2, 0, 2, 3])
let Gr = class xf extends Kt {
    constructor(t) {
        ;(super(),
            (this._anchor = new Je(
                this._onAnchorUpdate,
                this,
                t ? t.defaultAnchor.x : 0,
                t ? t.defaultAnchor.y : 0,
            )),
            (this._texture = null),
            (this._width = 0),
            (this._height = 0),
            (this._tintColor = new Tt(16777215)),
            (this._tintRGB = null),
            (this.tint = 16777215),
            (this.blendMode = ot.NORMAL),
            (this._cachedTint = 16777215),
            (this.uvs = null),
            (this.texture = t || j.EMPTY),
            (this.vertexData = new Float32Array(8)),
            (this.vertexTrimmedData = null),
            (this._transformID = -1),
            (this._textureID = -1),
            (this._transformTrimmedID = -1),
            (this._textureTrimmedID = -1),
            (this.indices = z_),
            (this.pluginName = 'batch'),
            (this.isSprite = !0),
            (this._roundPixels = Y.ROUND_PIXELS))
    }
    _onTextureUpdate() {
        ;((this._textureID = -1),
            (this._textureTrimmedID = -1),
            (this._cachedTint = 16777215),
            this._width &&
                (this.scale.x =
                    (mi(this.scale.x) * this._width) /
                    this._texture.orig.width),
            this._height &&
                (this.scale.y =
                    (mi(this.scale.y) * this._height) /
                    this._texture.orig.height))
    }
    _onAnchorUpdate() {
        ;((this._transformID = -1), (this._transformTrimmedID = -1))
    }
    calculateVertices() {
        const t = this._texture
        if (
            this._transformID === this.transform._worldID &&
            this._textureID === t._updateID
        )
            return
        ;(this._textureID !== t._updateID &&
            (this.uvs = this._texture._uvs.uvsFloat32),
            (this._transformID = this.transform._worldID),
            (this._textureID = t._updateID))
        const e = this.transform.worldTransform,
            i = e.a,
            r = e.b,
            n = e.c,
            a = e.d,
            o = e.tx,
            h = e.ty,
            l = this.vertexData,
            u = t.trim,
            c = t.orig,
            d = this._anchor
        let f = 0,
            m = 0,
            p = 0,
            g = 0
        if (
            (u
                ? ((m = u.x - d._x * c.width),
                  (f = m + u.width),
                  (g = u.y - d._y * c.height),
                  (p = g + u.height))
                : ((m = -d._x * c.width),
                  (f = m + c.width),
                  (g = -d._y * c.height),
                  (p = g + c.height)),
            (l[0] = i * m + n * g + o),
            (l[1] = a * g + r * m + h),
            (l[2] = i * f + n * g + o),
            (l[3] = a * g + r * f + h),
            (l[4] = i * f + n * p + o),
            (l[5] = a * p + r * f + h),
            (l[6] = i * m + n * p + o),
            (l[7] = a * p + r * m + h),
            this._roundPixels)
        ) {
            const _ = Y.RESOLUTION
            for (let b = 0; b < l.length; ++b) l[b] = Math.round(l[b] * _) / _
        }
    }
    calculateTrimmedVertices() {
        if (!this.vertexTrimmedData)
            this.vertexTrimmedData = new Float32Array(8)
        else if (
            this._transformTrimmedID === this.transform._worldID &&
            this._textureTrimmedID === this._texture._updateID
        )
            return
        ;((this._transformTrimmedID = this.transform._worldID),
            (this._textureTrimmedID = this._texture._updateID))
        const t = this._texture,
            e = this.vertexTrimmedData,
            i = t.orig,
            r = this._anchor,
            n = this.transform.worldTransform,
            a = n.a,
            o = n.b,
            h = n.c,
            l = n.d,
            u = n.tx,
            c = n.ty,
            d = -r._x * i.width,
            f = d + i.width,
            m = -r._y * i.height,
            p = m + i.height
        if (
            ((e[0] = a * d + h * m + u),
            (e[1] = l * m + o * d + c),
            (e[2] = a * f + h * m + u),
            (e[3] = l * m + o * f + c),
            (e[4] = a * f + h * p + u),
            (e[5] = l * p + o * f + c),
            (e[6] = a * d + h * p + u),
            (e[7] = l * p + o * d + c),
            this._roundPixels)
        ) {
            const g = Y.RESOLUTION
            for (let _ = 0; _ < e.length; ++_) e[_] = Math.round(e[_] * g) / g
        }
    }
    _render(t) {
        ;(this.calculateVertices(),
            t.batch.setObjectRenderer(t.plugins[this.pluginName]),
            t.plugins[this.pluginName].render(this))
    }
    _calculateBounds() {
        const t = this._texture.trim,
            e = this._texture.orig
        !t || (t.width === e.width && t.height === e.height)
            ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData))
            : (this.calculateTrimmedVertices(),
              this._bounds.addQuad(this.vertexTrimmedData))
    }
    getLocalBounds(t) {
        return this.children.length === 0
            ? (this._localBounds || (this._localBounds = new vn()),
              (this._localBounds.minX =
                  this._texture.orig.width * -this._anchor._x),
              (this._localBounds.minY =
                  this._texture.orig.height * -this._anchor._y),
              (this._localBounds.maxX =
                  this._texture.orig.width * (1 - this._anchor._x)),
              (this._localBounds.maxY =
                  this._texture.orig.height * (1 - this._anchor._y)),
              t ||
                  (this._localBoundsRect || (this._localBoundsRect = new dt()),
                  (t = this._localBoundsRect)),
              this._localBounds.getRectangle(t))
            : super.getLocalBounds.call(this, t)
    }
    containsPoint(t) {
        this.worldTransform.applyInverse(t, jr)
        const e = this._texture.orig.width,
            i = this._texture.orig.height,
            r = -e * this.anchor.x
        let n = 0
        return (
            jr.x >= r &&
            jr.x < r + e &&
            ((n = -i * this.anchor.y), jr.y >= n && jr.y < n + i)
        )
    }
    destroy(t) {
        if (
            (super.destroy(t),
            this._texture.off('update', this._onTextureUpdate, this),
            (this._anchor = null),
            typeof t == 'boolean' ? t : t?.texture)
        ) {
            const e = typeof t == 'boolean' ? t : t?.baseTexture
            this._texture.destroy(!!e)
        }
        this._texture = null
    }
    static from(t, e) {
        const i = t instanceof j ? t : j.from(t, e)
        return new xf(i)
    }
    set roundPixels(t) {
        ;(this._roundPixels !== t &&
            ((this._transformID = -1), (this._transformTrimmedID = -1)),
            (this._roundPixels = t))
    }
    get roundPixels() {
        return this._roundPixels
    }
    get width() {
        return Math.abs(this.scale.x) * this._texture.orig.width
    }
    set width(t) {
        const e = mi(this.scale.x) || 1
        ;((this.scale.x = (e * t) / this._texture.orig.width),
            (this._width = t))
    }
    get height() {
        return Math.abs(this.scale.y) * this._texture.orig.height
    }
    set height(t) {
        const e = mi(this.scale.y) || 1
        ;((this.scale.y = (e * t) / this._texture.orig.height),
            (this._height = t))
    }
    get anchor() {
        return this._anchor
    }
    set anchor(t) {
        this._anchor.copyFrom(t)
    }
    get tint() {
        return this._tintColor.value
    }
    set tint(t) {
        ;(this._tintColor.setValue(t),
            (this._tintRGB = this._tintColor.toLittleEndianNumber()))
    }
    get tintValue() {
        return this._tintColor.toNumber()
    }
    get texture() {
        return this._texture
    }
    set texture(t) {
        this._texture !== t &&
            (this._texture &&
                this._texture.off('update', this._onTextureUpdate, this),
            (this._texture = t || j.EMPTY),
            (this._cachedTint = 16777215),
            (this._textureID = -1),
            (this._textureTrimmedID = -1),
            t &&
                (t.baseTexture.valid
                    ? this._onTextureUpdate()
                    : t.once('update', this._onTextureUpdate, this)))
    }
}
const bf = new Et()
Rt.prototype._cacheAsBitmap = !1
Rt.prototype._cacheData = null
Rt.prototype._cacheAsBitmapResolution = null
Rt.prototype._cacheAsBitmapMultisample = null
class V_ {
    constructor() {
        ;((this.textureCacheId = null),
            (this.originalRender = null),
            (this.originalRenderCanvas = null),
            (this.originalCalculateBounds = null),
            (this.originalGetLocalBounds = null),
            (this.originalUpdateTransform = null),
            (this.originalDestroy = null),
            (this.originalMask = null),
            (this.originalFilterArea = null),
            (this.originalContainsPoint = null),
            (this.sprite = null))
    }
}
Object.defineProperties(Rt.prototype, {
    cacheAsBitmapResolution: {
        get() {
            return this._cacheAsBitmapResolution
        },
        set(s) {
            s !== this._cacheAsBitmapResolution &&
                ((this._cacheAsBitmapResolution = s),
                this.cacheAsBitmap &&
                    ((this.cacheAsBitmap = !1), (this.cacheAsBitmap = !0)))
        },
    },
    cacheAsBitmapMultisample: {
        get() {
            return this._cacheAsBitmapMultisample
        },
        set(s) {
            s !== this._cacheAsBitmapMultisample &&
                ((this._cacheAsBitmapMultisample = s),
                this.cacheAsBitmap &&
                    ((this.cacheAsBitmap = !1), (this.cacheAsBitmap = !0)))
        },
    },
    cacheAsBitmap: {
        get() {
            return this._cacheAsBitmap
        },
        set(s) {
            if (this._cacheAsBitmap === s) return
            this._cacheAsBitmap = s
            let t
            s
                ? (this._cacheData || (this._cacheData = new V_()),
                  (t = this._cacheData),
                  (t.originalRender = this.render),
                  (t.originalRenderCanvas = this.renderCanvas),
                  (t.originalUpdateTransform = this.updateTransform),
                  (t.originalCalculateBounds = this.calculateBounds),
                  (t.originalGetLocalBounds = this.getLocalBounds),
                  (t.originalDestroy = this.destroy),
                  (t.originalContainsPoint = this.containsPoint),
                  (t.originalMask = this._mask),
                  (t.originalFilterArea = this.filterArea),
                  (this.render = this._renderCached),
                  (this.renderCanvas = this._renderCachedCanvas),
                  (this.destroy = this._cacheAsBitmapDestroy))
                : ((t = this._cacheData),
                  t.sprite && this._destroyCachedDisplayObject(),
                  (this.render = t.originalRender),
                  (this.renderCanvas = t.originalRenderCanvas),
                  (this.calculateBounds = t.originalCalculateBounds),
                  (this.getLocalBounds = t.originalGetLocalBounds),
                  (this.destroy = t.originalDestroy),
                  (this.updateTransform = t.originalUpdateTransform),
                  (this.containsPoint = t.originalContainsPoint),
                  (this._mask = t.originalMask),
                  (this.filterArea = t.originalFilterArea))
        },
    },
})
Rt.prototype._renderCached = function (s) {
    !this.visible ||
        this.worldAlpha <= 0 ||
        !this.renderable ||
        (this._initCachedDisplayObject(s),
        (this._cacheData.sprite.transform._worldID = this.transform._worldID),
        (this._cacheData.sprite.worldAlpha = this.worldAlpha),
        this._cacheData.sprite._render(s))
}
Rt.prototype._initCachedDisplayObject = function (s) {
    if (this._cacheData?.sprite) return
    const t = this.alpha
    ;((this.alpha = 1), s.batch.flush())
    const e = this.getLocalBounds(new dt(), !0)
    if (this.filters?.length) {
        const d = this.filters[0].padding
        e.pad(d)
    }
    const i = this.cacheAsBitmapResolution || s.resolution
    ;(e.ceil(i),
        (e.width = Math.max(e.width, 1 / i)),
        (e.height = Math.max(e.height, 1 / i)))
    const r = s.renderTexture.current,
        n = s.renderTexture.sourceFrame.clone(),
        a = s.renderTexture.destinationFrame.clone(),
        o = s.projection.transform,
        h = er.create({
            width: e.width,
            height: e.height,
            resolution: i,
            multisample: this.cacheAsBitmapMultisample ?? s.multisample,
        }),
        l = `cacheAsBitmap_${Zi()}`
    ;((this._cacheData.textureCacheId = l),
        lt.addToCache(h.baseTexture, l),
        j.addToCache(h, l))
    const u = this.transform.localTransform
        .copyTo(bf)
        .invert()
        .translate(-e.x, -e.y)
    ;((this.render = this._cacheData.originalRender),
        s.render(this, {
            renderTexture: h,
            clear: !0,
            transform: u,
            skipUpdateTransform: !1,
        }),
        s.framebuffer.blit(),
        (s.projection.transform = o),
        s.renderTexture.bind(r, n, a),
        (this.render = this._renderCached),
        (this.updateTransform = this.displayObjectUpdateTransform),
        (this.calculateBounds = this._calculateCachedBounds),
        (this.getLocalBounds = this._getCachedLocalBounds),
        (this._mask = null),
        (this.filterArea = null),
        (this.alpha = t))
    const c = new Gr(h)
    ;((c.transform.worldTransform = this.transform.worldTransform),
        (c.anchor.x = -(e.x / e.width)),
        (c.anchor.y = -(e.y / e.height)),
        (c.alpha = t),
        (c._bounds = this._bounds),
        (this._cacheData.sprite = c),
        (this.transform._parentID = -1),
        this.parent
            ? this.updateTransform()
            : (this.enableTempParent(),
              this.updateTransform(),
              this.disableTempParent(null)),
        (this.containsPoint = c.containsPoint.bind(c)))
}
Rt.prototype._renderCachedCanvas = function (s) {
    !this.visible ||
        this.worldAlpha <= 0 ||
        !this.renderable ||
        (this._initCachedDisplayObjectCanvas(s),
        (this._cacheData.sprite.worldAlpha = this.worldAlpha),
        this._cacheData.sprite._renderCanvas(s))
}
Rt.prototype._initCachedDisplayObjectCanvas = function (s) {
    if (this._cacheData?.sprite) return
    const t = this.getLocalBounds(new dt(), !0),
        e = this.alpha
    this.alpha = 1
    const i = s.canvasContext.activeContext,
        r = s._projTransform,
        n = this.cacheAsBitmapResolution || s.resolution
    ;(t.ceil(n),
        (t.width = Math.max(t.width, 1 / n)),
        (t.height = Math.max(t.height, 1 / n)))
    const a = er.create({ width: t.width, height: t.height, resolution: n }),
        o = `cacheAsBitmap_${Zi()}`
    ;((this._cacheData.textureCacheId = o),
        lt.addToCache(a.baseTexture, o),
        j.addToCache(a, o))
    const h = bf
    ;(this.transform.localTransform.copyTo(h),
        h.invert(),
        (h.tx -= t.x),
        (h.ty -= t.y),
        (this.renderCanvas = this._cacheData.originalRenderCanvas),
        s.render(this, {
            renderTexture: a,
            clear: !0,
            transform: h,
            skipUpdateTransform: !1,
        }),
        (s.canvasContext.activeContext = i),
        (s._projTransform = r),
        (this.renderCanvas = this._renderCachedCanvas),
        (this.updateTransform = this.displayObjectUpdateTransform),
        (this.calculateBounds = this._calculateCachedBounds),
        (this.getLocalBounds = this._getCachedLocalBounds),
        (this._mask = null),
        (this.filterArea = null),
        (this.alpha = e))
    const l = new Gr(a)
    ;((l.transform.worldTransform = this.transform.worldTransform),
        (l.anchor.x = -(t.x / t.width)),
        (l.anchor.y = -(t.y / t.height)),
        (l.alpha = e),
        (l._bounds = this._bounds),
        (this._cacheData.sprite = l),
        (this.transform._parentID = -1),
        this.parent
            ? this.updateTransform()
            : ((this.parent = s._tempDisplayObjectParent),
              this.updateTransform(),
              (this.parent = null)),
        (this.containsPoint = l.containsPoint.bind(l)))
}
Rt.prototype._calculateCachedBounds = function () {
    ;(this._bounds.clear(),
        (this._cacheData.sprite.transform._worldID = this.transform._worldID),
        this._cacheData.sprite._calculateBounds(),
        (this._bounds.updateID = this._boundsID))
}
Rt.prototype._getCachedLocalBounds = function () {
    return this._cacheData.sprite.getLocalBounds(null)
}
Rt.prototype._destroyCachedDisplayObject = function () {
    ;(this._cacheData.sprite._texture.destroy(!0),
        (this._cacheData.sprite = null),
        lt.removeFromCache(this._cacheData.textureCacheId),
        j.removeFromCache(this._cacheData.textureCacheId),
        (this._cacheData.textureCacheId = null))
}
Rt.prototype._cacheAsBitmapDestroy = function (s) {
    ;((this.cacheAsBitmap = !1), this.destroy(s))
}
Rt.prototype.name = null
Kt.prototype.getChildByName = function (s, t) {
    for (let e = 0, i = this.children.length; e < i; e++)
        if (this.children[e].name === s) return this.children[e]
    if (t)
        for (let e = 0, i = this.children.length; e < i; e++) {
            const r = this.children[e]
            if (!r.getChildByName) continue
            const n = r.getChildByName(s, !0)
            if (n) return n
        }
    return null
}
Rt.prototype.getGlobalPosition = function (s = new ut(), t = !1) {
    return (
        this.parent
            ? this.parent.toGlobal(this.position, s, t)
            : ((s.x = this.position.x), (s.y = this.position.y)),
        s
    )
}
var X_ = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform float uAlpha;

void main(void)
{
   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;
}
`
class W_ extends qt {
    constructor(t = 1) {
        ;(super(B_, X_, { uAlpha: 1 }), (this.alpha = t))
    }
    get alpha() {
        return this.uniforms.uAlpha
    }
    set alpha(t) {
        this.uniforms.uAlpha = t
    }
}
const $_ = {
        5: [0.153388, 0.221461, 0.250301],
        7: [0.071303, 0.131514, 0.189879, 0.214607],
        9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
        11: [0.0093, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
        13: [
            0.002406, 0.009255, 0.027867, 0.065666, 0.121117, 0.174868,
            0.197641,
        ],
        15: [
            489e-6, 0.002403, 0.009246, 0.02784, 0.065602, 0.120999, 0.174697,
            0.197448,
        ],
    },
    j_ = [
        'varying vec2 vBlurTexCoords[%size%];',
        'uniform sampler2D uSampler;',
        'void main(void)',
        '{',
        '    gl_FragColor = vec4(0.0);',
        '    %blur%',
        '}',
    ].join(`
`)
function q_(s) {
    const t = $_[s],
        e = t.length
    let i = j_,
        r = ''
    const n =
        'gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;'
    let a
    for (let o = 0; o < s; o++) {
        let h = n.replace('%index%', o.toString())
        ;((a = o),
            o >= e && (a = s - o - 1),
            (h = h.replace('%value%', t[a].toString())),
            (r += h),
            (r += `
`))
    }
    return (
        (i = i.replace('%blur%', r)),
        (i = i.replace('%size%', s.toString())),
        i
    )
}
const Y_ = `
    attribute vec2 aVertexPosition;

    uniform mat3 projectionMatrix;

    uniform float strength;

    varying vec2 vBlurTexCoords[%size%];

    uniform vec4 inputSize;
    uniform vec4 outputFrame;

    vec4 filterVertexPosition( void )
    {
        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
    }

    vec2 filterTextureCoord( void )
    {
        return aVertexPosition * (outputFrame.zw * inputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`
function K_(s, t) {
    const e = Math.ceil(s / 2)
    let i = Y_,
        r = '',
        n
    t
        ? (n =
              'vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);')
        : (n =
              'vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);')
    for (let a = 0; a < s; a++) {
        let o = n.replace('%index%', a.toString())
        ;((o = o.replace('%sampleIndex%', `${a - (e - 1)}.0`)),
            (r += o),
            (r += `
`))
    }
    return (
        (i = i.replace('%blur%', r)),
        (i = i.replace('%size%', s.toString())),
        i
    )
}
class ah extends qt {
    constructor(t, e = 8, i = 4, r = qt.defaultResolution, n = 5) {
        const a = K_(n, t),
            o = q_(n)
        ;(super(a, o),
            (this.horizontal = t),
            (this.resolution = r),
            (this._quality = 0),
            (this.quality = i),
            (this.blur = e))
    }
    apply(t, e, i, r) {
        if (
            (i
                ? this.horizontal
                    ? (this.uniforms.strength =
                          (1 / i.width) * (i.width / e.width))
                    : (this.uniforms.strength =
                          (1 / i.height) * (i.height / e.height))
                : this.horizontal
                  ? (this.uniforms.strength =
                        (1 / t.renderer.width) * (t.renderer.width / e.width))
                  : (this.uniforms.strength =
                        (1 / t.renderer.height) *
                        (t.renderer.height / e.height)),
            (this.uniforms.strength *= this.strength),
            (this.uniforms.strength /= this.passes),
            this.passes === 1)
        )
            t.applyFilter(this, e, i, r)
        else {
            const n = t.getFilterTexture(),
                a = t.renderer
            let o = e,
                h = n
            ;((this.state.blend = !1), t.applyFilter(this, o, h, Fe.CLEAR))
            for (let l = 1; l < this.passes - 1; l++) {
                ;(t.bindAndClear(o, Fe.BLIT), (this.uniforms.uSampler = h))
                const u = h
                ;((h = o), (o = u), a.shader.bind(this), a.geometry.draw(5))
            }
            ;((this.state.blend = !0),
                t.applyFilter(this, h, i, r),
                t.returnFilterTexture(n))
        }
    }
    get blur() {
        return this.strength
    }
    set blur(t) {
        ;((this.padding = 1 + Math.abs(t) * 2), (this.strength = t))
    }
    get quality() {
        return this._quality
    }
    set quality(t) {
        ;((this._quality = t), (this.passes = t))
    }
}
class Z_ extends qt {
    constructor(t = 8, e = 4, i = qt.defaultResolution, r = 5) {
        ;(super(),
            (this._repeatEdgePixels = !1),
            (this.blurXFilter = new ah(!0, t, e, i, r)),
            (this.blurYFilter = new ah(!1, t, e, i, r)),
            (this.resolution = i),
            (this.quality = e),
            (this.blur = t),
            (this.repeatEdgePixels = !1))
    }
    apply(t, e, i, r) {
        const n = Math.abs(this.blurXFilter.strength),
            a = Math.abs(this.blurYFilter.strength)
        if (n && a) {
            const o = t.getFilterTexture()
            ;(this.blurXFilter.apply(t, e, o, Fe.CLEAR),
                this.blurYFilter.apply(t, o, i, r),
                t.returnFilterTexture(o))
        } else
            a
                ? this.blurYFilter.apply(t, e, i, r)
                : this.blurXFilter.apply(t, e, i, r)
    }
    updatePadding() {
        this._repeatEdgePixels
            ? (this.padding = 0)
            : (this.padding =
                  Math.max(
                      Math.abs(this.blurXFilter.strength),
                      Math.abs(this.blurYFilter.strength),
                  ) * 2)
    }
    get blur() {
        return this.blurXFilter.blur
    }
    set blur(t) {
        ;((this.blurXFilter.blur = this.blurYFilter.blur = t),
            this.updatePadding())
    }
    get quality() {
        return this.blurXFilter.quality
    }
    set quality(t) {
        this.blurXFilter.quality = this.blurYFilter.quality = t
    }
    get blurX() {
        return this.blurXFilter.blur
    }
    set blurX(t) {
        ;((this.blurXFilter.blur = t), this.updatePadding())
    }
    get blurY() {
        return this.blurYFilter.blur
    }
    set blurY(t) {
        ;((this.blurYFilter.blur = t), this.updatePadding())
    }
    get blendMode() {
        return this.blurYFilter.blendMode
    }
    set blendMode(t) {
        this.blurYFilter.blendMode = t
    }
    get repeatEdgePixels() {
        return this._repeatEdgePixels
    }
    set repeatEdgePixels(t) {
        ;((this._repeatEdgePixels = t), this.updatePadding())
    }
}
var Q_ = `varying vec2 vTextureCoord;
uniform sampler2D uSampler;
uniform float m[20];
uniform float uAlpha;

void main(void)
{
    vec4 c = texture2D(uSampler, vTextureCoord);

    if (uAlpha == 0.0) {
        gl_FragColor = c;
        return;
    }

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (c.a > 0.0) {
      c.rgb /= c.a;
    }

    vec4 result;

    result.r = (m[0] * c.r);
        result.r += (m[1] * c.g);
        result.r += (m[2] * c.b);
        result.r += (m[3] * c.a);
        result.r += m[4];

    result.g = (m[5] * c.r);
        result.g += (m[6] * c.g);
        result.g += (m[7] * c.b);
        result.g += (m[8] * c.a);
        result.g += m[9];

    result.b = (m[10] * c.r);
       result.b += (m[11] * c.g);
       result.b += (m[12] * c.b);
       result.b += (m[13] * c.a);
       result.b += m[14];

    result.a = (m[15] * c.r);
       result.a += (m[16] * c.g);
       result.a += (m[17] * c.b);
       result.a += (m[18] * c.a);
       result.a += m[19];

    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);

    // Premultiply alpha again.
    rgb *= result.a;

    gl_FragColor = vec4(rgb, result.a);
}
`
class oh extends qt {
    constructor() {
        const t = {
            m: new Float32Array([
                1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0,
            ]),
            uAlpha: 1,
        }
        ;(super(df, Q_, t), (this.alpha = 1))
    }
    _loadMatrix(t, e = !1) {
        let i = t
        ;(e &&
            (this._multiply(i, this.uniforms.m, t), (i = this._colorMatrix(i))),
            (this.uniforms.m = i))
    }
    _multiply(t, e, i) {
        return (
            (t[0] = e[0] * i[0] + e[1] * i[5] + e[2] * i[10] + e[3] * i[15]),
            (t[1] = e[0] * i[1] + e[1] * i[6] + e[2] * i[11] + e[3] * i[16]),
            (t[2] = e[0] * i[2] + e[1] * i[7] + e[2] * i[12] + e[3] * i[17]),
            (t[3] = e[0] * i[3] + e[1] * i[8] + e[2] * i[13] + e[3] * i[18]),
            (t[4] =
                e[0] * i[4] + e[1] * i[9] + e[2] * i[14] + e[3] * i[19] + e[4]),
            (t[5] = e[5] * i[0] + e[6] * i[5] + e[7] * i[10] + e[8] * i[15]),
            (t[6] = e[5] * i[1] + e[6] * i[6] + e[7] * i[11] + e[8] * i[16]),
            (t[7] = e[5] * i[2] + e[6] * i[7] + e[7] * i[12] + e[8] * i[17]),
            (t[8] = e[5] * i[3] + e[6] * i[8] + e[7] * i[13] + e[8] * i[18]),
            (t[9] =
                e[5] * i[4] + e[6] * i[9] + e[7] * i[14] + e[8] * i[19] + e[9]),
            (t[10] =
                e[10] * i[0] + e[11] * i[5] + e[12] * i[10] + e[13] * i[15]),
            (t[11] =
                e[10] * i[1] + e[11] * i[6] + e[12] * i[11] + e[13] * i[16]),
            (t[12] =
                e[10] * i[2] + e[11] * i[7] + e[12] * i[12] + e[13] * i[17]),
            (t[13] =
                e[10] * i[3] + e[11] * i[8] + e[12] * i[13] + e[13] * i[18]),
            (t[14] =
                e[10] * i[4] +
                e[11] * i[9] +
                e[12] * i[14] +
                e[13] * i[19] +
                e[14]),
            (t[15] =
                e[15] * i[0] + e[16] * i[5] + e[17] * i[10] + e[18] * i[15]),
            (t[16] =
                e[15] * i[1] + e[16] * i[6] + e[17] * i[11] + e[18] * i[16]),
            (t[17] =
                e[15] * i[2] + e[16] * i[7] + e[17] * i[12] + e[18] * i[17]),
            (t[18] =
                e[15] * i[3] + e[16] * i[8] + e[17] * i[13] + e[18] * i[18]),
            (t[19] =
                e[15] * i[4] +
                e[16] * i[9] +
                e[17] * i[14] +
                e[18] * i[19] +
                e[19]),
            t
        )
    }
    _colorMatrix(t) {
        const e = new Float32Array(t)
        return ((e[4] /= 255), (e[9] /= 255), (e[14] /= 255), (e[19] /= 255), e)
    }
    brightness(t, e) {
        const i = [t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 1, 0]
        this._loadMatrix(i, e)
    }
    tint(t, e) {
        const [i, r, n] = Tt.shared.setValue(t).toArray(),
            a = [i, 0, 0, 0, 0, 0, r, 0, 0, 0, 0, 0, n, 0, 0, 0, 0, 0, 1, 0]
        this._loadMatrix(a, e)
    }
    greyscale(t, e) {
        const i = [t, t, t, 0, 0, t, t, t, 0, 0, t, t, t, 0, 0, 0, 0, 0, 1, 0]
        this._loadMatrix(i, e)
    }
    blackAndWhite(t) {
        const e = [
            0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0, 0,
            0, 1, 0,
        ]
        this._loadMatrix(e, t)
    }
    hue(t, e) {
        t = ((t || 0) / 180) * Math.PI
        const i = Math.cos(t),
            r = Math.sin(t),
            n = Math.sqrt,
            a = 1 / 3,
            o = n(a),
            h = i + (1 - i) * a,
            l = a * (1 - i) - o * r,
            u = a * (1 - i) + o * r,
            c = a * (1 - i) + o * r,
            d = i + a * (1 - i),
            f = a * (1 - i) - o * r,
            m = a * (1 - i) - o * r,
            p = a * (1 - i) + o * r,
            g = i + a * (1 - i),
            _ = [h, l, u, 0, 0, c, d, f, 0, 0, m, p, g, 0, 0, 0, 0, 0, 1, 0]
        this._loadMatrix(_, e)
    }
    contrast(t, e) {
        const i = (t || 0) + 1,
            r = -0.5 * (i - 1),
            n = [i, 0, 0, 0, r, 0, i, 0, 0, r, 0, 0, i, 0, r, 0, 0, 0, 1, 0]
        this._loadMatrix(n, e)
    }
    saturate(t = 0, e) {
        const i = (t * 2) / 3 + 1,
            r = (i - 1) * -0.5,
            n = [i, r, r, 0, 0, r, i, r, 0, 0, r, r, i, 0, 0, 0, 0, 0, 1, 0]
        this._loadMatrix(n, e)
    }
    desaturate() {
        this.saturate(-1)
    }
    negative(t) {
        const e = [
            -1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0,
        ]
        this._loadMatrix(e, t)
    }
    sepia(t) {
        const e = [
            0.393, 0.7689999, 0.18899999, 0, 0, 0.349, 0.6859999, 0.16799999, 0,
            0, 0.272, 0.5339999, 0.13099999, 0, 0, 0, 0, 0, 1, 0,
        ]
        this._loadMatrix(e, t)
    }
    technicolor(t) {
        const e = [
            1.9125277891456083, -0.8545344976951645, -0.09155508482755585, 0,
            11.793603434377337, -0.3087833385928097, 1.7658908555458428,
            -0.10601743074722245, 0, -70.35205161461398, -0.231103377548616,
            -0.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0,
            0, 1, 0,
        ]
        this._loadMatrix(e, t)
    }
    polaroid(t) {
        const e = [
            1.438, -0.062, -0.062, 0, 0, -0.122, 1.378, -0.122, 0, 0, -0.016,
            -0.016, 1.483, 0, 0, 0, 0, 0, 1, 0,
        ]
        this._loadMatrix(e, t)
    }
    toBGR(t) {
        const e = [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0]
        this._loadMatrix(e, t)
    }
    kodachrome(t) {
        const e = [
            1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0,
            63.72958762196502, -0.16404339962244616, 1.0835251566291304,
            -0.05498805115633132, 0, 24.732407896706203, -0.16786010706155763,
            -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0,
            0, 1, 0,
        ]
        this._loadMatrix(e, t)
    }
    browni(t) {
        const e = [
            0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0,
            47.43192855600873, -0.037703249837783157, 0.8609577587992641,
            0.15059552388459913, 0, -36.96841498319127, 0.24113635128153335,
            -0.07441037908422492, 0.44972182064877153, 0, -7.562075277591283, 0,
            0, 0, 1, 0,
        ]
        this._loadMatrix(e, t)
    }
    vintage(t) {
        const e = [
            0.6279345635605994, 0.3202183420819367, -0.03965408211312453, 0,
            9.651285835294123, 0.02578397704808868, 0.6441188644374771,
            0.03259127616149294, 0, 7.462829176470591, 0.0466055556782719,
            -0.0851232987247891, 0.5241648018700465, 0, 5.159190588235296, 0, 0,
            0, 1, 0,
        ]
        this._loadMatrix(e, t)
    }
    colorTone(t, e, i, r, n) {
        ;((t = t || 0.2),
            (e = e || 0.15),
            (i = i || 16770432),
            (r = r || 3375104))
        const a = Tt.shared,
            [o, h, l] = a.setValue(i).toArray(),
            [u, c, d] = a.setValue(r).toArray(),
            f = [
                0.3,
                0.59,
                0.11,
                0,
                0,
                o,
                h,
                l,
                t,
                0,
                u,
                c,
                d,
                e,
                0,
                o - u,
                h - c,
                l - d,
                0,
                0,
            ]
        this._loadMatrix(f, n)
    }
    night(t, e) {
        t = t || 0.1
        const i = [
            t * -2,
            -t,
            0,
            0,
            0,
            -t,
            0,
            t,
            0,
            0,
            0,
            t,
            t * 2,
            0,
            0,
            0,
            0,
            0,
            1,
            0,
        ]
        this._loadMatrix(i, e)
    }
    predator(t, e) {
        const i = [
            11.224130630493164 * t,
            -4.794486999511719 * t,
            -2.8746118545532227 * t,
            0 * t,
            0.40342438220977783 * t,
            -3.6330697536468506 * t,
            9.193157196044922 * t,
            -2.951810836791992 * t,
            0 * t,
            -1.316135048866272 * t,
            -3.2184197902679443 * t,
            -4.2375030517578125 * t,
            7.476448059082031 * t,
            0 * t,
            0.8044459223747253 * t,
            0,
            0,
            0,
            1,
            0,
        ]
        this._loadMatrix(i, e)
    }
    lsd(t) {
        const e = [
            2, -0.4, 0.5, 0, 0, -0.5, 2, -0.4, 0, 0, -0.4, -0.5, 3, 0, 0, 0, 0,
            0, 1, 0,
        ]
        this._loadMatrix(e, t)
    }
    reset() {
        const t = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]
        this._loadMatrix(t, !1)
    }
    get matrix() {
        return this.uniforms.m
    }
    set matrix(t) {
        this.uniforms.m = t
    }
    get alpha() {
        return this.uniforms.uAlpha
    }
    set alpha(t) {
        this.uniforms.uAlpha = t
    }
}
oh.prototype.grayscale = oh.prototype.greyscale
var J_ = `varying vec2 vFilterCoord;
varying vec2 vTextureCoord;

uniform vec2 scale;
uniform mat2 rotation;
uniform sampler2D uSampler;
uniform sampler2D mapSampler;

uniform highp vec4 inputSize;
uniform vec4 inputClamp;

void main(void)
{
  vec4 map =  texture2D(mapSampler, vFilterCoord);

  map -= 0.5;
  map.xy = scale * inputSize.zw * (rotation * map.xy);

  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));
}
`,
    ty = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;
uniform mat3 filterMatrix;

varying vec2 vTextureCoord;
varying vec2 vFilterCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
	gl_Position = filterVertexPosition();
	vTextureCoord = filterTextureCoord();
	vFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;
}
`
class ey extends qt {
    constructor(t, e) {
        const i = new Et()
        ;((t.renderable = !1),
            super(ty, J_, {
                mapSampler: t._texture,
                filterMatrix: i,
                scale: { x: 1, y: 1 },
                rotation: new Float32Array([1, 0, 0, 1]),
            }),
            (this.maskSprite = t),
            (this.maskMatrix = i),
            e == null && (e = 20),
            (this.scale = new ut(e, e)))
    }
    apply(t, e, i, r) {
        ;((this.uniforms.filterMatrix = t.calculateSpriteMatrix(
            this.maskMatrix,
            this.maskSprite,
        )),
            (this.uniforms.scale.x = this.scale.x),
            (this.uniforms.scale.y = this.scale.y))
        const n = this.maskSprite.worldTransform,
            a = Math.sqrt(n.a * n.a + n.b * n.b),
            o = Math.sqrt(n.c * n.c + n.d * n.d)
        ;(a !== 0 &&
            o !== 0 &&
            ((this.uniforms.rotation[0] = n.a / a),
            (this.uniforms.rotation[1] = n.b / a),
            (this.uniforms.rotation[2] = n.c / o),
            (this.uniforms.rotation[3] = n.d / o)),
            t.applyFilter(this, e, i, r))
    }
    get map() {
        return this.uniforms.mapSampler
    }
    set map(t) {
        this.uniforms.mapSampler = t
    }
}
var iy = `varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;
uniform sampler2D uSampler;
uniform highp vec4 inputSize;


/**
 Basic FXAA implementation based on the code on geeks3d.com with the
 modification that the texture2DLod stuff was removed since it's
 unsupported by WebGL.

 --

 From:
 https://github.com/mitsuhiko/webgl-meincraft

 Copyright (c) 2011 by Armin Ronacher.

 Some rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:

 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above
 copyright notice, this list of conditions and the following
 disclaimer in the documentation and/or other materials provided
 with the distribution.

 * The names of the contributors may not be used to endorse or
 promote products derived from this software without specific
 prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FXAA_REDUCE_MIN
#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#endif
#ifndef FXAA_REDUCE_MUL
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#endif
#ifndef FXAA_SPAN_MAX
#define FXAA_SPAN_MAX     8.0
#endif

//optimized version for mobile, where dependent
//texture reads can be a bottleneck
vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,
          vec2 v_rgbNW, vec2 v_rgbNE,
          vec2 v_rgbSW, vec2 v_rgbSE,
          vec2 v_rgbM) {
    vec4 color;
    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;
    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;
    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;
    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;
    vec4 texColor = texture2D(tex, v_rgbM);
    vec3 rgbM  = texColor.xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    mediump vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                  dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
    else
        color = vec4(rgbB, texColor.a);
    return color;
}

void main() {

      vec4 color;

      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);

      gl_FragColor = color;
}
`,
    ry = `
attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

void texcoords(vec2 fragCoord, vec2 inverseVP,
               out vec2 v_rgbNW, out vec2 v_rgbNE,
               out vec2 v_rgbSW, out vec2 v_rgbSE,
               out vec2 v_rgbM) {
    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;
    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;
    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;
    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;
    v_rgbM = vec2(fragCoord * inverseVP);
}

void main(void) {

   gl_Position = filterVertexPosition();

   vFragCoord = aVertexPosition * outputFrame.zw;

   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);
}
`
class sy extends qt {
    constructor() {
        super(ry, iy)
    }
}
var ny = `precision highp float;

varying vec2 vTextureCoord;
varying vec4 vColor;

uniform float uNoise;
uniform float uSeed;
uniform sampler2D uSampler;

float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main()
{
    vec4 color = texture2D(uSampler, vTextureCoord);
    float randomValue = rand(gl_FragCoord.xy * uSeed);
    float diff = (randomValue - 0.5) * uNoise;

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (color.a > 0.0) {
        color.rgb /= color.a;
    }

    color.r += diff;
    color.g += diff;
    color.b += diff;

    // Premultiply alpha again.
    color.rgb *= color.a;

    gl_FragColor = color;
}
`
class ay extends qt {
    constructor(t = 0.5, e = Math.random()) {
        ;(super(df, ny, { uNoise: 0, uSeed: 0 }),
            (this.noise = t),
            (this.seed = e))
    }
    get noise() {
        return this.uniforms.uNoise
    }
    set noise(t) {
        this.uniforms.uNoise = t
    }
    get seed() {
        return this.uniforms.uSeed
    }
    set seed(t) {
        this.uniforms.uSeed = t
    }
}
const Rc = {
    AlphaFilter: W_,
    BlurFilter: Z_,
    BlurFilterPass: ah,
    ColorMatrixFilter: oh,
    DisplacementFilter: ey,
    FXAAFilter: sy,
    NoiseFilter: ay,
}
Object.entries(Rc).forEach(([s, t]) => {
    Object.defineProperty(Rc, s, {
        get() {
            return (ft('7.1.0', `filters.${s} has moved to ${s}`), t)
        },
    })
})
class oy {
    constructor() {
        ;((this.interactionFrequency = 10),
            (this._deltaTime = 0),
            (this._didMove = !1),
            (this.tickerAdded = !1),
            (this._pauseUpdate = !0))
    }
    init(t) {
        ;(this.removeTickerListener(),
            (this.events = t),
            (this.interactionFrequency = 10),
            (this._deltaTime = 0),
            (this._didMove = !1),
            (this.tickerAdded = !1),
            (this._pauseUpdate = !0))
    }
    get pauseUpdate() {
        return this._pauseUpdate
    }
    set pauseUpdate(t) {
        this._pauseUpdate = t
    }
    addTickerListener() {
        this.tickerAdded ||
            !this.domElement ||
            (Yt.system.add(this.tickerUpdate, this, Qi.INTERACTION),
            (this.tickerAdded = !0))
    }
    removeTickerListener() {
        this.tickerAdded &&
            (Yt.system.remove(this.tickerUpdate, this), (this.tickerAdded = !1))
    }
    pointerMoved() {
        this._didMove = !0
    }
    update() {
        if (!this.domElement || this._pauseUpdate) return
        if (this._didMove) {
            this._didMove = !1
            return
        }
        const t = this.events.rootPointerEvent
        ;(this.events.supportsTouchEvents && t.pointerType === 'touch') ||
            globalThis.document.dispatchEvent(
                new PointerEvent('pointermove', {
                    clientX: t.clientX,
                    clientY: t.clientY,
                }),
            )
    }
    tickerUpdate(t) {
        ;((this._deltaTime += t),
            !(this._deltaTime < this.interactionFrequency) &&
                ((this._deltaTime = 0), this.update()))
    }
}
const pi = new oy()
class xs {
    constructor(t) {
        ;((this.bubbles = !0),
            (this.cancelBubble = !0),
            (this.cancelable = !1),
            (this.composed = !1),
            (this.defaultPrevented = !1),
            (this.eventPhase = xs.prototype.NONE),
            (this.propagationStopped = !1),
            (this.propagationImmediatelyStopped = !1),
            (this.layer = new ut()),
            (this.page = new ut()),
            (this.NONE = 0),
            (this.CAPTURING_PHASE = 1),
            (this.AT_TARGET = 2),
            (this.BUBBLING_PHASE = 3),
            (this.manager = t))
    }
    get layerX() {
        return this.layer.x
    }
    get layerY() {
        return this.layer.y
    }
    get pageX() {
        return this.page.x
    }
    get pageY() {
        return this.page.y
    }
    get data() {
        return this
    }
    composedPath() {
        return (
            this.manager &&
                (!this.path ||
                    this.path[this.path.length - 1] !== this.target) &&
                (this.path = this.target
                    ? this.manager.propagationPath(this.target)
                    : []),
            this.path
        )
    }
    initEvent(t, e, i) {
        throw new Error(
            'initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.',
        )
    }
    initUIEvent(t, e, i, r, n) {
        throw new Error(
            'initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.',
        )
    }
    preventDefault() {
        ;(this.nativeEvent instanceof Event &&
            this.nativeEvent.cancelable &&
            this.nativeEvent.preventDefault(),
            (this.defaultPrevented = !0))
    }
    stopImmediatePropagation() {
        this.propagationImmediatelyStopped = !0
    }
    stopPropagation() {
        this.propagationStopped = !0
    }
}
class xn extends xs {
    constructor() {
        ;(super(...arguments),
            (this.client = new ut()),
            (this.movement = new ut()),
            (this.offset = new ut()),
            (this.global = new ut()),
            (this.screen = new ut()))
    }
    get clientX() {
        return this.client.x
    }
    get clientY() {
        return this.client.y
    }
    get x() {
        return this.clientX
    }
    get y() {
        return this.clientY
    }
    get movementX() {
        return this.movement.x
    }
    get movementY() {
        return this.movement.y
    }
    get offsetX() {
        return this.offset.x
    }
    get offsetY() {
        return this.offset.y
    }
    get globalX() {
        return this.global.x
    }
    get globalY() {
        return this.global.y
    }
    get screenX() {
        return this.screen.x
    }
    get screenY() {
        return this.screen.y
    }
    getLocalPosition(t, e, i) {
        return t.worldTransform.applyInverse(i || this.global, e)
    }
    getModifierState(t) {
        return (
            'getModifierState' in this.nativeEvent &&
            this.nativeEvent.getModifierState(t)
        )
    }
    initMouseEvent(t, e, i, r, n, a, o, h, l, u, c, d, f, m, p) {
        throw new Error('Method not implemented.')
    }
}
class Te extends xn {
    constructor() {
        ;(super(...arguments),
            (this.width = 0),
            (this.height = 0),
            (this.isPrimary = !1))
    }
    getCoalescedEvents() {
        return this.type === 'pointermove' ||
            this.type === 'mousemove' ||
            this.type === 'touchmove'
            ? [this]
            : []
    }
    getPredictedEvents() {
        throw new Error('getPredictedEvents is not supported!')
    }
}
class Sr extends xn {
    constructor() {
        ;(super(...arguments),
            (this.DOM_DELTA_PIXEL = 0),
            (this.DOM_DELTA_LINE = 1),
            (this.DOM_DELTA_PAGE = 2))
    }
}
;((Sr.DOM_DELTA_PIXEL = 0), (Sr.DOM_DELTA_LINE = 1), (Sr.DOM_DELTA_PAGE = 2))
const hy = 2048,
    ly = new ut(),
    _o = new ut()
class uy {
    constructor(t) {
        ;((this.dispatch = new vs()),
            (this.moveOnAll = !1),
            (this.enableGlobalMoveEvents = !0),
            (this.mappingState = { trackingData: {} }),
            (this.eventPool = new Map()),
            (this._allInteractiveElements = []),
            (this._hitElements = []),
            (this._isPointerMoveEvent = !1),
            (this.rootTarget = t),
            (this.hitPruneFn = this.hitPruneFn.bind(this)),
            (this.hitTestFn = this.hitTestFn.bind(this)),
            (this.mapPointerDown = this.mapPointerDown.bind(this)),
            (this.mapPointerMove = this.mapPointerMove.bind(this)),
            (this.mapPointerOut = this.mapPointerOut.bind(this)),
            (this.mapPointerOver = this.mapPointerOver.bind(this)),
            (this.mapPointerUp = this.mapPointerUp.bind(this)),
            (this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this)),
            (this.mapWheel = this.mapWheel.bind(this)),
            (this.mappingTable = {}),
            this.addEventMapping('pointerdown', this.mapPointerDown),
            this.addEventMapping('pointermove', this.mapPointerMove),
            this.addEventMapping('pointerout', this.mapPointerOut),
            this.addEventMapping('pointerleave', this.mapPointerOut),
            this.addEventMapping('pointerover', this.mapPointerOver),
            this.addEventMapping('pointerup', this.mapPointerUp),
            this.addEventMapping('pointerupoutside', this.mapPointerUpOutside),
            this.addEventMapping('wheel', this.mapWheel))
    }
    addEventMapping(t, e) {
        ;(this.mappingTable[t] || (this.mappingTable[t] = []),
            this.mappingTable[t].push({ fn: e, priority: 0 }),
            this.mappingTable[t].sort((i, r) => i.priority - r.priority))
    }
    dispatchEvent(t, e) {
        ;((t.propagationStopped = !1),
            (t.propagationImmediatelyStopped = !1),
            this.propagate(t, e),
            this.dispatch.emit(e || t.type, t))
    }
    mapEvent(t) {
        if (!this.rootTarget) return
        const e = this.mappingTable[t.type]
        if (e) for (let i = 0, r = e.length; i < r; i++) e[i].fn(t)
        else
            console.warn(
                `[EventBoundary]: Event mapping not defined for ${t.type}`,
            )
    }
    hitTest(t, e) {
        pi.pauseUpdate = !0
        const i =
                this._isPointerMoveEvent && this.enableGlobalMoveEvents
                    ? 'hitTestMoveRecursive'
                    : 'hitTestRecursive',
            r = this[i](
                this.rootTarget,
                this.rootTarget.eventMode,
                ly.set(t, e),
                this.hitTestFn,
                this.hitPruneFn,
            )
        return r && r[0]
    }
    propagate(t, e) {
        if (!t.target) return
        const i = t.composedPath()
        t.eventPhase = t.CAPTURING_PHASE
        for (let r = 0, n = i.length - 1; r < n; r++)
            if (
                ((t.currentTarget = i[r]),
                this.notifyTarget(t, e),
                t.propagationStopped || t.propagationImmediatelyStopped)
            )
                return
        if (
            ((t.eventPhase = t.AT_TARGET),
            (t.currentTarget = t.target),
            this.notifyTarget(t, e),
            !(t.propagationStopped || t.propagationImmediatelyStopped))
        ) {
            t.eventPhase = t.BUBBLING_PHASE
            for (let r = i.length - 2; r >= 0; r--)
                if (
                    ((t.currentTarget = i[r]),
                    this.notifyTarget(t, e),
                    t.propagationStopped || t.propagationImmediatelyStopped)
                )
                    return
        }
    }
    all(t, e, i = this._allInteractiveElements) {
        if (i.length === 0) return
        t.eventPhase = t.BUBBLING_PHASE
        const r = Array.isArray(e) ? e : [e]
        for (let n = i.length - 1; n >= 0; n--)
            r.forEach(a => {
                ;((t.currentTarget = i[n]), this.notifyTarget(t, a))
            })
    }
    propagationPath(t) {
        const e = [t]
        for (let i = 0; i < hy && t !== this.rootTarget; i++) {
            if (!t.parent)
                throw new Error(
                    'Cannot find propagation path to disconnected target',
                )
            ;(e.push(t.parent), (t = t.parent))
        }
        return (e.reverse(), e)
    }
    hitTestMoveRecursive(t, e, i, r, n, a = !1) {
        let o = !1
        if (this._interactivePrune(t)) return null
        if (
            ((t.eventMode === 'dynamic' || e === 'dynamic') &&
                (pi.pauseUpdate = !1),
            t.interactiveChildren && t.children)
        ) {
            const u = t.children
            for (let c = u.length - 1; c >= 0; c--) {
                const d = u[c],
                    f = this.hitTestMoveRecursive(
                        d,
                        this._isInteractive(e) ? e : d.eventMode,
                        i,
                        r,
                        n,
                        a || n(t, i),
                    )
                if (f) {
                    if (f.length > 0 && !f[f.length - 1].parent) continue
                    const m = t.isInteractive()
                    ;((f.length > 0 || m) &&
                        (m && this._allInteractiveElements.push(t), f.push(t)),
                        this._hitElements.length === 0 &&
                            (this._hitElements = f),
                        (o = !0))
                }
            }
        }
        const h = this._isInteractive(e),
            l = t.isInteractive()
        return (
            h && l && this._allInteractiveElements.push(t),
            a || this._hitElements.length > 0
                ? null
                : o
                  ? this._hitElements
                  : h && !n(t, i) && r(t, i)
                    ? l
                        ? [t]
                        : []
                    : null
        )
    }
    hitTestRecursive(t, e, i, r, n) {
        if (this._interactivePrune(t) || n(t, i)) return null
        if (
            ((t.eventMode === 'dynamic' || e === 'dynamic') &&
                (pi.pauseUpdate = !1),
            t.interactiveChildren && t.children)
        ) {
            const h = t.children
            for (let l = h.length - 1; l >= 0; l--) {
                const u = h[l],
                    c = this.hitTestRecursive(
                        u,
                        this._isInteractive(e) ? e : u.eventMode,
                        i,
                        r,
                        n,
                    )
                if (c) {
                    if (c.length > 0 && !c[c.length - 1].parent) continue
                    const d = t.isInteractive()
                    return ((c.length > 0 || d) && c.push(t), c)
                }
            }
        }
        const a = this._isInteractive(e),
            o = t.isInteractive()
        return a && r(t, i) ? (o ? [t] : []) : null
    }
    _isInteractive(t) {
        return t === 'static' || t === 'dynamic'
    }
    _interactivePrune(t) {
        return !!(
            !t ||
            t.isMask ||
            !t.visible ||
            !t.renderable ||
            t.eventMode === 'none' ||
            (t.eventMode === 'passive' && !t.interactiveChildren) ||
            t.isMask
        )
    }
    hitPruneFn(t, e) {
        if (
            t.hitArea &&
            (t.worldTransform.applyInverse(e, _o),
            !t.hitArea.contains(_o.x, _o.y))
        )
            return !0
        if (t._mask) {
            const i = t._mask.isMaskData ? t._mask.maskObject : t._mask
            if (i && !i.containsPoint?.(e)) return !0
        }
        return !1
    }
    hitTestFn(t, e) {
        return t.eventMode === 'passive'
            ? !1
            : t.hitArea
              ? !0
              : t.containsPoint
                ? t.containsPoint(e)
                : !1
    }
    notifyTarget(t, e) {
        e = e ?? t.type
        const i = `on${e}`
        t.currentTarget[i]?.(t)
        const r =
            t.eventPhase === t.CAPTURING_PHASE || t.eventPhase === t.AT_TARGET
                ? `${e}capture`
                : e
        ;(this.notifyListeners(t, r),
            t.eventPhase === t.AT_TARGET && this.notifyListeners(t, e))
    }
    mapPointerDown(t) {
        if (!(t instanceof Te)) {
            console.warn(
                'EventBoundary cannot map a non-pointer event as a pointer event',
            )
            return
        }
        const e = this.createPointerEvent(t)
        if ((this.dispatchEvent(e, 'pointerdown'), e.pointerType === 'touch'))
            this.dispatchEvent(e, 'touchstart')
        else if (e.pointerType === 'mouse' || e.pointerType === 'pen') {
            const r = e.button === 2
            this.dispatchEvent(e, r ? 'rightdown' : 'mousedown')
        }
        const i = this.trackingData(t.pointerId)
        ;((i.pressTargetsByButton[t.button] = e.composedPath()),
            this.freeEvent(e))
    }
    mapPointerMove(t) {
        if (!(t instanceof Te)) {
            console.warn(
                'EventBoundary cannot map a non-pointer event as a pointer event',
            )
            return
        }
        ;((this._allInteractiveElements.length = 0),
            (this._hitElements.length = 0),
            (this._isPointerMoveEvent = !0))
        const e = this.createPointerEvent(t)
        this._isPointerMoveEvent = !1
        const i = e.pointerType === 'mouse' || e.pointerType === 'pen',
            r = this.trackingData(t.pointerId),
            n = this.findMountedTarget(r.overTargets)
        if (r.overTargets?.length > 0 && n !== e.target) {
            const h = t.type === 'mousemove' ? 'mouseout' : 'pointerout',
                l = this.createPointerEvent(t, h, n)
            if (
                (this.dispatchEvent(l, 'pointerout'),
                i && this.dispatchEvent(l, 'mouseout'),
                !e.composedPath().includes(n))
            ) {
                const u = this.createPointerEvent(t, 'pointerleave', n)
                for (
                    u.eventPhase = u.AT_TARGET;
                    u.target && !e.composedPath().includes(u.target);

                )
                    ((u.currentTarget = u.target),
                        this.notifyTarget(u),
                        i && this.notifyTarget(u, 'mouseleave'),
                        (u.target = u.target.parent))
                this.freeEvent(u)
            }
            this.freeEvent(l)
        }
        if (n !== e.target) {
            const h = t.type === 'mousemove' ? 'mouseover' : 'pointerover',
                l = this.clonePointerEvent(e, h)
            ;(this.dispatchEvent(l, 'pointerover'),
                i && this.dispatchEvent(l, 'mouseover'))
            let u = n?.parent
            for (; u && u !== this.rootTarget.parent && u !== e.target; )
                u = u.parent
            if (!u || u === this.rootTarget.parent) {
                const c = this.clonePointerEvent(e, 'pointerenter')
                for (
                    c.eventPhase = c.AT_TARGET;
                    c.target &&
                    c.target !== n &&
                    c.target !== this.rootTarget.parent;

                )
                    ((c.currentTarget = c.target),
                        this.notifyTarget(c),
                        i && this.notifyTarget(c, 'mouseenter'),
                        (c.target = c.target.parent))
                this.freeEvent(c)
            }
            this.freeEvent(l)
        }
        const a = [],
            o = this.enableGlobalMoveEvents ?? !0
        ;(this.moveOnAll
            ? a.push('pointermove')
            : this.dispatchEvent(e, 'pointermove'),
            o && a.push('globalpointermove'),
            e.pointerType === 'touch' &&
                (this.moveOnAll
                    ? a.splice(1, 0, 'touchmove')
                    : this.dispatchEvent(e, 'touchmove'),
                o && a.push('globaltouchmove')),
            i &&
                (this.moveOnAll
                    ? a.splice(1, 0, 'mousemove')
                    : this.dispatchEvent(e, 'mousemove'),
                o && a.push('globalmousemove'),
                (this.cursor = e.target?.cursor)),
            a.length > 0 && this.all(e, a),
            (this._allInteractiveElements.length = 0),
            (this._hitElements.length = 0),
            (r.overTargets = e.composedPath()),
            this.freeEvent(e))
    }
    mapPointerOver(t) {
        if (!(t instanceof Te)) {
            console.warn(
                'EventBoundary cannot map a non-pointer event as a pointer event',
            )
            return
        }
        const e = this.trackingData(t.pointerId),
            i = this.createPointerEvent(t),
            r = i.pointerType === 'mouse' || i.pointerType === 'pen'
        ;(this.dispatchEvent(i, 'pointerover'),
            r && this.dispatchEvent(i, 'mouseover'),
            i.pointerType === 'mouse' && (this.cursor = i.target?.cursor))
        const n = this.clonePointerEvent(i, 'pointerenter')
        for (
            n.eventPhase = n.AT_TARGET;
            n.target && n.target !== this.rootTarget.parent;

        )
            ((n.currentTarget = n.target),
                this.notifyTarget(n),
                r && this.notifyTarget(n, 'mouseenter'),
                (n.target = n.target.parent))
        ;((e.overTargets = i.composedPath()),
            this.freeEvent(i),
            this.freeEvent(n))
    }
    mapPointerOut(t) {
        if (!(t instanceof Te)) {
            console.warn(
                'EventBoundary cannot map a non-pointer event as a pointer event',
            )
            return
        }
        const e = this.trackingData(t.pointerId)
        if (e.overTargets) {
            const i = t.pointerType === 'mouse' || t.pointerType === 'pen',
                r = this.findMountedTarget(e.overTargets),
                n = this.createPointerEvent(t, 'pointerout', r)
            ;(this.dispatchEvent(n), i && this.dispatchEvent(n, 'mouseout'))
            const a = this.createPointerEvent(t, 'pointerleave', r)
            for (
                a.eventPhase = a.AT_TARGET;
                a.target && a.target !== this.rootTarget.parent;

            )
                ((a.currentTarget = a.target),
                    this.notifyTarget(a),
                    i && this.notifyTarget(a, 'mouseleave'),
                    (a.target = a.target.parent))
            ;((e.overTargets = null), this.freeEvent(n), this.freeEvent(a))
        }
        this.cursor = null
    }
    mapPointerUp(t) {
        if (!(t instanceof Te)) {
            console.warn(
                'EventBoundary cannot map a non-pointer event as a pointer event',
            )
            return
        }
        const e = performance.now(),
            i = this.createPointerEvent(t)
        if ((this.dispatchEvent(i, 'pointerup'), i.pointerType === 'touch'))
            this.dispatchEvent(i, 'touchend')
        else if (i.pointerType === 'mouse' || i.pointerType === 'pen') {
            const o = i.button === 2
            this.dispatchEvent(i, o ? 'rightup' : 'mouseup')
        }
        const r = this.trackingData(t.pointerId),
            n = this.findMountedTarget(r.pressTargetsByButton[t.button])
        let a = n
        if (n && !i.composedPath().includes(n)) {
            let o = n
            for (; o && !i.composedPath().includes(o); ) {
                if (
                    ((i.currentTarget = o),
                    this.notifyTarget(i, 'pointerupoutside'),
                    i.pointerType === 'touch')
                )
                    this.notifyTarget(i, 'touchendoutside')
                else if (i.pointerType === 'mouse' || i.pointerType === 'pen') {
                    const h = i.button === 2
                    this.notifyTarget(
                        i,
                        h ? 'rightupoutside' : 'mouseupoutside',
                    )
                }
                o = o.parent
            }
            ;(delete r.pressTargetsByButton[t.button], (a = o))
        }
        if (a) {
            const o = this.clonePointerEvent(i, 'click')
            ;((o.target = a),
                (o.path = null),
                r.clicksByButton[t.button] ||
                    (r.clicksByButton[t.button] = {
                        clickCount: 0,
                        target: o.target,
                        timeStamp: e,
                    }))
            const h = r.clicksByButton[t.button]
            if (
                (h.target === o.target && e - h.timeStamp < 200
                    ? ++h.clickCount
                    : (h.clickCount = 1),
                (h.target = o.target),
                (h.timeStamp = e),
                (o.detail = h.clickCount),
                o.pointerType === 'mouse')
            ) {
                const l = o.button === 2
                this.dispatchEvent(o, l ? 'rightclick' : 'click')
            } else o.pointerType === 'touch' && this.dispatchEvent(o, 'tap')
            ;(this.dispatchEvent(o, 'pointertap'), this.freeEvent(o))
        }
        this.freeEvent(i)
    }
    mapPointerUpOutside(t) {
        if (!(t instanceof Te)) {
            console.warn(
                'EventBoundary cannot map a non-pointer event as a pointer event',
            )
            return
        }
        const e = this.trackingData(t.pointerId),
            i = this.findMountedTarget(e.pressTargetsByButton[t.button]),
            r = this.createPointerEvent(t)
        if (i) {
            let n = i
            for (; n; )
                ((r.currentTarget = n),
                    this.notifyTarget(r, 'pointerupoutside'),
                    r.pointerType === 'touch'
                        ? this.notifyTarget(r, 'touchendoutside')
                        : (r.pointerType === 'mouse' ||
                              r.pointerType === 'pen') &&
                          this.notifyTarget(
                              r,
                              r.button === 2
                                  ? 'rightupoutside'
                                  : 'mouseupoutside',
                          ),
                    (n = n.parent))
            delete e.pressTargetsByButton[t.button]
        }
        this.freeEvent(r)
    }
    mapWheel(t) {
        if (!(t instanceof Sr)) {
            console.warn(
                'EventBoundary cannot map a non-wheel event as a wheel event',
            )
            return
        }
        const e = this.createWheelEvent(t)
        ;(this.dispatchEvent(e), this.freeEvent(e))
    }
    findMountedTarget(t) {
        if (!t) return null
        let e = t[0]
        for (let i = 1; i < t.length && t[i].parent === e; i++) e = t[i]
        return e
    }
    createPointerEvent(t, e, i) {
        const r = this.allocateEvent(Te)
        return (
            this.copyPointerData(t, r),
            this.copyMouseData(t, r),
            this.copyData(t, r),
            (r.nativeEvent = t.nativeEvent),
            (r.originalEvent = t),
            (r.target =
                i ??
                this.hitTest(r.global.x, r.global.y) ??
                this._hitElements[0]),
            typeof e == 'string' && (r.type = e),
            r
        )
    }
    createWheelEvent(t) {
        const e = this.allocateEvent(Sr)
        return (
            this.copyWheelData(t, e),
            this.copyMouseData(t, e),
            this.copyData(t, e),
            (e.nativeEvent = t.nativeEvent),
            (e.originalEvent = t),
            (e.target = this.hitTest(e.global.x, e.global.y)),
            e
        )
    }
    clonePointerEvent(t, e) {
        const i = this.allocateEvent(Te)
        return (
            (i.nativeEvent = t.nativeEvent),
            (i.originalEvent = t.originalEvent),
            this.copyPointerData(t, i),
            this.copyMouseData(t, i),
            this.copyData(t, i),
            (i.target = t.target),
            (i.path = t.composedPath().slice()),
            (i.type = e ?? i.type),
            i
        )
    }
    copyWheelData(t, e) {
        ;((e.deltaMode = t.deltaMode),
            (e.deltaX = t.deltaX),
            (e.deltaY = t.deltaY),
            (e.deltaZ = t.deltaZ))
    }
    copyPointerData(t, e) {
        t instanceof Te &&
            e instanceof Te &&
            ((e.pointerId = t.pointerId),
            (e.width = t.width),
            (e.height = t.height),
            (e.isPrimary = t.isPrimary),
            (e.pointerType = t.pointerType),
            (e.pressure = t.pressure),
            (e.tangentialPressure = t.tangentialPressure),
            (e.tiltX = t.tiltX),
            (e.tiltY = t.tiltY),
            (e.twist = t.twist))
    }
    copyMouseData(t, e) {
        t instanceof xn &&
            e instanceof xn &&
            ((e.altKey = t.altKey),
            (e.button = t.button),
            (e.buttons = t.buttons),
            e.client.copyFrom(t.client),
            (e.ctrlKey = t.ctrlKey),
            (e.metaKey = t.metaKey),
            e.movement.copyFrom(t.movement),
            e.screen.copyFrom(t.screen),
            (e.shiftKey = t.shiftKey),
            e.global.copyFrom(t.global))
    }
    copyData(t, e) {
        ;((e.isTrusted = t.isTrusted),
            (e.srcElement = t.srcElement),
            (e.timeStamp = performance.now()),
            (e.type = t.type),
            (e.detail = t.detail),
            (e.view = t.view),
            (e.which = t.which),
            e.layer.copyFrom(t.layer),
            e.page.copyFrom(t.page))
    }
    trackingData(t) {
        return (
            this.mappingState.trackingData[t] ||
                (this.mappingState.trackingData[t] = {
                    pressTargetsByButton: {},
                    clicksByButton: {},
                    overTarget: null,
                }),
            this.mappingState.trackingData[t]
        )
    }
    allocateEvent(t) {
        this.eventPool.has(t) || this.eventPool.set(t, [])
        const e = this.eventPool.get(t).pop() || new t(this)
        return (
            (e.eventPhase = e.NONE),
            (e.currentTarget = null),
            (e.path = null),
            (e.target = null),
            e
        )
    }
    freeEvent(t) {
        if (t.manager !== this)
            throw new Error(
                'It is illegal to free an event not managed by this EventBoundary!',
            )
        const e = t.constructor
        ;(this.eventPool.has(e) || this.eventPool.set(e, []),
            this.eventPool.get(e).push(t))
    }
    notifyListeners(t, e) {
        const i = t.currentTarget._events[e]
        if (i && t.currentTarget.isInteractive())
            if ('fn' in i)
                (i.once && t.currentTarget.removeListener(e, i.fn, void 0, !0),
                    i.fn.call(i.context, t))
            else
                for (
                    let r = 0, n = i.length;
                    r < n && !t.propagationImmediatelyStopped;
                    r++
                )
                    (i[r].once &&
                        t.currentTarget.removeListener(e, i[r].fn, void 0, !0),
                        i[r].fn.call(i[r].context, t))
    }
}
const cy = 1,
    dy = {
        touchstart: 'pointerdown',
        touchend: 'pointerup',
        touchendoutside: 'pointerupoutside',
        touchmove: 'pointermove',
        touchcancel: 'pointercancel',
    },
    hh = class lh {
        constructor(t) {
            ;((this.supportsTouchEvents = 'ontouchstart' in globalThis),
                (this.supportsPointerEvents = !!globalThis.PointerEvent),
                (this.domElement = null),
                (this.resolution = 1),
                (this.renderer = t),
                (this.rootBoundary = new uy(null)),
                pi.init(this),
                (this.autoPreventDefault = !0),
                (this.eventsAdded = !1),
                (this.rootPointerEvent = new Te(null)),
                (this.rootWheelEvent = new Sr(null)),
                (this.cursorStyles = {
                    default: 'inherit',
                    pointer: 'pointer',
                }),
                (this.features = new Proxy(
                    { ...lh.defaultEventFeatures },
                    {
                        set: (e, i, r) => (
                            i === 'globalMove' &&
                                (this.rootBoundary.enableGlobalMoveEvents = r),
                            (e[i] = r),
                            !0
                        ),
                    },
                )),
                (this.onPointerDown = this.onPointerDown.bind(this)),
                (this.onPointerMove = this.onPointerMove.bind(this)),
                (this.onPointerUp = this.onPointerUp.bind(this)),
                (this.onPointerOverOut = this.onPointerOverOut.bind(this)),
                (this.onWheel = this.onWheel.bind(this)))
        }
        static get defaultEventMode() {
            return this._defaultEventMode
        }
        init(t) {
            const { view: e, resolution: i } = this.renderer
            ;(this.setTargetElement(e),
                (this.resolution = i),
                (lh._defaultEventMode = t.eventMode ?? 'auto'),
                Object.assign(this.features, t.eventFeatures ?? {}),
                (this.rootBoundary.enableGlobalMoveEvents =
                    this.features.globalMove))
        }
        resolutionChange(t) {
            this.resolution = t
        }
        destroy() {
            ;(this.setTargetElement(null), (this.renderer = null))
        }
        setCursor(t) {
            t = t || 'default'
            let e = !0
            if (
                (globalThis.OffscreenCanvas &&
                    this.domElement instanceof OffscreenCanvas &&
                    (e = !1),
                this.currentCursor === t)
            )
                return
            this.currentCursor = t
            const i = this.cursorStyles[t]
            if (i)
                switch (typeof i) {
                    case 'string':
                        e && (this.domElement.style.cursor = i)
                        break
                    case 'function':
                        i(t)
                        break
                    case 'object':
                        e && Object.assign(this.domElement.style, i)
                        break
                }
            else
                e &&
                    typeof t == 'string' &&
                    !Object.prototype.hasOwnProperty.call(
                        this.cursorStyles,
                        t,
                    ) &&
                    (this.domElement.style.cursor = t)
        }
        get pointer() {
            return this.rootPointerEvent
        }
        onPointerDown(t) {
            if (!this.features.click) return
            this.rootBoundary.rootTarget = this.renderer.lastObjectRendered
            const e = this.normalizeToPointerData(t)
            this.autoPreventDefault &&
                e[0].isNormalized &&
                (t.cancelable || !('cancelable' in t)) &&
                t.preventDefault()
            for (let i = 0, r = e.length; i < r; i++) {
                const n = e[i],
                    a = this.bootstrapEvent(this.rootPointerEvent, n)
                this.rootBoundary.mapEvent(a)
            }
            this.setCursor(this.rootBoundary.cursor)
        }
        onPointerMove(t) {
            if (!this.features.move) return
            ;((this.rootBoundary.rootTarget = this.renderer.lastObjectRendered),
                pi.pointerMoved())
            const e = this.normalizeToPointerData(t)
            for (let i = 0, r = e.length; i < r; i++) {
                const n = this.bootstrapEvent(this.rootPointerEvent, e[i])
                this.rootBoundary.mapEvent(n)
            }
            this.setCursor(this.rootBoundary.cursor)
        }
        onPointerUp(t) {
            if (!this.features.click) return
            this.rootBoundary.rootTarget = this.renderer.lastObjectRendered
            let e = t.target
            t.composedPath &&
                t.composedPath().length > 0 &&
                (e = t.composedPath()[0])
            const i = e !== this.domElement ? 'outside' : '',
                r = this.normalizeToPointerData(t)
            for (let n = 0, a = r.length; n < a; n++) {
                const o = this.bootstrapEvent(this.rootPointerEvent, r[n])
                ;((o.type += i), this.rootBoundary.mapEvent(o))
            }
            this.setCursor(this.rootBoundary.cursor)
        }
        onPointerOverOut(t) {
            if (!this.features.click) return
            this.rootBoundary.rootTarget = this.renderer.lastObjectRendered
            const e = this.normalizeToPointerData(t)
            for (let i = 0, r = e.length; i < r; i++) {
                const n = this.bootstrapEvent(this.rootPointerEvent, e[i])
                this.rootBoundary.mapEvent(n)
            }
            this.setCursor(this.rootBoundary.cursor)
        }
        onWheel(t) {
            if (!this.features.wheel) return
            const e = this.normalizeWheelEvent(t)
            ;((this.rootBoundary.rootTarget = this.renderer.lastObjectRendered),
                this.rootBoundary.mapEvent(e))
        }
        setTargetElement(t) {
            ;(this.removeEvents(),
                (this.domElement = t),
                (pi.domElement = t),
                this.addEvents())
        }
        addEvents() {
            if (this.eventsAdded || !this.domElement) return
            pi.addTickerListener()
            const t = this.domElement.style
            ;(t &&
                (globalThis.navigator.msPointerEnabled
                    ? ((t.msContentZooming = 'none'),
                      (t.msTouchAction = 'none'))
                    : this.supportsPointerEvents && (t.touchAction = 'none')),
                this.supportsPointerEvents
                    ? (globalThis.document.addEventListener(
                          'pointermove',
                          this.onPointerMove,
                          !0,
                      ),
                      this.domElement.addEventListener(
                          'pointerdown',
                          this.onPointerDown,
                          !0,
                      ),
                      this.domElement.addEventListener(
                          'pointerleave',
                          this.onPointerOverOut,
                          !0,
                      ),
                      this.domElement.addEventListener(
                          'pointerover',
                          this.onPointerOverOut,
                          !0,
                      ),
                      globalThis.addEventListener(
                          'pointerup',
                          this.onPointerUp,
                          !0,
                      ))
                    : (globalThis.document.addEventListener(
                          'mousemove',
                          this.onPointerMove,
                          !0,
                      ),
                      this.domElement.addEventListener(
                          'mousedown',
                          this.onPointerDown,
                          !0,
                      ),
                      this.domElement.addEventListener(
                          'mouseout',
                          this.onPointerOverOut,
                          !0,
                      ),
                      this.domElement.addEventListener(
                          'mouseover',
                          this.onPointerOverOut,
                          !0,
                      ),
                      globalThis.addEventListener(
                          'mouseup',
                          this.onPointerUp,
                          !0,
                      ),
                      this.supportsTouchEvents &&
                          (this.domElement.addEventListener(
                              'touchstart',
                              this.onPointerDown,
                              !0,
                          ),
                          this.domElement.addEventListener(
                              'touchend',
                              this.onPointerUp,
                              !0,
                          ),
                          this.domElement.addEventListener(
                              'touchmove',
                              this.onPointerMove,
                              !0,
                          ))),
                this.domElement.addEventListener('wheel', this.onWheel, {
                    passive: !0,
                    capture: !0,
                }),
                (this.eventsAdded = !0))
        }
        removeEvents() {
            if (!this.eventsAdded || !this.domElement) return
            pi.removeTickerListener()
            const t = this.domElement.style
            ;(globalThis.navigator.msPointerEnabled
                ? ((t.msContentZooming = ''), (t.msTouchAction = ''))
                : this.supportsPointerEvents && (t.touchAction = ''),
                this.supportsPointerEvents
                    ? (globalThis.document.removeEventListener(
                          'pointermove',
                          this.onPointerMove,
                          !0,
                      ),
                      this.domElement.removeEventListener(
                          'pointerdown',
                          this.onPointerDown,
                          !0,
                      ),
                      this.domElement.removeEventListener(
                          'pointerleave',
                          this.onPointerOverOut,
                          !0,
                      ),
                      this.domElement.removeEventListener(
                          'pointerover',
                          this.onPointerOverOut,
                          !0,
                      ),
                      globalThis.removeEventListener(
                          'pointerup',
                          this.onPointerUp,
                          !0,
                      ))
                    : (globalThis.document.removeEventListener(
                          'mousemove',
                          this.onPointerMove,
                          !0,
                      ),
                      this.domElement.removeEventListener(
                          'mousedown',
                          this.onPointerDown,
                          !0,
                      ),
                      this.domElement.removeEventListener(
                          'mouseout',
                          this.onPointerOverOut,
                          !0,
                      ),
                      this.domElement.removeEventListener(
                          'mouseover',
                          this.onPointerOverOut,
                          !0,
                      ),
                      globalThis.removeEventListener(
                          'mouseup',
                          this.onPointerUp,
                          !0,
                      ),
                      this.supportsTouchEvents &&
                          (this.domElement.removeEventListener(
                              'touchstart',
                              this.onPointerDown,
                              !0,
                          ),
                          this.domElement.removeEventListener(
                              'touchend',
                              this.onPointerUp,
                              !0,
                          ),
                          this.domElement.removeEventListener(
                              'touchmove',
                              this.onPointerMove,
                              !0,
                          ))),
                this.domElement.removeEventListener('wheel', this.onWheel, !0),
                (this.domElement = null),
                (this.eventsAdded = !1))
        }
        mapPositionToPoint(t, e, i) {
            const r = this.domElement.isConnected
                    ? this.domElement.getBoundingClientRect()
                    : {
                          width: this.domElement.width,
                          height: this.domElement.height,
                          left: 0,
                          top: 0,
                      },
                n = 1 / this.resolution
            ;((t.x = (e - r.left) * (this.domElement.width / r.width) * n),
                (t.y = (i - r.top) * (this.domElement.height / r.height) * n))
        }
        normalizeToPointerData(t) {
            const e = []
            if (this.supportsTouchEvents && t instanceof TouchEvent)
                for (let i = 0, r = t.changedTouches.length; i < r; i++) {
                    const n = t.changedTouches[i]
                    ;(typeof n.button > 'u' && (n.button = 0),
                        typeof n.buttons > 'u' && (n.buttons = 1),
                        typeof n.isPrimary > 'u' &&
                            (n.isPrimary =
                                t.touches.length === 1 &&
                                t.type === 'touchstart'),
                        typeof n.width > 'u' && (n.width = n.radiusX || 1),
                        typeof n.height > 'u' && (n.height = n.radiusY || 1),
                        typeof n.tiltX > 'u' && (n.tiltX = 0),
                        typeof n.tiltY > 'u' && (n.tiltY = 0),
                        typeof n.pointerType > 'u' && (n.pointerType = 'touch'),
                        typeof n.pointerId > 'u' &&
                            (n.pointerId = n.identifier || 0),
                        typeof n.pressure > 'u' &&
                            (n.pressure = n.force || 0.5),
                        typeof n.twist > 'u' && (n.twist = 0),
                        typeof n.tangentialPressure > 'u' &&
                            (n.tangentialPressure = 0),
                        typeof n.layerX > 'u' &&
                            (n.layerX = n.offsetX = n.clientX),
                        typeof n.layerY > 'u' &&
                            (n.layerY = n.offsetY = n.clientY),
                        (n.isNormalized = !0),
                        (n.type = t.type),
                        e.push(n))
                }
            else if (
                !globalThis.MouseEvent ||
                (t instanceof MouseEvent &&
                    (!this.supportsPointerEvents ||
                        !(t instanceof globalThis.PointerEvent)))
            ) {
                const i = t
                ;(typeof i.isPrimary > 'u' && (i.isPrimary = !0),
                    typeof i.width > 'u' && (i.width = 1),
                    typeof i.height > 'u' && (i.height = 1),
                    typeof i.tiltX > 'u' && (i.tiltX = 0),
                    typeof i.tiltY > 'u' && (i.tiltY = 0),
                    typeof i.pointerType > 'u' && (i.pointerType = 'mouse'),
                    typeof i.pointerId > 'u' && (i.pointerId = cy),
                    typeof i.pressure > 'u' && (i.pressure = 0.5),
                    typeof i.twist > 'u' && (i.twist = 0),
                    typeof i.tangentialPressure > 'u' &&
                        (i.tangentialPressure = 0),
                    (i.isNormalized = !0),
                    e.push(i))
            } else e.push(t)
            return e
        }
        normalizeWheelEvent(t) {
            const e = this.rootWheelEvent
            return (
                this.transferMouseData(e, t),
                (e.deltaX = t.deltaX),
                (e.deltaY = t.deltaY),
                (e.deltaZ = t.deltaZ),
                (e.deltaMode = t.deltaMode),
                this.mapPositionToPoint(e.screen, t.clientX, t.clientY),
                e.global.copyFrom(e.screen),
                e.offset.copyFrom(e.screen),
                (e.nativeEvent = t),
                (e.type = t.type),
                e
            )
        }
        bootstrapEvent(t, e) {
            return (
                (t.originalEvent = null),
                (t.nativeEvent = e),
                (t.pointerId = e.pointerId),
                (t.width = e.width),
                (t.height = e.height),
                (t.isPrimary = e.isPrimary),
                (t.pointerType = e.pointerType),
                (t.pressure = e.pressure),
                (t.tangentialPressure = e.tangentialPressure),
                (t.tiltX = e.tiltX),
                (t.tiltY = e.tiltY),
                (t.twist = e.twist),
                this.transferMouseData(t, e),
                this.mapPositionToPoint(t.screen, e.clientX, e.clientY),
                t.global.copyFrom(t.screen),
                t.offset.copyFrom(t.screen),
                (t.isTrusted = e.isTrusted),
                t.type === 'pointerleave' && (t.type = 'pointerout'),
                t.type.startsWith('mouse') &&
                    (t.type = t.type.replace('mouse', 'pointer')),
                t.type.startsWith('touch') && (t.type = dy[t.type] || t.type),
                t
            )
        }
        transferMouseData(t, e) {
            ;((t.isTrusted = e.isTrusted),
                (t.srcElement = e.srcElement),
                (t.timeStamp = performance.now()),
                (t.type = e.type),
                (t.altKey = e.altKey),
                (t.button = e.button),
                (t.buttons = e.buttons),
                (t.client.x = e.clientX),
                (t.client.y = e.clientY),
                (t.ctrlKey = e.ctrlKey),
                (t.metaKey = e.metaKey),
                (t.movement.x = e.movementX),
                (t.movement.y = e.movementY),
                (t.page.x = e.pageX),
                (t.page.y = e.pageY),
                (t.relatedTarget = null),
                (t.shiftKey = e.shiftKey))
        }
    }
;((hh.extension = {
    name: 'events',
    type: [$.RendererSystem, $.CanvasRendererSystem],
}),
    (hh.defaultEventFeatures = {
        move: !0,
        globalMove: !0,
        click: !0,
        wheel: !0,
    }))
let uh = hh
Q.add(uh)
function Ic(s) {
    return s === 'dynamic' || s === 'static'
}
const fy = {
    onclick: null,
    onmousedown: null,
    onmouseenter: null,
    onmouseleave: null,
    onmousemove: null,
    onglobalmousemove: null,
    onmouseout: null,
    onmouseover: null,
    onmouseup: null,
    onmouseupoutside: null,
    onpointercancel: null,
    onpointerdown: null,
    onpointerenter: null,
    onpointerleave: null,
    onpointermove: null,
    onglobalpointermove: null,
    onpointerout: null,
    onpointerover: null,
    onpointertap: null,
    onpointerup: null,
    onpointerupoutside: null,
    onrightclick: null,
    onrightdown: null,
    onrightup: null,
    onrightupoutside: null,
    ontap: null,
    ontouchcancel: null,
    ontouchend: null,
    ontouchendoutside: null,
    ontouchmove: null,
    onglobaltouchmove: null,
    ontouchstart: null,
    onwheel: null,
    _internalInteractive: void 0,
    get interactive() {
        return this._internalInteractive ?? Ic(uh.defaultEventMode)
    },
    set interactive(s) {
        ;(ft(
            '7.2.0',
            "Setting interactive is deprecated, use eventMode = 'none'/'passive'/'auto'/'static'/'dynamic' instead.",
        ),
            (this._internalInteractive = s),
            (this.eventMode = s ? 'static' : 'auto'))
    },
    _internalEventMode: void 0,
    get eventMode() {
        return this._internalEventMode ?? uh.defaultEventMode
    },
    set eventMode(s) {
        ;((this._internalInteractive = Ic(s)), (this._internalEventMode = s))
    },
    isInteractive() {
        return this.eventMode === 'static' || this.eventMode === 'dynamic'
    },
    interactiveChildren: !0,
    hitArea: null,
    addEventListener(s, t, e) {
        const i =
                (typeof e == 'boolean' && e) ||
                (typeof e == 'object' && e.capture),
            r = typeof e == 'object' ? e.signal : void 0,
            n = typeof e == 'object' ? e.once === !0 : !1,
            a = typeof t == 'function' ? void 0 : t
        s = i ? `${s}capture` : s
        const o = typeof t == 'function' ? t : t.handleEvent,
            h = this
        ;(r &&
            r.addEventListener('abort', () => {
                h.off(s, o, a)
            }),
            n ? h.once(s, o, a) : h.on(s, o, a))
    },
    removeEventListener(s, t, e) {
        const i =
                (typeof e == 'boolean' && e) ||
                (typeof e == 'object' && e.capture),
            r = typeof t == 'function' ? void 0 : t
        ;((s = i ? `${s}capture` : s),
            (t = typeof t == 'function' ? t : t.handleEvent),
            this.off(s, t, r))
    },
    dispatchEvent(s) {
        if (!(s instanceof xs))
            throw new Error(
                'DisplayObject cannot propagate events outside of the Federated Events API',
            )
        return (
            (s.defaultPrevented = !1),
            (s.path = null),
            (s.target = this),
            s.manager.dispatchEvent(s),
            !s.defaultPrevented
        )
    },
}
Rt.mixin(fy)
const py = {
    accessible: !1,
    accessibleTitle: null,
    accessibleHint: null,
    tabIndex: 0,
    _accessibleActive: !1,
    _accessibleDiv: null,
    accessibleType: 'button',
    accessiblePointerEvents: 'auto',
    accessibleChildren: !0,
    renderId: -1,
}
Rt.mixin(py)
const my = 9,
    Gs = 100,
    gy = 0,
    _y = 0,
    Mc = 2,
    Dc = 1,
    yy = -1e3,
    vy = -1e3,
    xy = 2
class wf {
    constructor(t) {
        ;((this.debug = !1),
            (this._isActive = !1),
            (this._isMobileAccessibility = !1),
            (this.pool = []),
            (this.renderId = 0),
            (this.children = []),
            (this.androidUpdateCount = 0),
            (this.androidUpdateFrequency = 500),
            (this._hookDiv = null),
            (Qe.tablet || Qe.phone) && this.createTouchHook())
        const e = document.createElement('div')
        ;((e.style.width = `${Gs}px`),
            (e.style.height = `${Gs}px`),
            (e.style.position = 'absolute'),
            (e.style.top = `${gy}px`),
            (e.style.left = `${_y}px`),
            (e.style.zIndex = Mc.toString()),
            (this.div = e),
            (this.renderer = t),
            (this._onKeyDown = this._onKeyDown.bind(this)),
            (this._onMouseMove = this._onMouseMove.bind(this)),
            globalThis.addEventListener('keydown', this._onKeyDown, !1))
    }
    get isActive() {
        return this._isActive
    }
    get isMobileAccessibility() {
        return this._isMobileAccessibility
    }
    createTouchHook() {
        const t = document.createElement('button')
        ;((t.style.width = `${Dc}px`),
            (t.style.height = `${Dc}px`),
            (t.style.position = 'absolute'),
            (t.style.top = `${yy}px`),
            (t.style.left = `${vy}px`),
            (t.style.zIndex = xy.toString()),
            (t.style.backgroundColor = '#FF0000'),
            (t.title = 'select to enable accessibility for this content'),
            t.addEventListener('focus', () => {
                ;((this._isMobileAccessibility = !0),
                    this.activate(),
                    this.destroyTouchHook())
            }),
            document.body.appendChild(t),
            (this._hookDiv = t))
    }
    destroyTouchHook() {
        this._hookDiv &&
            (document.body.removeChild(this._hookDiv), (this._hookDiv = null))
    }
    activate() {
        this._isActive ||
            ((this._isActive = !0),
            globalThis.document.addEventListener(
                'mousemove',
                this._onMouseMove,
                !0,
            ),
            globalThis.removeEventListener('keydown', this._onKeyDown, !1),
            this.renderer.on('postrender', this.update, this),
            this.renderer.view.parentNode?.appendChild(this.div))
    }
    deactivate() {
        !this._isActive ||
            this._isMobileAccessibility ||
            ((this._isActive = !1),
            globalThis.document.removeEventListener(
                'mousemove',
                this._onMouseMove,
                !0,
            ),
            globalThis.addEventListener('keydown', this._onKeyDown, !1),
            this.renderer.off('postrender', this.update),
            this.div.parentNode?.removeChild(this.div))
    }
    updateAccessibleObjects(t) {
        if (!t.visible || !t.accessibleChildren) return
        t.accessible &&
            t.isInteractive() &&
            (t._accessibleActive || this.addChild(t),
            (t.renderId = this.renderId))
        const e = t.children
        if (e)
            for (let i = 0; i < e.length; i++)
                this.updateAccessibleObjects(e[i])
    }
    update() {
        const t = performance.now()
        if (
            (Qe.android.device && t < this.androidUpdateCount) ||
            ((this.androidUpdateCount = t + this.androidUpdateFrequency),
            !this.renderer.renderingToScreen)
        )
            return
        this.renderer.lastObjectRendered &&
            this.updateAccessibleObjects(this.renderer.lastObjectRendered)
        const {
                x: e,
                y: i,
                width: r,
                height: n,
            } = this.renderer.view.getBoundingClientRect(),
            { width: a, height: o, resolution: h } = this.renderer,
            l = (r / a) * h,
            u = (n / o) * h
        let c = this.div
        ;((c.style.left = `${e}px`),
            (c.style.top = `${i}px`),
            (c.style.width = `${a}px`),
            (c.style.height = `${o}px`))
        for (let d = 0; d < this.children.length; d++) {
            const f = this.children[d]
            if (f.renderId !== this.renderId)
                ((f._accessibleActive = !1),
                    Er(this.children, d, 1),
                    this.div.removeChild(f._accessibleDiv),
                    this.pool.push(f._accessibleDiv),
                    (f._accessibleDiv = null),
                    d--)
            else {
                c = f._accessibleDiv
                let m = f.hitArea
                const p = f.worldTransform
                ;(f.hitArea
                    ? ((c.style.left = `${(p.tx + m.x * p.a) * l}px`),
                      (c.style.top = `${(p.ty + m.y * p.d) * u}px`),
                      (c.style.width = `${m.width * p.a * l}px`),
                      (c.style.height = `${m.height * p.d * u}px`))
                    : ((m = f.getBounds()),
                      this.capHitArea(m),
                      (c.style.left = `${m.x * l}px`),
                      (c.style.top = `${m.y * u}px`),
                      (c.style.width = `${m.width * l}px`),
                      (c.style.height = `${m.height * u}px`),
                      c.title !== f.accessibleTitle &&
                          f.accessibleTitle !== null &&
                          (c.title = f.accessibleTitle),
                      c.getAttribute('aria-label') !== f.accessibleHint &&
                          f.accessibleHint !== null &&
                          c.setAttribute('aria-label', f.accessibleHint)),
                    (f.accessibleTitle !== c.title ||
                        f.tabIndex !== c.tabIndex) &&
                        ((c.title = f.accessibleTitle),
                        (c.tabIndex = f.tabIndex),
                        this.debug && this.updateDebugHTML(c)))
            }
        }
        this.renderId++
    }
    updateDebugHTML(t) {
        t.innerHTML = `type: ${t.type}</br> title : ${t.title}</br> tabIndex: ${t.tabIndex}`
    }
    capHitArea(t) {
        ;(t.x < 0 && ((t.width += t.x), (t.x = 0)),
            t.y < 0 && ((t.height += t.y), (t.y = 0)))
        const { width: e, height: i } = this.renderer
        ;(t.x + t.width > e && (t.width = e - t.x),
            t.y + t.height > i && (t.height = i - t.y))
    }
    addChild(t) {
        let e = this.pool.pop()
        ;(e ||
            ((e = document.createElement('button')),
            (e.style.width = `${Gs}px`),
            (e.style.height = `${Gs}px`),
            (e.style.backgroundColor = this.debug
                ? 'rgba(255,255,255,0.5)'
                : 'transparent'),
            (e.style.position = 'absolute'),
            (e.style.zIndex = Mc.toString()),
            (e.style.borderStyle = 'none'),
            navigator.userAgent.toLowerCase().includes('chrome')
                ? e.setAttribute('aria-live', 'off')
                : e.setAttribute('aria-live', 'polite'),
            navigator.userAgent.match(/rv:.*Gecko\//)
                ? e.setAttribute('aria-relevant', 'additions')
                : e.setAttribute('aria-relevant', 'text'),
            e.addEventListener('click', this._onClick.bind(this)),
            e.addEventListener('focus', this._onFocus.bind(this)),
            e.addEventListener('focusout', this._onFocusOut.bind(this))),
            (e.style.pointerEvents = t.accessiblePointerEvents),
            (e.type = t.accessibleType),
            t.accessibleTitle && t.accessibleTitle !== null
                ? (e.title = t.accessibleTitle)
                : (!t.accessibleHint || t.accessibleHint === null) &&
                  (e.title = `displayObject ${t.tabIndex}`),
            t.accessibleHint &&
                t.accessibleHint !== null &&
                e.setAttribute('aria-label', t.accessibleHint),
            this.debug && this.updateDebugHTML(e),
            (t._accessibleActive = !0),
            (t._accessibleDiv = e),
            (e.displayObject = t),
            this.children.push(t),
            this.div.appendChild(t._accessibleDiv),
            (t._accessibleDiv.tabIndex = t.tabIndex))
    }
    _dispatchEvent(t, e) {
        const { displayObject: i } = t.target,
            r = this.renderer.events.rootBoundary,
            n = Object.assign(new xs(r), { target: i })
        ;((r.rootTarget = this.renderer.lastObjectRendered),
            e.forEach(a => r.dispatchEvent(n, a)))
    }
    _onClick(t) {
        this._dispatchEvent(t, ['click', 'pointertap', 'tap'])
    }
    _onFocus(t) {
        ;(t.target.getAttribute('aria-live') ||
            t.target.setAttribute('aria-live', 'assertive'),
            this._dispatchEvent(t, ['mouseover']))
    }
    _onFocusOut(t) {
        ;(t.target.getAttribute('aria-live') ||
            t.target.setAttribute('aria-live', 'polite'),
            this._dispatchEvent(t, ['mouseout']))
    }
    _onKeyDown(t) {
        t.keyCode === my && this.activate()
    }
    _onMouseMove(t) {
        ;(t.movementX === 0 && t.movementY === 0) || this.deactivate()
    }
    destroy() {
        ;(this.destroyTouchHook(),
            (this.div = null),
            globalThis.document.removeEventListener(
                'mousemove',
                this._onMouseMove,
                !0,
            ),
            globalThis.removeEventListener('keydown', this._onKeyDown),
            (this.pool = null),
            (this.children = null),
            (this.renderer = null))
    }
}
wf.extension = {
    name: 'accessibility',
    type: [$.RendererPlugin, $.CanvasRendererPlugin],
}
Q.add(wf)
const Tf = class ch {
    constructor(t) {
        ;((this.stage = new Kt()),
            (t = Object.assign({ forceCanvas: !1 }, t)),
            (this.renderer = I_(t)),
            ch._plugins.forEach(e => {
                e.init.call(this, t)
            }))
    }
    render() {
        this.renderer.render(this.stage)
    }
    get view() {
        return this.renderer?.view
    }
    get screen() {
        return this.renderer?.screen
    }
    destroy(t, e) {
        const i = ch._plugins.slice(0)
        ;(i.reverse(),
            i.forEach(r => {
                r.destroy.call(this)
            }),
            this.stage.destroy(e),
            (this.stage = null),
            this.renderer.destroy(t),
            (this.renderer = null))
    }
}
Tf._plugins = []
let Ef = Tf
Q.handleByList($.Application, Ef._plugins)
class Af {
    static init(t) {
        ;(Object.defineProperty(this, 'resizeTo', {
            set(e) {
                ;(globalThis.removeEventListener('resize', this.queueResize),
                    (this._resizeTo = e),
                    e &&
                        (globalThis.addEventListener(
                            'resize',
                            this.queueResize,
                        ),
                        this.resize()))
            },
            get() {
                return this._resizeTo
            },
        }),
            (this.queueResize = () => {
                this._resizeTo &&
                    (this.cancelResize(),
                    (this._resizeId = requestAnimationFrame(() =>
                        this.resize(),
                    )))
            }),
            (this.cancelResize = () => {
                this._resizeId &&
                    (cancelAnimationFrame(this._resizeId),
                    (this._resizeId = null))
            }),
            (this.resize = () => {
                if (!this._resizeTo) return
                this.cancelResize()
                let e, i
                if (this._resizeTo === globalThis.window)
                    ((e = globalThis.innerWidth), (i = globalThis.innerHeight))
                else {
                    const { clientWidth: r, clientHeight: n } = this._resizeTo
                    ;((e = r), (i = n))
                }
                ;(this.renderer.resize(e, i), this.render())
            }),
            (this._resizeId = null),
            (this._resizeTo = null),
            (this.resizeTo = t.resizeTo || null))
    }
    static destroy() {
        ;(globalThis.removeEventListener('resize', this.queueResize),
            this.cancelResize(),
            (this.cancelResize = null),
            (this.queueResize = null),
            (this.resizeTo = null),
            (this.resize = null))
    }
}
Af.extension = $.Application
Q.add(Af)
const Bc = {
    loader: $.LoadParser,
    resolver: $.ResolveParser,
    cache: $.CacheParser,
    detection: $.DetectionParser,
}
Q.handle(
    $.Asset,
    s => {
        const t = s.ref
        Object.entries(Bc)
            .filter(([e]) => !!t[e])
            .forEach(([e, i]) =>
                Q.add(Object.assign(t[e], { extension: t[e].extension ?? i })),
            )
    },
    s => {
        const t = s.ref
        Object.keys(Bc)
            .filter(e => !!t[e])
            .forEach(e => Q.remove(t[e]))
    },
)
class by {
    constructor(t, e = !1) {
        ;((this._loader = t),
            (this._assetList = []),
            (this._isLoading = !1),
            (this._maxConcurrent = 1),
            (this.verbose = e))
    }
    add(t) {
        ;(t.forEach(e => {
            this._assetList.push(e)
        }),
            this.verbose &&
                console.log('[BackgroundLoader] assets: ', this._assetList),
            this._isActive && !this._isLoading && this._next())
    }
    async _next() {
        if (this._assetList.length && this._isActive) {
            this._isLoading = !0
            const t = [],
                e = Math.min(this._assetList.length, this._maxConcurrent)
            for (let i = 0; i < e; i++) t.push(this._assetList.pop())
            ;(await this._loader.load(t), (this._isLoading = !1), this._next())
        }
    }
    get active() {
        return this._isActive
    }
    set active(t) {
        this._isActive !== t &&
            ((this._isActive = t), t && !this._isLoading && this._next())
    }
}
function Hr(s, t) {
    if (Array.isArray(t)) {
        for (const e of t) if (s.startsWith(`data:${e}`)) return !0
        return !1
    }
    return s.startsWith(`data:${t}`)
}
function Si(s, t) {
    const e = s.split('?')[0],
        i = Gt.extname(e).toLowerCase()
    return Array.isArray(t) ? t.includes(i) : i === t
}
const Ee = (s, t, e = !1) => (
        Array.isArray(s) || (s = [s]),
        t ? s.map(i => (typeof i == 'string' || e ? t(i) : i)) : s
    ),
    dh = (s, t) => {
        const e = t.split('?')[1]
        return (e && (s += `?${e}`), s)
    }
function Sf(s, t, e, i, r) {
    const n = t[e]
    for (let a = 0; a < n.length; a++) {
        const o = n[a]
        e < t.length - 1
            ? Sf(s.replace(i[e], o), t, e + 1, i, r)
            : r.push(s.replace(i[e], o))
    }
}
function wy(s) {
    const t = /\{(.*?)\}/g,
        e = s.match(t),
        i = []
    if (e) {
        const r = []
        ;(e.forEach(n => {
            const a = n.substring(1, n.length - 1).split(',')
            r.push(a)
        }),
            Sf(s, r, 0, e, i))
    } else i.push(s)
    return i
}
const bn = s => !Array.isArray(s)
class Ty {
    constructor() {
        ;((this._parsers = []),
            (this._cache = new Map()),
            (this._cacheMap = new Map()))
    }
    reset() {
        ;(this._cacheMap.clear(), this._cache.clear())
    }
    has(t) {
        return this._cache.has(t)
    }
    get(t) {
        const e = this._cache.get(t)
        return (
            e ||
                console.warn(
                    `[Assets] Asset id ${t} was not found in the Cache`,
                ),
            e
        )
    }
    set(t, e) {
        const i = Ee(t)
        let r
        for (let o = 0; o < this.parsers.length; o++) {
            const h = this.parsers[o]
            if (h.test(e)) {
                r = h.getCacheableAssets(i, e)
                break
            }
        }
        r ||
            ((r = {}),
            i.forEach(o => {
                r[o] = e
            }))
        const n = Object.keys(r),
            a = { cacheKeys: n, keys: i }
        if (
            (i.forEach(o => {
                this._cacheMap.set(o, a)
            }),
            n.forEach(o => {
                const h = r ? r[o] : e
                ;(this._cache.has(o) &&
                    this._cache.get(o) !== h &&
                    console.warn('[Cache] already has key:', o),
                    this._cache.set(o, r[o]))
            }),
            e instanceof j)
        ) {
            const o = e
            i.forEach(h => {
                ;(o.baseTexture !== j.EMPTY.baseTexture &&
                    lt.addToCache(o.baseTexture, h),
                    j.addToCache(o, h))
            })
        }
    }
    remove(t) {
        if (!this._cacheMap.has(t)) {
            console.warn(`[Assets] Asset id ${t} was not found in the Cache`)
            return
        }
        const e = this._cacheMap.get(t)
        ;(e.cacheKeys.forEach(i => {
            this._cache.delete(i)
        }),
            e.keys.forEach(i => {
                this._cacheMap.delete(i)
            }))
    }
    get parsers() {
        return this._parsers
    }
}
const zi = new Ty()
class Ey {
    constructor() {
        ;((this._parsers = []),
            (this._parsersValidated = !1),
            (this.parsers = new Proxy(this._parsers, {
                set: (t, e, i) => (
                    (this._parsersValidated = !1),
                    (t[e] = i),
                    !0
                ),
            })),
            (this.promiseCache = {}))
    }
    reset() {
        ;((this._parsersValidated = !1), (this.promiseCache = {}))
    }
    _getLoadPromiseAndParser(t, e) {
        const i = { promise: null, parser: null }
        return (
            (i.promise = (async () => {
                let r = null,
                    n = null
                if (
                    (e.loadParser &&
                        ((n = this._parserHash[e.loadParser]),
                        n ||
                            console.warn(
                                `[Assets] specified load parser "${e.loadParser}" not found while loading ${t}`,
                            )),
                    !n)
                ) {
                    for (let a = 0; a < this.parsers.length; a++) {
                        const o = this.parsers[a]
                        if (o.load && o.test?.(t, e, this)) {
                            n = o
                            break
                        }
                    }
                    if (!n)
                        return (
                            console.warn(
                                `[Assets] ${t} could not be loaded as we don't know how to parse it, ensure the correct parser has been added`,
                            ),
                            null
                        )
                }
                ;((r = await n.load(t, e, this)), (i.parser = n))
                for (let a = 0; a < this.parsers.length; a++) {
                    const o = this.parsers[a]
                    o.parse &&
                        o.parse &&
                        (await o.testParse?.(r, e, this)) &&
                        ((r = (await o.parse(r, e, this)) || r), (i.parser = o))
                }
                return r
            })()),
            i
        )
    }
    async load(t, e) {
        this._parsersValidated || this._validateParsers()
        let i = 0
        const r = {},
            n = bn(t),
            a = Ee(t, l => ({ alias: [l], src: l })),
            o = a.length,
            h = a.map(async l => {
                const u = Gt.toAbsolute(l.src)
                if (!r[l.src])
                    try {
                        ;(this.promiseCache[u] ||
                            (this.promiseCache[u] =
                                this._getLoadPromiseAndParser(u, l)),
                            (r[l.src] = await this.promiseCache[u].promise),
                            e && e(++i / o))
                    } catch (c) {
                        throw (
                            delete this.promiseCache[u],
                            delete r[l.src],
                            new Error(`[Loader.load] Failed to load ${u}.
${c}`)
                        )
                    }
            })
        return (await Promise.all(h), n ? r[a[0].src] : r)
    }
    async unload(t) {
        const e = Ee(t, i => ({ alias: [i], src: i })).map(async i => {
            const r = Gt.toAbsolute(i.src),
                n = this.promiseCache[r]
            if (n) {
                const a = await n.promise
                ;(delete this.promiseCache[r], n.parser?.unload?.(a, i, this))
            }
        })
        await Promise.all(e)
    }
    _validateParsers() {
        ;((this._parsersValidated = !0),
            (this._parserHash = this._parsers
                .filter(t => t.name)
                .reduce(
                    (t, e) => (
                        t[e.name] &&
                            console.warn(
                                `[Assets] loadParser name conflict "${e.name}"`,
                            ),
                        { ...t, [e.name]: e }
                    ),
                    {},
                )))
    }
}
var Pe = (s => (
    (s[(s.Low = 0)] = 'Low'),
    (s[(s.Normal = 1)] = 'Normal'),
    (s[(s.High = 2)] = 'High'),
    s
))(Pe || {})
const Ay = '.json',
    Sy = 'application/json',
    Cy = {
        extension: { type: $.LoadParser, priority: Pe.Low },
        name: 'loadJson',
        test(s) {
            return Hr(s, Sy) || Si(s, Ay)
        },
        async load(s) {
            return await (await Y.ADAPTER.fetch(s)).json()
        },
    }
Q.add(Cy)
const Py = '.txt',
    Ry = 'text/plain',
    Iy = {
        name: 'loadTxt',
        extension: { type: $.LoadParser, priority: Pe.Low },
        test(s) {
            return Hr(s, Ry) || Si(s, Py)
        },
        async load(s) {
            return await (await Y.ADAPTER.fetch(s)).text()
        },
    }
Q.add(Iy)
const My = [
        'normal',
        'bold',
        '100',
        '200',
        '300',
        '400',
        '500',
        '600',
        '700',
        '800',
        '900',
    ],
    Dy = ['.ttf', '.otf', '.woff', '.woff2'],
    By = ['font/ttf', 'font/otf', 'font/woff', 'font/woff2'],
    Oy = /^(--|-?[A-Z_])[0-9A-Z_-]*$/i
function Fy(s) {
    const t = Gt.extname(s),
        e = Gt.basename(s, t)
            .replace(/(-|_)/g, ' ')
            .toLowerCase()
            .split(' ')
            .map(n => n.charAt(0).toUpperCase() + n.slice(1))
    let i = e.length > 0
    for (const n of e)
        if (!n.match(Oy)) {
            i = !1
            break
        }
    let r = e.join(' ')
    return (i || (r = `"${r.replace(/[\\"]/g, '\\$&')}"`), r)
}
const Ly = /^[0-9A-Za-z%:/?#\[\]@!\$&'()\*\+,;=\-._~]*$/
function ky(s) {
    return Ly.test(s) ? s : encodeURI(s)
}
const Ny = {
    extension: { type: $.LoadParser, priority: Pe.Low },
    name: 'loadWebFont',
    test(s) {
        return Hr(s, By) || Si(s, Dy)
    },
    async load(s, t) {
        const e = Y.ADAPTER.getFontFaceSet()
        if (e) {
            const i = [],
                r = t.data?.family ?? Fy(s),
                n = t.data?.weights?.filter(o => My.includes(o)) ?? ['normal'],
                a = t.data ?? {}
            for (let o = 0; o < n.length; o++) {
                const h = n[o],
                    l = new FontFace(r, `url(${ky(s)})`, { ...a, weight: h })
                ;(await l.load(), e.add(l), i.push(l))
            }
            return i.length === 1 ? i[0] : i
        }
        return (
            console.warn(
                '[loadWebFont] FontFace API is not supported. Skipping loading font',
            ),
            null
        )
    },
    unload(s) {
        ;(Array.isArray(s) ? s : [s]).forEach(t =>
            Y.ADAPTER.getFontFaceSet().delete(t),
        )
    },
}
Q.add(Ny)
const Uy = `(function() {
  "use strict";
  const WHITE_PNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=";
  async function checkImageBitmap() {
    try {
      if (typeof createImageBitmap != "function")
        return !1;
      const imageBlob = await (await fetch(WHITE_PNG)).blob(), imageBitmap = await createImageBitmap(imageBlob);
      return imageBitmap.width === 1 && imageBitmap.height === 1;
    } catch {
      return !1;
    }
  }
  checkImageBitmap().then((result) => {
    self.postMessage(result);
  });
})();
`
let Cr = null,
    fh = class {
        constructor() {
            ;(Cr ||
                (Cr = URL.createObjectURL(
                    new Blob([Uy], { type: 'application/javascript' }),
                )),
                (this.worker = new Worker(Cr)))
        }
    }
fh.revokeObjectURL = function () {
    Cr && (URL.revokeObjectURL(Cr), (Cr = null))
}
const Gy = `(function() {
  "use strict";
  async function loadImageBitmap(url) {
    const response = await fetch(url);
    if (!response.ok)
      throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \${response.status} \${response.statusText}\`);
    const imageBlob = await response.blob();
    return await createImageBitmap(imageBlob);
  }
  self.onmessage = async (event) => {
    try {
      const imageBitmap = await loadImageBitmap(event.data.data[0]);
      self.postMessage({
        data: imageBitmap,
        uuid: event.data.uuid,
        id: event.data.id
      }, [imageBitmap]);
    } catch (e) {
      self.postMessage({
        error: e,
        uuid: event.data.uuid,
        id: event.data.id
      });
    }
  };
})();
`
let Pr = null
class Cf {
    constructor() {
        ;(Pr ||
            (Pr = URL.createObjectURL(
                new Blob([Gy], { type: 'application/javascript' }),
            )),
            (this.worker = new Worker(Pr)))
    }
}
Cf.revokeObjectURL = function () {
    Pr && (URL.revokeObjectURL(Pr), (Pr = null))
}
let Oc = 0,
    yo
class Hy {
    constructor() {
        ;((this._initialized = !1),
            (this._createdWorkers = 0),
            (this.workerPool = []),
            (this.queue = []),
            (this.resolveHash = {}))
    }
    isImageBitmapSupported() {
        return this._isImageBitmapSupported !== void 0
            ? this._isImageBitmapSupported
            : ((this._isImageBitmapSupported = new Promise(t => {
                  const { worker: e } = new fh()
                  e.addEventListener('message', i => {
                      ;(e.terminate(), fh.revokeObjectURL(), t(i.data))
                  })
              })),
              this._isImageBitmapSupported)
    }
    loadImageBitmap(t) {
        return this._run('loadImageBitmap', [t])
    }
    async _initWorkers() {
        this._initialized || (this._initialized = !0)
    }
    getWorker() {
        yo === void 0 && (yo = navigator.hardwareConcurrency || 4)
        let t = this.workerPool.pop()
        return (
            !t &&
                this._createdWorkers < yo &&
                (this._createdWorkers++,
                (t = new Cf().worker),
                t.addEventListener('message', e => {
                    ;(this.complete(e.data),
                        this.returnWorker(e.target),
                        this.next())
                })),
            t
        )
    }
    returnWorker(t) {
        this.workerPool.push(t)
    }
    complete(t) {
        ;(t.error !== void 0
            ? this.resolveHash[t.uuid].reject(t.error)
            : this.resolveHash[t.uuid].resolve(t.data),
            (this.resolveHash[t.uuid] = null))
    }
    async _run(t, e) {
        await this._initWorkers()
        const i = new Promise((r, n) => {
            this.queue.push({ id: t, arguments: e, resolve: r, reject: n })
        })
        return (this.next(), i)
    }
    next() {
        if (!this.queue.length) return
        const t = this.getWorker()
        if (!t) return
        const e = this.queue.pop(),
            i = e.id
        ;((this.resolveHash[Oc] = { resolve: e.resolve, reject: e.reject }),
            t.postMessage({ data: e.arguments, uuid: Oc++, id: i }))
    }
}
const Fc = new Hy()
function bs(s, t, e) {
    s.resource.internal = !0
    const i = new j(s),
        r = () => {
            ;(delete t.promiseCache[e], zi.has(e) && zi.remove(e))
        }
    return (
        i.baseTexture.once('destroyed', () => {
            e in t.promiseCache &&
                (console.warn(
                    '[Assets] A BaseTexture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the BaseTexture.',
                ),
                r())
        }),
        i.once('destroyed', () => {
            s.destroyed ||
                (console.warn(
                    '[Assets] A Texture managed by Assets was destroyed instead of unloaded! Use Assets.unload() instead of destroying the Texture.',
                ),
                r())
        }),
        i
    )
}
const zy = ['.jpeg', '.jpg', '.png', '.webp', '.avif'],
    Vy = ['image/jpeg', 'image/png', 'image/webp', 'image/avif']
async function Xy(s) {
    const t = await Y.ADAPTER.fetch(s)
    if (!t.ok)
        throw new Error(
            `[loadImageBitmap] Failed to fetch ${s}: ${t.status} ${t.statusText}`,
        )
    const e = await t.blob()
    return await createImageBitmap(e)
}
const Gn = {
    name: 'loadTextures',
    extension: { type: $.LoadParser, priority: Pe.High },
    config: {
        preferWorkers: !0,
        preferCreateImageBitmap: !0,
        crossOrigin: 'anonymous',
    },
    test(s) {
        return Hr(s, Vy) || Si(s, zy)
    },
    async load(s, t, e) {
        const i =
            globalThis.createImageBitmap && this.config.preferCreateImageBitmap
        let r
        i
            ? this.config.preferWorkers && (await Fc.isImageBitmapSupported())
                ? (r = await Fc.loadImageBitmap(s))
                : (r = await Xy(s))
            : (r = await new Promise((o, h) => {
                  const l = new Image()
                  ;((l.crossOrigin = this.config.crossOrigin),
                      (l.src = s),
                      l.complete
                          ? o(l)
                          : ((l.onload = () => o(l)), (l.onerror = u => h(u))))
              }))
        const n = { ...t.data }
        ;(n.resolution ?? (n.resolution = ii(s)),
            i &&
                n.resourceOptions?.ownsImageBitmap === void 0 &&
                ((n.resourceOptions = { ...n.resourceOptions }),
                (n.resourceOptions.ownsImageBitmap = !0)))
        const a = new lt(r, n)
        return ((a.resource.src = s), bs(a, e, s))
    },
    unload(s) {
        s.destroy(!0)
    },
}
Q.add(Gn)
const Wy = '.svg',
    $y = 'image/svg+xml',
    jy = {
        extension: { type: $.LoadParser, priority: Pe.High },
        name: 'loadSVG',
        test(s) {
            return Hr(s, $y) || Si(s, Wy)
        },
        async testParse(s) {
            return ih.test(s)
        },
        async parse(s, t, e) {
            const i = new ih(s, t?.data?.resourceOptions)
            await i.load()
            const r = new lt(i, { resolution: ii(s), ...t?.data })
            return ((r.resource.src = t.src), bs(r, e, t.src))
        },
        async load(s, t) {
            return (await Y.ADAPTER.fetch(s)).text()
        },
        unload: Gn.unload,
    }
Q.add(jy)
const qy = ['.mp4', '.m4v', '.webm', '.ogv'],
    Yy = ['video/mp4', 'video/webm', 'video/ogg'],
    Ky = {
        name: 'loadVideo',
        extension: { type: $.LoadParser, priority: Pe.High },
        config: {
            defaultAutoPlay: !0,
            defaultUpdateFPS: 0,
            defaultLoop: !1,
            defaultMuted: !1,
            defaultPlaysinline: !0,
        },
        test(s) {
            return Hr(s, Yy) || Si(s, qy)
        },
        async load(s, t, e) {
            let i
            const r = await (await Y.ADAPTER.fetch(s)).blob(),
                n = URL.createObjectURL(r)
            try {
                const a = {
                        autoPlay: this.config.defaultAutoPlay,
                        updateFPS: this.config.defaultUpdateFPS,
                        loop: this.config.defaultLoop,
                        muted: this.config.defaultMuted,
                        playsinline: this.config.defaultPlaysinline,
                        ...t?.data?.resourceOptions,
                        autoLoad: !0,
                    },
                    o = new yf(n, a)
                await o.load()
                const h = new lt(o, {
                    alphaMode: await ig(),
                    resolution: ii(s),
                    ...t?.data,
                })
                ;((h.resource.src = s),
                    (i = bs(h, e, s)),
                    i.baseTexture.once('destroyed', () => {
                        URL.revokeObjectURL(n)
                    }))
            } catch (a) {
                throw (URL.revokeObjectURL(n), a)
            }
            return i
        },
        unload(s) {
            s.destroy(!0)
        },
    }
Q.add(Ky)
class Zy {
    constructor() {
        ;((this._defaultBundleIdentifierOptions = {
            connector: '-',
            createBundleAssetId: (t, e) => `${t}${this._bundleIdConnector}${e}`,
            extractAssetIdFromBundle: (t, e) =>
                e.replace(`${t}${this._bundleIdConnector}`, ''),
        }),
            (this._bundleIdConnector =
                this._defaultBundleIdentifierOptions.connector),
            (this._createBundleAssetId =
                this._defaultBundleIdentifierOptions.createBundleAssetId),
            (this._extractAssetIdFromBundle =
                this._defaultBundleIdentifierOptions.extractAssetIdFromBundle),
            (this._assetMap = {}),
            (this._preferredOrder = []),
            (this._parsers = []),
            (this._resolverHash = {}),
            (this._bundles = {}))
    }
    setBundleIdentifier(t) {
        if (
            ((this._bundleIdConnector = t.connector ?? this._bundleIdConnector),
            (this._createBundleAssetId =
                t.createBundleAssetId ?? this._createBundleAssetId),
            (this._extractAssetIdFromBundle =
                t.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle),
            this._extractAssetIdFromBundle(
                'foo',
                this._createBundleAssetId('foo', 'bar'),
            ) !== 'bar')
        )
            throw new Error(
                '[Resolver] GenerateBundleAssetId are not working correctly',
            )
    }
    prefer(...t) {
        ;(t.forEach(e => {
            ;(this._preferredOrder.push(e),
                e.priority || (e.priority = Object.keys(e.params)))
        }),
            (this._resolverHash = {}))
    }
    set basePath(t) {
        this._basePath = t
    }
    get basePath() {
        return this._basePath
    }
    set rootPath(t) {
        this._rootPath = t
    }
    get rootPath() {
        return this._rootPath
    }
    get parsers() {
        return this._parsers
    }
    reset() {
        ;(this.setBundleIdentifier(this._defaultBundleIdentifierOptions),
            (this._assetMap = {}),
            (this._preferredOrder = []),
            (this._resolverHash = {}),
            (this._rootPath = null),
            (this._basePath = null),
            (this._manifest = null),
            (this._bundles = {}),
            (this._defaultSearchParams = null))
    }
    setDefaultSearchParams(t) {
        if (typeof t == 'string') this._defaultSearchParams = t
        else {
            const e = t
            this._defaultSearchParams = Object.keys(e)
                .map(
                    i => `${encodeURIComponent(i)}=${encodeURIComponent(e[i])}`,
                )
                .join('&')
        }
    }
    getAlias(t) {
        const { alias: e, name: i, src: r, srcs: n } = t
        return Ee(
            e || i || r || n,
            a =>
                typeof a == 'string'
                    ? a
                    : Array.isArray(a)
                      ? a.map(o => o?.src ?? o?.srcs ?? o)
                      : a?.src || a?.srcs
                        ? (a.src ?? a.srcs)
                        : a,
            !0,
        )
    }
    addManifest(t) {
        ;(this._manifest &&
            console.warn(
                '[Resolver] Manifest already exists, this will be overwritten',
            ),
            (this._manifest = t),
            t.bundles.forEach(e => {
                this.addBundle(e.name, e.assets)
            }))
    }
    addBundle(t, e) {
        const i = []
        ;(Array.isArray(e)
            ? e.forEach(r => {
                  const n = r.src ?? r.srcs,
                      a = r.alias ?? r.name
                  let o
                  if (typeof a == 'string') {
                      const h = this._createBundleAssetId(t, a)
                      ;(i.push(h), (o = [a, h]))
                  } else {
                      const h = a.map(l => this._createBundleAssetId(t, l))
                      ;(i.push(...h), (o = [...a, ...h]))
                  }
                  this.add({ ...r, alias: o, src: n })
              })
            : Object.keys(e).forEach(r => {
                  const n = [r, this._createBundleAssetId(t, r)]
                  if (typeof e[r] == 'string') this.add({ alias: n, src: e[r] })
                  else if (Array.isArray(e[r]))
                      this.add({ alias: n, src: e[r] })
                  else {
                      const a = e[r],
                          o = a.src ?? a.srcs
                      this.add({
                          ...a,
                          alias: n,
                          src: Array.isArray(o) ? o : [o],
                      })
                  }
                  i.push(...n)
              }),
            (this._bundles[t] = i))
    }
    add(t, e, i, r, n) {
        const a = []
        typeof t == 'string' || (Array.isArray(t) && typeof t[0] == 'string')
            ? (ft(
                  '7.2.0',
                  `Assets.add now uses an object instead of individual parameters.
Please use Assets.add({ alias, src, data, format, loadParser }) instead.`,
              ),
              a.push({ alias: t, src: e, data: i, format: r, loadParser: n }))
            : Array.isArray(t)
              ? a.push(...t)
              : a.push(t)
        let o
        ;((o = h => {
            this.hasKey(h) &&
                console.warn(`[Resolver] already has key: ${h} overwriting`)
        }),
            Ee(a).forEach(h => {
                const { src: l, srcs: u } = h
                let { data: c, format: d, loadParser: f } = h
                const m = Ee(l || u).map(_ =>
                        typeof _ == 'string'
                            ? wy(_)
                            : Array.isArray(_)
                              ? _
                              : [_],
                    ),
                    p = this.getAlias(h)
                Array.isArray(p) ? p.forEach(o) : o(p)
                const g = []
                ;(m.forEach(_ => {
                    _.forEach(b => {
                        let v = {}
                        if (typeof b != 'object') {
                            v.src = b
                            for (let w = 0; w < this._parsers.length; w++) {
                                const x = this._parsers[w]
                                if (x.test(b)) {
                                    v = x.parse(b)
                                    break
                                }
                            }
                        } else
                            ((c = b.data ?? c),
                                (d = b.format ?? d),
                                (f = b.loadParser ?? f),
                                (v = { ...v, ...b }))
                        if (!p)
                            throw new Error(
                                `[Resolver] alias is undefined for this asset: ${v.src}`,
                            )
                        ;((v = this.buildResolvedAsset(v, {
                            aliases: p,
                            data: c,
                            format: d,
                            loadParser: f,
                        })),
                            g.push(v))
                    })
                }),
                    p.forEach(_ => {
                        this._assetMap[_] = g
                    }))
            }))
    }
    resolveBundle(t) {
        const e = bn(t)
        t = Ee(t)
        const i = {}
        return (
            t.forEach(r => {
                const n = this._bundles[r]
                if (n) {
                    const a = this.resolve(n),
                        o = {}
                    for (const h in a) {
                        const l = a[h]
                        o[this._extractAssetIdFromBundle(r, h)] = l
                    }
                    i[r] = o
                }
            }),
            e ? i[t[0]] : i
        )
    }
    resolveUrl(t) {
        const e = this.resolve(t)
        if (typeof t != 'string') {
            const i = {}
            for (const r in e) i[r] = e[r].src
            return i
        }
        return e.src
    }
    resolve(t) {
        const e = bn(t)
        t = Ee(t)
        const i = {}
        return (
            t.forEach(r => {
                if (!this._resolverHash[r])
                    if (this._assetMap[r]) {
                        let n = this._assetMap[r]
                        const a = n[0],
                            o = this._getPreferredOrder(n)
                        ;(o?.priority.forEach(h => {
                            o.params[h].forEach(l => {
                                const u = n.filter(c =>
                                    c[h] ? c[h] === l : !1,
                                )
                                u.length && (n = u)
                            })
                        }),
                            (this._resolverHash[r] = n[0] ?? a))
                    } else
                        this._resolverHash[r] = this.buildResolvedAsset(
                            { alias: [r], src: r },
                            {},
                        )
                i[r] = this._resolverHash[r]
            }),
            e ? i[t[0]] : i
        )
    }
    hasKey(t) {
        return !!this._assetMap[t]
    }
    hasBundle(t) {
        return !!this._bundles[t]
    }
    _getPreferredOrder(t) {
        for (let e = 0; e < t.length; e++) {
            const i = t[0],
                r = this._preferredOrder.find(n =>
                    n.params.format.includes(i.format),
                )
            if (r) return r
        }
        return this._preferredOrder[0]
    }
    _appendDefaultSearchParams(t) {
        if (!this._defaultSearchParams) return t
        const e = /\?/.test(t) ? '&' : '?'
        return `${t}${e}${this._defaultSearchParams}`
    }
    buildResolvedAsset(t, e) {
        const { aliases: i, data: r, loadParser: n, format: a } = e
        return (
            (this._basePath || this._rootPath) &&
                (t.src = Gt.toAbsolute(t.src, this._basePath, this._rootPath)),
            (t.alias = i ?? t.alias ?? [t.src]),
            (t.src = this._appendDefaultSearchParams(t.src)),
            (t.data = { ...(r || {}), ...t.data }),
            (t.loadParser = n ?? t.loadParser),
            (t.format = a ?? t.format ?? Gt.extname(t.src).slice(1)),
            (t.srcs = t.src),
            (t.name = t.alias),
            t
        )
    }
}
class Qy {
    constructor() {
        ;((this._detections = []),
            (this._initialized = !1),
            (this.resolver = new Zy()),
            (this.loader = new Ey()),
            (this.cache = zi),
            (this._backgroundLoader = new by(this.loader)),
            (this._backgroundLoader.active = !0),
            this.reset())
    }
    async init(t = {}) {
        if (this._initialized) {
            console.warn(
                '[Assets]AssetManager already initialized, did you load before calling this Assets.init()?',
            )
            return
        }
        if (
            ((this._initialized = !0),
            t.defaultSearchParams &&
                this.resolver.setDefaultSearchParams(t.defaultSearchParams),
            t.basePath && (this.resolver.basePath = t.basePath),
            t.bundleIdentifier &&
                this.resolver.setBundleIdentifier(t.bundleIdentifier),
            t.manifest)
        ) {
            let n = t.manifest
            ;(typeof n == 'string' && (n = await this.load(n)),
                this.resolver.addManifest(n))
        }
        const e = t.texturePreference?.resolution ?? 1,
            i = typeof e == 'number' ? [e] : e,
            r = await this._detectFormats({
                preferredFormats: t.texturePreference?.format,
                skipDetections: t.skipDetections,
                detections: this._detections,
            })
        ;(this.resolver.prefer({ params: { format: r, resolution: i } }),
            t.preferences && this.setPreferences(t.preferences))
    }
    add(t, e, i, r, n) {
        this.resolver.add(t, e, i, r, n)
    }
    async load(t, e) {
        this._initialized || (await this.init())
        const i = bn(t),
            r = Ee(t).map(o => {
                if (typeof o != 'string') {
                    const h = this.resolver.getAlias(o)
                    return (
                        h.some(l => !this.resolver.hasKey(l)) && this.add(o),
                        Array.isArray(h) ? h[0] : h
                    )
                }
                return (
                    this.resolver.hasKey(o) || this.add({ alias: o, src: o }),
                    o
                )
            }),
            n = this.resolver.resolve(r),
            a = await this._mapLoadToResolve(n, e)
        return i ? a[r[0]] : a
    }
    addBundle(t, e) {
        this.resolver.addBundle(t, e)
    }
    async loadBundle(t, e) {
        this._initialized || (await this.init())
        let i = !1
        typeof t == 'string' && ((i = !0), (t = [t]))
        const r = this.resolver.resolveBundle(t),
            n = {},
            a = Object.keys(r)
        let o = 0,
            h = 0
        const l = () => {
                e?.(++o / h)
            },
            u = a.map(c => {
                const d = r[c]
                return (
                    (h += Object.keys(d).length),
                    this._mapLoadToResolve(d, l).then(f => {
                        n[c] = f
                    })
                )
            })
        return (await Promise.all(u), i ? n[t[0]] : n)
    }
    async backgroundLoad(t) {
        ;(this._initialized || (await this.init()),
            typeof t == 'string' && (t = [t]))
        const e = this.resolver.resolve(t)
        this._backgroundLoader.add(Object.values(e))
    }
    async backgroundLoadBundle(t) {
        ;(this._initialized || (await this.init()),
            typeof t == 'string' && (t = [t]))
        const e = this.resolver.resolveBundle(t)
        Object.values(e).forEach(i => {
            this._backgroundLoader.add(Object.values(i))
        })
    }
    reset() {
        ;(this.resolver.reset(),
            this.loader.reset(),
            this.cache.reset(),
            (this._initialized = !1))
    }
    get(t) {
        if (typeof t == 'string') return zi.get(t)
        const e = {}
        for (let i = 0; i < t.length; i++) e[i] = zi.get(t[i])
        return e
    }
    async _mapLoadToResolve(t, e) {
        const i = Object.values(t),
            r = Object.keys(t)
        this._backgroundLoader.active = !1
        const n = await this.loader.load(i, e)
        this._backgroundLoader.active = !0
        const a = {}
        return (
            i.forEach((o, h) => {
                const l = n[o.src],
                    u = [o.src]
                ;(o.alias && u.push(...o.alias), (a[r[h]] = l), zi.set(u, l))
            }),
            a
        )
    }
    async unload(t) {
        this._initialized || (await this.init())
        const e = Ee(t).map(r => (typeof r != 'string' ? r.src : r)),
            i = this.resolver.resolve(e)
        await this._unloadFromResolved(i)
    }
    async unloadBundle(t) {
        ;(this._initialized || (await this.init()), (t = Ee(t)))
        const e = this.resolver.resolveBundle(t),
            i = Object.keys(e).map(r => this._unloadFromResolved(e[r]))
        await Promise.all(i)
    }
    async _unloadFromResolved(t) {
        const e = Object.values(t)
        ;(e.forEach(i => {
            zi.remove(i.src)
        }),
            await this.loader.unload(e))
    }
    async _detectFormats(t) {
        let e = []
        t.preferredFormats &&
            (e = Array.isArray(t.preferredFormats)
                ? t.preferredFormats
                : [t.preferredFormats])
        for (const i of t.detections)
            t.skipDetections || (await i.test())
                ? (e = await i.add(e))
                : t.skipDetections || (e = await i.remove(e))
        return ((e = e.filter((i, r) => e.indexOf(i) === r)), e)
    }
    get detections() {
        return this._detections
    }
    get preferWorkers() {
        return Gn.config.preferWorkers
    }
    set preferWorkers(t) {
        ;(ft(
            '7.2.0',
            'Assets.prefersWorkers is deprecated, use Assets.setPreferences({ preferWorkers: true }) instead.',
        ),
            this.setPreferences({ preferWorkers: t }))
    }
    setPreferences(t) {
        this.loader.parsers.forEach(e => {
            e.config &&
                Object.keys(e.config)
                    .filter(i => i in t)
                    .forEach(i => {
                        e.config[i] = t[i]
                    })
        })
    }
}
const xr = new Qy()
Q.handleByList($.LoadParser, xr.loader.parsers)
    .handleByList($.ResolveParser, xr.resolver.parsers)
    .handleByList($.CacheParser, xr.cache.parsers)
    .handleByList($.DetectionParser, xr.detections)
const Jy = {
    extension: $.CacheParser,
    test: s => Array.isArray(s) && s.every(t => t instanceof j),
    getCacheableAssets: (s, t) => {
        const e = {}
        return (
            s.forEach(i => {
                t.forEach((r, n) => {
                    e[i + (n === 0 ? '' : n + 1)] = r
                })
            }),
            e
        )
    },
}
Q.add(Jy)
async function Pf(s) {
    if ('Image' in globalThis)
        return new Promise(t => {
            const e = new Image()
            ;((e.onload = () => {
                t(!0)
            }),
                (e.onerror = () => {
                    t(!1)
                }),
                (e.src = s))
        })
    if ('createImageBitmap' in globalThis && 'fetch' in globalThis) {
        try {
            const t = await (await fetch(s)).blob()
            await createImageBitmap(t)
        } catch {
            return !1
        }
        return !0
    }
    return !1
}
const t0 = {
    extension: { type: $.DetectionParser, priority: 1 },
    test: async () =>
        Pf(
            'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=',
        ),
    add: async s => [...s, 'avif'],
    remove: async s => s.filter(t => t !== 'avif'),
}
Q.add(t0)
const e0 = {
    extension: { type: $.DetectionParser, priority: 0 },
    test: async () =>
        Pf(
            'data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=',
        ),
    add: async s => [...s, 'webp'],
    remove: async s => s.filter(t => t !== 'webp'),
}
Q.add(e0)
const Lc = ['png', 'jpg', 'jpeg'],
    i0 = {
        extension: { type: $.DetectionParser, priority: -1 },
        test: () => Promise.resolve(!0),
        add: async s => [...s, ...Lc],
        remove: async s => s.filter(t => !Lc.includes(t)),
    }
Q.add(i0)
const r0 =
    'WorkerGlobalScope' in globalThis &&
    globalThis instanceof globalThis.WorkerGlobalScope
function $h(s) {
    return r0 ? !1 : document.createElement('video').canPlayType(s) !== ''
}
const s0 = {
    extension: { type: $.DetectionParser, priority: 0 },
    test: async () => $h('video/webm'),
    add: async s => [...s, 'webm'],
    remove: async s => s.filter(t => t !== 'webm'),
}
Q.add(s0)
const n0 = {
    extension: { type: $.DetectionParser, priority: 0 },
    test: async () => $h('video/mp4'),
    add: async s => [...s, 'mp4', 'm4v'],
    remove: async s => s.filter(t => t !== 'mp4' && t !== 'm4v'),
}
Q.add(n0)
const a0 = {
    extension: { type: $.DetectionParser, priority: 0 },
    test: async () => $h('video/ogg'),
    add: async s => [...s, 'ogv'],
    remove: async s => s.filter(t => t !== 'ogv'),
}
Q.add(a0)
const o0 = {
    extension: $.ResolveParser,
    test: Gn.test,
    parse: s => ({
        resolution: parseFloat(Y.RETINA_PREFIX.exec(s)?.[1] ?? '1'),
        format: Gt.extname(s).slice(1),
        src: s,
    }),
}
Q.add(o0)
var zt = (s => (
    (s[(s.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776)] =
        'COMPRESSED_RGB_S3TC_DXT1_EXT'),
    (s[(s.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777)] =
        'COMPRESSED_RGBA_S3TC_DXT1_EXT'),
    (s[(s.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778)] =
        'COMPRESSED_RGBA_S3TC_DXT3_EXT'),
    (s[(s.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779)] =
        'COMPRESSED_RGBA_S3TC_DXT5_EXT'),
    (s[(s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917)] =
        'COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT'),
    (s[(s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918)] =
        'COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT'),
    (s[(s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919)] =
        'COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT'),
    (s[(s.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916)] =
        'COMPRESSED_SRGB_S3TC_DXT1_EXT'),
    (s[(s.COMPRESSED_R11_EAC = 37488)] = 'COMPRESSED_R11_EAC'),
    (s[(s.COMPRESSED_SIGNED_R11_EAC = 37489)] = 'COMPRESSED_SIGNED_R11_EAC'),
    (s[(s.COMPRESSED_RG11_EAC = 37490)] = 'COMPRESSED_RG11_EAC'),
    (s[(s.COMPRESSED_SIGNED_RG11_EAC = 37491)] = 'COMPRESSED_SIGNED_RG11_EAC'),
    (s[(s.COMPRESSED_RGB8_ETC2 = 37492)] = 'COMPRESSED_RGB8_ETC2'),
    (s[(s.COMPRESSED_RGBA8_ETC2_EAC = 37496)] = 'COMPRESSED_RGBA8_ETC2_EAC'),
    (s[(s.COMPRESSED_SRGB8_ETC2 = 37493)] = 'COMPRESSED_SRGB8_ETC2'),
    (s[(s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497)] =
        'COMPRESSED_SRGB8_ALPHA8_ETC2_EAC'),
    (s[(s.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494)] =
        'COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2'),
    (s[(s.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495)] =
        'COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2'),
    (s[(s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840)] =
        'COMPRESSED_RGB_PVRTC_4BPPV1_IMG'),
    (s[(s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842)] =
        'COMPRESSED_RGBA_PVRTC_4BPPV1_IMG'),
    (s[(s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841)] =
        'COMPRESSED_RGB_PVRTC_2BPPV1_IMG'),
    (s[(s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843)] =
        'COMPRESSED_RGBA_PVRTC_2BPPV1_IMG'),
    (s[(s.COMPRESSED_RGB_ETC1_WEBGL = 36196)] = 'COMPRESSED_RGB_ETC1_WEBGL'),
    (s[(s.COMPRESSED_RGB_ATC_WEBGL = 35986)] = 'COMPRESSED_RGB_ATC_WEBGL'),
    (s[(s.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35987)] =
        'COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL'),
    (s[(s.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798)] =
        'COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL'),
    (s[(s.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808)] =
        'COMPRESSED_RGBA_ASTC_4x4_KHR'),
    (s[(s.COMPRESSED_RGBA_BPTC_UNORM_EXT = 36492)] =
        'COMPRESSED_RGBA_BPTC_UNORM_EXT'),
    (s[(s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = 36493)] =
        'COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT'),
    (s[(s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT = 36494)] =
        'COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT'),
    (s[(s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT = 36495)] =
        'COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT'),
    s
))(zt || {})
const wn = {
    33776: 0.5,
    33777: 0.5,
    33778: 1,
    33779: 1,
    35916: 0.5,
    35917: 0.5,
    35918: 1,
    35919: 1,
    37488: 0.5,
    37489: 0.5,
    37490: 1,
    37491: 1,
    37492: 0.5,
    37496: 1,
    37493: 0.5,
    37497: 1,
    37494: 0.5,
    37495: 0.5,
    35840: 0.5,
    35842: 0.5,
    35841: 0.25,
    35843: 0.25,
    36196: 0.5,
    35986: 0.5,
    35987: 1,
    34798: 1,
    37808: 1,
    36492: 1,
    36493: 1,
    36494: 1,
    36495: 1,
}
let Me, gr
function kc() {
    gr = {
        bptc: Me.getExtension('EXT_texture_compression_bptc'),
        astc: Me.getExtension('WEBGL_compressed_texture_astc'),
        etc: Me.getExtension('WEBGL_compressed_texture_etc'),
        s3tc: Me.getExtension('WEBGL_compressed_texture_s3tc'),
        s3tc_sRGB: Me.getExtension('WEBGL_compressed_texture_s3tc_srgb'),
        pvrtc:
            Me.getExtension('WEBGL_compressed_texture_pvrtc') ||
            Me.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc'),
        etc1: Me.getExtension('WEBGL_compressed_texture_etc1'),
        atc: Me.getExtension('WEBGL_compressed_texture_atc'),
    }
}
const h0 = {
    extension: { type: $.DetectionParser, priority: 2 },
    test: async () => {
        const s = Y.ADAPTER.createCanvas().getContext('webgl')
        return s
            ? ((Me = s), !0)
            : (console.warn('WebGL not available for compressed textures.'), !1)
    },
    add: async s => {
        gr || kc()
        const t = []
        for (const e in gr) gr[e] && t.push(e)
        return [...t, ...s]
    },
    remove: async s => (gr || kc(), s.filter(t => !(t in gr))),
}
Q.add(h0)
class l0 extends Fn {
    constructor(t, e = { width: 1, height: 1, autoLoad: !0 }) {
        let i, r
        ;(typeof t == 'string'
            ? ((i = t), (r = new Uint8Array()))
            : ((i = null), (r = t)),
            super(r, e),
            (this.origin = i),
            (this.buffer = r ? new zo(r) : null),
            (this._load = null),
            (this.loaded = !1),
            this.origin !== null && e.autoLoad !== !1 && this.load(),
            this.origin === null &&
                this.buffer &&
                ((this._load = Promise.resolve(this)),
                (this.loaded = !0),
                this.onBlobLoaded(this.buffer.rawBinaryData)))
    }
    onBlobLoaded(t) {}
    load() {
        return this._load
            ? this._load
            : ((this._load = fetch(this.origin)
                  .then(t => t.blob())
                  .then(t => t.arrayBuffer())
                  .then(
                      t => (
                          (this.data = new Uint32Array(t)),
                          (this.buffer = new zo(t)),
                          (this.loaded = !0),
                          this.onBlobLoaded(t),
                          this.update(),
                          this
                      ),
                  )),
              this._load)
    }
}
class $i extends l0 {
    constructor(t, e) {
        ;(super(t, e),
            (this.format = e.format),
            (this.levels = e.levels || 1),
            (this._width = e.width),
            (this._height = e.height),
            (this._extension = $i._formatToExtension(this.format)),
            (e.levelBuffers || this.buffer) &&
                (this._levelBuffers =
                    e.levelBuffers ||
                    $i._createLevelBuffers(
                        t instanceof Uint8Array ? t : this.buffer.uint8View,
                        this.format,
                        this.levels,
                        4,
                        4,
                        this.width,
                        this.height,
                    )))
    }
    upload(t, e, i) {
        const r = t.gl
        if (!t.context.extensions[this._extension])
            throw new Error(
                `${this._extension} textures are not supported on the current machine`,
            )
        if (!this._levelBuffers) return !1
        r.pixelStorei(r.UNPACK_ALIGNMENT, 4)
        for (let n = 0, a = this.levels; n < a; n++) {
            const {
                levelID: o,
                levelWidth: h,
                levelHeight: l,
                levelBuffer: u,
            } = this._levelBuffers[n]
            r.compressedTexImage2D(r.TEXTURE_2D, o, this.format, h, l, 0, u)
        }
        return !0
    }
    onBlobLoaded() {
        this._levelBuffers = $i._createLevelBuffers(
            this.buffer.uint8View,
            this.format,
            this.levels,
            4,
            4,
            this.width,
            this.height,
        )
    }
    static _formatToExtension(t) {
        if (t >= 33776 && t <= 33779) return 's3tc'
        if (t >= 35916 && t <= 35919) return 's3tc_sRGB'
        if (t >= 37488 && t <= 37497) return 'etc'
        if (t >= 35840 && t <= 35843) return 'pvrtc'
        if (t === 36196) return 'etc1'
        if (t === 35986 || t === 35987 || t === 34798) return 'atc'
        if (t >= 36492 && t <= 36495) return 'bptc'
        if (t === 37808) return 'astc'
        throw new Error(`Invalid (compressed) texture format given: ${t}`)
    }
    static _createLevelBuffers(t, e, i, r, n, a, o) {
        const h = new Array(i)
        let l = t.byteOffset,
            u = a,
            c = o,
            d = (u + r - 1) & ~(r - 1),
            f = (c + n - 1) & ~(n - 1),
            m = d * f * wn[e]
        for (let p = 0; p < i; p++)
            ((h[p] = {
                levelID: p,
                levelWidth: i > 1 ? u : d,
                levelHeight: i > 1 ? c : f,
                levelBuffer: new Uint8Array(t.buffer, l, m),
            }),
                (l += m),
                (u = u >> 1 || 1),
                (c = c >> 1 || 1),
                (d = (u + r - 1) & ~(r - 1)),
                (f = (c + n - 1) & ~(n - 1)),
                (m = d * f * wn[e]))
        return h
    }
}
const vo = 4,
    Hs = 124,
    u0 = 32,
    Nc = 20,
    c0 = 542327876,
    zs = { HEIGHT: 3, WIDTH: 4, MIPMAP_COUNT: 7, PIXEL_FORMAT: 19 },
    d0 = { FOURCC: 2 },
    Vs = { DXGI_FORMAT: 0, RESOURCE_DIMENSION: 1, MISC_FLAG: 2, ARRAY_SIZE: 3 },
    f0 = 1,
    p0 = 2,
    m0 = 4,
    g0 = 64,
    _0 = 512,
    y0 = 131072,
    v0 = 827611204,
    x0 = 861165636,
    b0 = 894720068,
    w0 = 808540228,
    T0 = 4,
    E0 = {
        [v0]: zt.COMPRESSED_RGBA_S3TC_DXT1_EXT,
        [x0]: zt.COMPRESSED_RGBA_S3TC_DXT3_EXT,
        [b0]: zt.COMPRESSED_RGBA_S3TC_DXT5_EXT,
    },
    A0 = {
        70: zt.COMPRESSED_RGBA_S3TC_DXT1_EXT,
        71: zt.COMPRESSED_RGBA_S3TC_DXT1_EXT,
        73: zt.COMPRESSED_RGBA_S3TC_DXT3_EXT,
        74: zt.COMPRESSED_RGBA_S3TC_DXT3_EXT,
        76: zt.COMPRESSED_RGBA_S3TC_DXT5_EXT,
        77: zt.COMPRESSED_RGBA_S3TC_DXT5_EXT,
        72: zt.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
        75: zt.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
        78: zt.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT,
        96: zt.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT,
        95: zt.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT,
        98: zt.COMPRESSED_RGBA_BPTC_UNORM_EXT,
        99: zt.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT,
    }
function S0(s) {
    const t = new Uint32Array(s)
    if (t[0] !== c0) throw new Error('Invalid DDS file magic word')
    const e = new Uint32Array(s, 0, Hs / Uint32Array.BYTES_PER_ELEMENT),
        i = e[zs.HEIGHT],
        r = e[zs.WIDTH],
        n = e[zs.MIPMAP_COUNT],
        a = new Uint32Array(
            s,
            zs.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT,
            u0 / Uint32Array.BYTES_PER_ELEMENT,
        ),
        o = a[f0]
    if (o & m0) {
        const h = a[d0.FOURCC]
        if (h !== w0) {
            const b = E0[h],
                v = vo + Hs,
                w = new Uint8Array(s, v)
            return [new $i(w, { format: b, width: r, height: i, levels: n })]
        }
        const l = vo + Hs,
            u = new Uint32Array(
                t.buffer,
                l,
                Nc / Uint32Array.BYTES_PER_ELEMENT,
            ),
            c = u[Vs.DXGI_FORMAT],
            d = u[Vs.RESOURCE_DIMENSION],
            f = u[Vs.MISC_FLAG],
            m = u[Vs.ARRAY_SIZE],
            p = A0[c]
        if (p === void 0)
            throw new Error(
                `DDSParser cannot parse texture data with DXGI format ${c}`,
            )
        if (f === T0)
            throw new Error('DDSParser does not support cubemap textures')
        if (d === 6)
            throw new Error('DDSParser does not supported 3D texture data')
        const g = new Array(),
            _ = vo + Hs + Nc
        if (m === 1) g.push(new Uint8Array(s, _))
        else {
            const b = wn[p]
            let v = 0,
                w = r,
                x = i
            for (let y = 0; y < n; y++) {
                const S = Math.max(1, (w + 3) & -4),
                    R = Math.max(1, (x + 3) & -4),
                    G = S * R * b
                ;((v += G), (w = w >>> 1), (x = x >>> 1))
            }
            let P = _
            for (let y = 0; y < m; y++)
                (g.push(new Uint8Array(s, P, v)), (P += v))
        }
        return g.map(
            b => new $i(b, { format: p, width: r, height: i, levels: n }),
        )
    }
    throw o & g0
        ? new Error('DDSParser does not support uncompressed texture data.')
        : o & _0
          ? new Error(
                'DDSParser does not supported YUV uncompressed texture data.',
            )
          : o & y0
            ? new Error(
                  'DDSParser does not support single-channel (lumninance) texture data!',
              )
            : o & p0
              ? new Error(
                    'DDSParser does not support single-channel (alpha) texture data!',
                )
              : new Error(
                    'DDSParser failed to load a texture file due to an unknown reason!',
                )
}
const Uc = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10],
    C0 = 67305985,
    be = {
        ENDIANNESS: 12,
        GL_TYPE: 16,
        GL_FORMAT: 24,
        GL_INTERNAL_FORMAT: 28,
        PIXEL_WIDTH: 36,
        PIXEL_HEIGHT: 40,
        PIXEL_DEPTH: 44,
        NUMBER_OF_ARRAY_ELEMENTS: 48,
        NUMBER_OF_FACES: 52,
        NUMBER_OF_MIPMAP_LEVELS: 56,
        BYTES_OF_KEY_VALUE_DATA: 60,
    },
    ph = 64,
    Gc = {
        [at.UNSIGNED_BYTE]: 1,
        [at.UNSIGNED_SHORT]: 2,
        [at.INT]: 4,
        [at.UNSIGNED_INT]: 4,
        [at.FLOAT]: 4,
        [at.HALF_FLOAT]: 8,
    },
    P0 = {
        [X.RGBA]: 4,
        [X.RGB]: 3,
        [X.RG]: 2,
        [X.RED]: 1,
        [X.LUMINANCE]: 1,
        [X.LUMINANCE_ALPHA]: 2,
        [X.ALPHA]: 1,
    },
    R0 = {
        [at.UNSIGNED_SHORT_4_4_4_4]: 2,
        [at.UNSIGNED_SHORT_5_5_5_1]: 2,
        [at.UNSIGNED_SHORT_5_6_5]: 2,
    }
function I0(s, t, e = !1) {
    const i = new DataView(t)
    if (!M0(s, i)) return null
    const r = i.getUint32(be.ENDIANNESS, !0) === C0,
        n = i.getUint32(be.GL_TYPE, r),
        a = i.getUint32(be.GL_FORMAT, r),
        o = i.getUint32(be.GL_INTERNAL_FORMAT, r),
        h = i.getUint32(be.PIXEL_WIDTH, r),
        l = i.getUint32(be.PIXEL_HEIGHT, r) || 1,
        u = i.getUint32(be.PIXEL_DEPTH, r) || 1,
        c = i.getUint32(be.NUMBER_OF_ARRAY_ELEMENTS, r) || 1,
        d = i.getUint32(be.NUMBER_OF_FACES, r),
        f = i.getUint32(be.NUMBER_OF_MIPMAP_LEVELS, r),
        m = i.getUint32(be.BYTES_OF_KEY_VALUE_DATA, r)
    if (l === 0 || u !== 1) throw new Error('Only 2D textures are supported')
    if (d !== 1)
        throw new Error('CubeTextures are not supported by KTXLoader yet!')
    if (c !== 1) throw new Error('WebGL does not support array textures')
    const p = 4,
        g = 4,
        _ = (h + 3) & -4,
        b = (l + 3) & -4,
        v = new Array(c)
    let w = h * l
    n === 0 && (w = _ * b)
    let x
    if (
        (n !== 0 ? (Gc[n] ? (x = Gc[n] * P0[a]) : (x = R0[n])) : (x = wn[o]),
        x === void 0)
    )
        throw new Error(
            'Unable to resolve the pixel format stored in the *.ktx file!',
        )
    const P = e ? B0(i, m, r) : null
    let y = w * x,
        S = h,
        R = l,
        G = _,
        N = b,
        I = ph + m
    for (let O = 0; O < f; O++) {
        const L = i.getUint32(I, r)
        let V = I + 4
        for (let T = 0; T < c; T++) {
            let A = v[T]
            ;(A || (A = v[T] = new Array(f)),
                (A[O] = {
                    levelID: O,
                    levelWidth: f > 1 || n !== 0 ? S : G,
                    levelHeight: f > 1 || n !== 0 ? R : N,
                    levelBuffer: new Uint8Array(t, V, y),
                }),
                (V += y))
        }
        ;((I += L + 4),
            (I = I % 4 !== 0 ? I + 4 - (I % 4) : I),
            (S = S >> 1 || 1),
            (R = R >> 1 || 1),
            (G = (S + p - 1) & -4),
            (N = (R + g - 1) & -4),
            (y = G * N * x))
    }
    return n !== 0
        ? {
              uncompressed: v.map(O => {
                  let L = O[0].levelBuffer,
                      V = !1
                  return (
                      n === at.FLOAT
                          ? (L = new Float32Array(
                                O[0].levelBuffer.buffer,
                                O[0].levelBuffer.byteOffset,
                                O[0].levelBuffer.byteLength / 4,
                            ))
                          : n === at.UNSIGNED_INT
                            ? ((V = !0),
                              (L = new Uint32Array(
                                  O[0].levelBuffer.buffer,
                                  O[0].levelBuffer.byteOffset,
                                  O[0].levelBuffer.byteLength / 4,
                              )))
                            : n === at.INT &&
                              ((V = !0),
                              (L = new Int32Array(
                                  O[0].levelBuffer.buffer,
                                  O[0].levelBuffer.byteOffset,
                                  O[0].levelBuffer.byteLength / 4,
                              ))),
                      {
                          resource: new Fn(L, {
                              width: O[0].levelWidth,
                              height: O[0].levelHeight,
                          }),
                          type: n,
                          format: V ? D0(a) : a,
                      }
                  )
              }),
              kvData: P,
          }
        : {
              compressed: v.map(
                  O =>
                      new $i(null, {
                          format: o,
                          width: h,
                          height: l,
                          levels: f,
                          levelBuffers: O,
                      }),
              ),
              kvData: P,
          }
}
function M0(s, t) {
    for (let e = 0; e < Uc.length; e++)
        if (t.getUint8(e) !== Uc[e])
            return (console.error(`${s} is not a valid *.ktx file!`), !1)
    return !0
}
function D0(s) {
    switch (s) {
        case X.RGBA:
            return X.RGBA_INTEGER
        case X.RGB:
            return X.RGB_INTEGER
        case X.RG:
            return X.RG_INTEGER
        case X.RED:
            return X.RED_INTEGER
        default:
            return s
    }
}
function B0(s, t, e) {
    const i = new Map()
    let r = 0
    for (; r < t; ) {
        const n = s.getUint32(ph + r, e),
            a = ph + r + 4,
            o = 3 - ((n + 3) % 4)
        if (n === 0 || n > t - r) {
            console.error('KTXLoader: keyAndValueByteSize out of bounds')
            break
        }
        let h = 0
        for (; h < n && s.getUint8(a + h) !== 0; h++);
        if (h === -1) {
            console.error(
                'KTXLoader: Failed to find null byte terminating kvData key',
            )
            break
        }
        const l = new TextDecoder().decode(new Uint8Array(s.buffer, a, h)),
            u = new DataView(s.buffer, a + h + 1, n - h - 1)
        ;(i.set(l, u), (r += 4 + n + o))
    }
    return i
}
const O0 = {
    extension: { type: $.LoadParser, priority: Pe.High },
    name: 'loadDDS',
    test(s) {
        return Si(s, '.dds')
    },
    async load(s, t, e) {
        const i = await (await Y.ADAPTER.fetch(s)).arrayBuffer(),
            r = S0(i).map(n => {
                const a = new lt(n, {
                    mipmap: Xe.OFF,
                    alphaMode: Zt.NO_PREMULTIPLIED_ALPHA,
                    resolution: ii(s),
                    ...t.data,
                })
                return bs(a, e, s)
            })
        return r.length === 1 ? r[0] : r
    },
    unload(s) {
        Array.isArray(s) ? s.forEach(t => t.destroy(!0)) : s.destroy(!0)
    },
}
Q.add(O0)
const F0 = {
    extension: { type: $.LoadParser, priority: Pe.High },
    name: 'loadKTX',
    test(s) {
        return Si(s, '.ktx')
    },
    async load(s, t, e) {
        const i = await (await Y.ADAPTER.fetch(s)).arrayBuffer(),
            { compressed: r, uncompressed: n, kvData: a } = I0(s, i),
            o = r ?? n,
            h = {
                mipmap: Xe.OFF,
                alphaMode: Zt.NO_PREMULTIPLIED_ALPHA,
                resolution: ii(s),
                ...t.data,
            },
            l = o.map(u => {
                o === n && Object.assign(h, { type: u.type, format: u.format })
                const c = u.resource ?? u,
                    d = new lt(c, h)
                return ((d.ktxKeyValueData = a), bs(d, e, s))
            })
        return l.length === 1 ? l[0] : l
    },
    unload(s) {
        Array.isArray(s) ? s.forEach(t => t.destroy(!0)) : s.destroy(!0)
    },
}
Q.add(F0)
const L0 = ['s3tc', 's3tc_sRGB', 'etc', 'etc1', 'pvrtc', 'atc', 'astc', 'bptc'],
    k0 = {
        extension: $.ResolveParser,
        test: s => {
            const t = Gt.extname(s).slice(1)
            return ['basis', 'ktx', 'dds'].includes(t)
        },
        parse: s => {
            const t = s.split('.'),
                e = t.pop()
            if (['ktx', 'dds'].includes(e)) {
                const i = t.pop()
                if (L0.includes(i))
                    return {
                        resolution: parseFloat(
                            Y.RETINA_PREFIX.exec(s)?.[1] ?? '1',
                        ),
                        format: i,
                        src: s,
                    }
            }
            return {
                resolution: parseFloat(Y.RETINA_PREFIX.exec(s)?.[1] ?? '1'),
                format: e,
                src: s,
            }
        },
    }
Q.add(k0)
const Xs = new dt(),
    N0 = 4,
    Rf = class ts {
        constructor(t) {
            ;((this.renderer = t), (this._rendererPremultipliedAlpha = !1))
        }
        contextChange() {
            const t = this.renderer?.gl.getContextAttributes()
            this._rendererPremultipliedAlpha = !!(
                t &&
                t.alpha &&
                t.premultipliedAlpha
            )
        }
        async image(t, e, i, r) {
            const n = new Image()
            return ((n.src = await this.base64(t, e, i, r)), n)
        }
        async base64(t, e, i, r) {
            const n = this.canvas(t, r)
            if (n.toBlob !== void 0)
                return new Promise((a, o) => {
                    n.toBlob(
                        h => {
                            if (!h) {
                                o(new Error('ICanvas.toBlob failed!'))
                                return
                            }
                            const l = new FileReader()
                            ;((l.onload = () => a(l.result)),
                                (l.onerror = o),
                                l.readAsDataURL(h))
                        },
                        e,
                        i,
                    )
                })
            if (n.toDataURL !== void 0) return n.toDataURL(e, i)
            if (n.convertToBlob !== void 0) {
                const a = await n.convertToBlob({ type: e, quality: i })
                return new Promise((o, h) => {
                    const l = new FileReader()
                    ;((l.onload = () => o(l.result)),
                        (l.onerror = h),
                        l.readAsDataURL(a))
                })
            }
            throw new Error(
                'Extract.base64() requires ICanvas.toDataURL, ICanvas.toBlob, or ICanvas.convertToBlob to be implemented',
            )
        }
        canvas(t, e) {
            const {
                pixels: i,
                width: r,
                height: n,
                flipY: a,
                premultipliedAlpha: o,
            } = this._rawPixels(t, e)
            ;(a && ts._flipY(i, r, n), o && ts._unpremultiplyAlpha(i))
            const h = new yg(r, n, 1),
                l = new ImageData(new Uint8ClampedArray(i.buffer), r, n)
            return (h.context.putImageData(l, 0, 0), h.canvas)
        }
        pixels(t, e) {
            const {
                pixels: i,
                width: r,
                height: n,
                flipY: a,
                premultipliedAlpha: o,
            } = this._rawPixels(t, e)
            return (a && ts._flipY(i, r, n), o && ts._unpremultiplyAlpha(i), i)
        }
        _rawPixels(t, e) {
            const i = this.renderer
            if (!i) throw new Error('The Extract has already been destroyed')
            let r,
                n = !1,
                a = !1,
                o,
                h = !1
            t &&
                (t instanceof er
                    ? (o = t)
                    : ((o = i.generateTexture(t, {
                          region: e,
                          resolution: i.resolution,
                          multisample: i.multisample,
                      })),
                      (h = !0),
                      e &&
                          ((Xs.width = e.width),
                          (Xs.height = e.height),
                          (e = Xs))))
            const l = i.gl
            if (o) {
                if (
                    ((r = o.baseTexture.resolution),
                    (e = e ?? o.frame),
                    (n = !1),
                    (a =
                        o.baseTexture.alphaMode > 0 &&
                        o.baseTexture.format === X.RGBA),
                    !h)
                ) {
                    i.renderTexture.bind(o)
                    const f = o.framebuffer.glFramebuffers[i.CONTEXT_UID]
                    f.blitFramebuffer && i.framebuffer.bind(f.blitFramebuffer)
                }
            } else
                ((r = i.resolution),
                    e ||
                        ((e = Xs),
                        (e.width = i.width / r),
                        (e.height = i.height / r)),
                    (n = !0),
                    (a = this._rendererPremultipliedAlpha),
                    i.renderTexture.bind())
            const u = Math.max(Math.round(e.width * r), 1),
                c = Math.max(Math.round(e.height * r), 1),
                d = new Uint8Array(N0 * u * c)
            return (
                l.readPixels(
                    Math.round(e.x * r),
                    Math.round(e.y * r),
                    u,
                    c,
                    l.RGBA,
                    l.UNSIGNED_BYTE,
                    d,
                ),
                h && o?.destroy(!0),
                {
                    pixels: d,
                    width: u,
                    height: c,
                    flipY: n,
                    premultipliedAlpha: a,
                }
            )
        }
        destroy() {
            this.renderer = null
        }
        static _flipY(t, e, i) {
            const r = e << 2,
                n = i >> 1,
                a = new Uint8Array(r)
            for (let o = 0; o < n; o++) {
                const h = o * r,
                    l = (i - o - 1) * r
                ;(a.set(t.subarray(h, h + r)),
                    t.copyWithin(h, l, l + r),
                    t.set(a, l))
            }
        }
        static _unpremultiplyAlpha(t) {
            t instanceof Uint8ClampedArray && (t = new Uint8Array(t.buffer))
            const e = t.length
            for (let i = 0; i < e; i += 4) {
                const r = t[i + 3]
                if (r !== 0) {
                    const n = 255.001 / r
                    ;((t[i] = t[i] * n + 0.5),
                        (t[i + 1] = t[i + 1] * n + 0.5),
                        (t[i + 2] = t[i + 2] * n + 0.5))
                }
            }
        }
    }
Rf.extension = { name: 'extract', type: $.RendererSystem }
let U0 = Rf
Q.add(U0)
const Tn = {
    build(s) {
        const t = s.points
        let e, i, r, n, a, o
        if (s.type === Vt.CIRC) {
            const m = s.shape
            ;((e = m.x), (i = m.y), (a = o = m.radius), (r = n = 0))
        } else if (s.type === Vt.ELIP) {
            const m = s.shape
            ;((e = m.x), (i = m.y), (a = m.width), (o = m.height), (r = n = 0))
        } else {
            const m = s.shape,
                p = m.width / 2,
                g = m.height / 2
            ;((e = m.x + p),
                (i = m.y + g),
                (a = o = Math.max(0, Math.min(m.radius, Math.min(p, g)))),
                (r = p - a),
                (n = g - o))
        }
        if (!(a >= 0 && o >= 0 && r >= 0 && n >= 0)) {
            t.length = 0
            return
        }
        const h = Math.ceil(2.3 * Math.sqrt(a + o)),
            l = h * 8 + (r ? 4 : 0) + (n ? 4 : 0)
        if (((t.length = l), l === 0)) return
        if (h === 0) {
            ;((t.length = 8),
                (t[0] = t[6] = e + r),
                (t[1] = t[3] = i + n),
                (t[2] = t[4] = e - r),
                (t[5] = t[7] = i - n))
            return
        }
        let u = 0,
            c = h * 4 + (r ? 2 : 0) + 2,
            d = c,
            f = l
        {
            const m = r + a,
                p = n,
                g = e + m,
                _ = e - m,
                b = i + p
            if (((t[u++] = g), (t[u++] = b), (t[--c] = b), (t[--c] = _), n)) {
                const v = i - p
                ;((t[d++] = _), (t[d++] = v), (t[--f] = v), (t[--f] = g))
            }
        }
        for (let m = 1; m < h; m++) {
            const p = (Math.PI / 2) * (m / h),
                g = r + Math.cos(p) * a,
                _ = n + Math.sin(p) * o,
                b = e + g,
                v = e - g,
                w = i + _,
                x = i - _
            ;((t[u++] = b),
                (t[u++] = w),
                (t[--c] = w),
                (t[--c] = v),
                (t[d++] = v),
                (t[d++] = x),
                (t[--f] = x),
                (t[--f] = b))
        }
        {
            const m = r,
                p = n + o,
                g = e + m,
                _ = e - m,
                b = i + p,
                v = i - p
            ;((t[u++] = g),
                (t[u++] = b),
                (t[--f] = v),
                (t[--f] = g),
                r && ((t[u++] = _), (t[u++] = b), (t[--f] = v), (t[--f] = _)))
        }
    },
    triangulate(s, t) {
        const e = s.points,
            i = t.points,
            r = t.indices
        if (e.length === 0) return
        let n = i.length / 2
        const a = n
        let o, h
        if (s.type !== Vt.RREC) {
            const u = s.shape
            ;((o = u.x), (h = u.y))
        } else {
            const u = s.shape
            ;((o = u.x + u.width / 2), (h = u.y + u.height / 2))
        }
        const l = s.matrix
        ;(i.push(
            s.matrix ? l.a * o + l.c * h + l.tx : o,
            s.matrix ? l.b * o + l.d * h + l.ty : h,
        ),
            n++,
            i.push(e[0], e[1]))
        for (let u = 2; u < e.length; u += 2)
            (i.push(e[u], e[u + 1]), r.push(n++, a, n))
        r.push(a + 1, a, n)
    },
}
function Hc(s, t = !1) {
    const e = s.length
    if (e < 6) return
    let i = 0
    for (let r = 0, n = s[e - 2], a = s[e - 1]; r < e; r += 2) {
        const o = s[r],
            h = s[r + 1]
        ;((i += (o - n) * (h + a)), (n = o), (a = h))
    }
    if ((!t && i > 0) || (t && i <= 0)) {
        const r = e / 2
        for (let n = r + (r % 2); n < e; n += 2) {
            const a = e - n - 2,
                o = e - n - 1,
                h = n,
                l = n + 1
            ;(([s[a], s[h]] = [s[h], s[a]]), ([s[o], s[l]] = [s[l], s[o]]))
        }
    }
}
const If = {
        build(s) {
            s.points = s.shape.points.slice()
        },
        triangulate(s, t) {
            let e = s.points
            const i = s.holes,
                r = t.points,
                n = t.indices
            if (e.length >= 6) {
                Hc(e, !1)
                const a = []
                for (let l = 0; l < i.length; l++) {
                    const u = i[l]
                    ;(Hc(u.points, !0),
                        a.push(e.length / 2),
                        (e = e.concat(u.points)))
                }
                const o = gm(e, a, 2)
                if (!o) return
                const h = r.length / 2
                for (let l = 0; l < o.length; l += 3)
                    (n.push(o[l] + h),
                        n.push(o[l + 1] + h),
                        n.push(o[l + 2] + h))
                for (let l = 0; l < e.length; l++) r.push(e[l])
            }
        },
    },
    G0 = {
        build(s) {
            const t = s.shape,
                e = t.x,
                i = t.y,
                r = t.width,
                n = t.height,
                a = s.points
            ;((a.length = 0),
                r >= 0 &&
                    n >= 0 &&
                    a.push(e, i, e + r, i, e + r, i + n, e, i + n))
        },
        triangulate(s, t) {
            const e = s.points,
                i = t.points
            if (e.length === 0) return
            const r = i.length / 2
            ;(i.push(e[0], e[1], e[2], e[3], e[6], e[7], e[4], e[5]),
                t.indices.push(r, r + 1, r + 2, r + 1, r + 2, r + 3))
        },
    },
    H0 = {
        build(s) {
            Tn.build(s)
        },
        triangulate(s, t) {
            Tn.triangulate(s, t)
        },
    }
var de = (s => (
        (s.MITER = 'miter'),
        (s.BEVEL = 'bevel'),
        (s.ROUND = 'round'),
        s
    ))(de || {}),
    gi = (s => (
        (s.BUTT = 'butt'),
        (s.ROUND = 'round'),
        (s.SQUARE = 'square'),
        s
    ))(gi || {})
const Dr = {
    adaptive: !0,
    maxLength: 10,
    minSegments: 8,
    maxSegments: 2048,
    epsilon: 1e-4,
    _segmentsCount(s, t = 20) {
        if (!this.adaptive || !s || isNaN(s)) return t
        let e = Math.ceil(s / this.maxLength)
        return (
            e < this.minSegments
                ? (e = this.minSegments)
                : e > this.maxSegments && (e = this.maxSegments),
            e
        )
    },
}
class zc {
    static curveTo(t, e, i, r, n, a) {
        const o = a[a.length - 2],
            h = a[a.length - 1] - e,
            l = o - t,
            u = r - e,
            c = i - t,
            d = Math.abs(h * c - l * u)
        if (d < 1e-8 || n === 0)
            return (
                (a[a.length - 2] !== t || a[a.length - 1] !== e) &&
                    a.push(t, e),
                null
            )
        const f = h * h + l * l,
            m = u * u + c * c,
            p = h * u + l * c,
            g = (n * Math.sqrt(f)) / d,
            _ = (n * Math.sqrt(m)) / d,
            b = (g * p) / f,
            v = (_ * p) / m,
            w = g * c + _ * l,
            x = g * u + _ * h,
            P = l * (_ + b),
            y = h * (_ + b),
            S = c * (g + v),
            R = u * (g + v),
            G = Math.atan2(y - x, P - w),
            N = Math.atan2(R - x, S - w)
        return {
            cx: w + t,
            cy: x + e,
            radius: n,
            startAngle: G,
            endAngle: N,
            anticlockwise: l * u > c * h,
        }
    }
    static arc(t, e, i, r, n, a, o, h, l) {
        const u = o - a,
            c = Dr._segmentsCount(
                Math.abs(u) * n,
                Math.ceil(Math.abs(u) / pn) * 40,
            ),
            d = u / (c * 2),
            f = d * 2,
            m = Math.cos(d),
            p = Math.sin(d),
            g = c - 1,
            _ = (g % 1) / g
        for (let b = 0; b <= g; ++b) {
            const v = b + _ * b,
                w = d + a + f * v,
                x = Math.cos(w),
                P = -Math.sin(w)
            l.push((m * x + p * P) * n + i, (m * -P + p * x) * n + r)
        }
    }
}
class z0 {
    constructor() {
        this.reset()
    }
    begin(t, e, i) {
        ;(this.reset(),
            (this.style = t),
            (this.start = e),
            (this.attribStart = i))
    }
    end(t, e) {
        ;((this.attribSize = e - this.attribStart),
            (this.size = t - this.start))
    }
    reset() {
        ;((this.style = null),
            (this.size = 0),
            (this.start = 0),
            (this.attribStart = 0),
            (this.attribSize = 0))
    }
}
class jh {
    static curveLength(t, e, i, r, n, a, o, h) {
        let l = 0,
            u = 0,
            c = 0,
            d = 0,
            f = 0,
            m = 0,
            p = 0,
            g = 0,
            _ = 0,
            b = 0,
            v = 0,
            w = t,
            x = e
        for (let P = 1; P <= 10; ++P)
            ((u = P / 10),
                (c = u * u),
                (d = c * u),
                (f = 1 - u),
                (m = f * f),
                (p = m * f),
                (g = p * t + 3 * m * u * i + 3 * f * c * n + d * o),
                (_ = p * e + 3 * m * u * r + 3 * f * c * a + d * h),
                (b = w - g),
                (v = x - _),
                (w = g),
                (x = _),
                (l += Math.sqrt(b * b + v * v)))
        return l
    }
    static curveTo(t, e, i, r, n, a, o) {
        const h = o[o.length - 2],
            l = o[o.length - 1]
        o.length -= 2
        const u = Dr._segmentsCount(jh.curveLength(h, l, t, e, i, r, n, a))
        let c = 0,
            d = 0,
            f = 0,
            m = 0,
            p = 0
        o.push(h, l)
        for (let g = 1, _ = 0; g <= u; ++g)
            ((_ = g / u),
                (c = 1 - _),
                (d = c * c),
                (f = d * c),
                (m = _ * _),
                (p = m * _),
                o.push(
                    f * h + 3 * d * _ * t + 3 * c * m * i + p * n,
                    f * l + 3 * d * _ * e + 3 * c * m * r + p * a,
                ))
    }
}
function Vc(s, t, e, i, r, n, a, o) {
    const h = s - e * r,
        l = t - i * r,
        u = s + e * n,
        c = t + i * n
    let d, f
    a ? ((d = i), (f = -e)) : ((d = -i), (f = e))
    const m = h + d,
        p = l + f,
        g = u + d,
        _ = c + f
    return (o.push(m, p, g, _), 2)
}
function Mi(s, t, e, i, r, n, a, o) {
    const h = e - s,
        l = i - t
    let u = Math.atan2(h, l),
        c = Math.atan2(r - s, n - t)
    o && u < c ? (u += Math.PI * 2) : !o && u > c && (c += Math.PI * 2)
    let d = u
    const f = c - u,
        m = Math.abs(f),
        p = Math.sqrt(h * h + l * l),
        g = (((15 * m * Math.sqrt(p)) / Math.PI) >> 0) + 1,
        _ = f / g
    if (((d += _), o)) {
        a.push(s, t, e, i)
        for (let b = 1, v = d; b < g; b++, v += _)
            a.push(s, t, s + Math.sin(v) * p, t + Math.cos(v) * p)
        a.push(s, t, r, n)
    } else {
        a.push(e, i, s, t)
        for (let b = 1, v = d; b < g; b++, v += _)
            a.push(s + Math.sin(v) * p, t + Math.cos(v) * p, s, t)
        a.push(r, n, s, t)
    }
    return g * 2
}
function V0(s, t) {
    const e = s.shape
    let i = s.points || e.points.slice()
    const r = t.closePointEps
    if (i.length === 0) return
    const n = s.lineStyle,
        a = new ut(i[0], i[1]),
        o = new ut(i[i.length - 2], i[i.length - 1]),
        h = e.type !== Vt.POLY || e.closeStroke,
        l = Math.abs(a.x - o.x) < r && Math.abs(a.y - o.y) < r
    if (h) {
        ;((i = i.slice()),
            l && (i.pop(), i.pop(), o.set(i[i.length - 2], i[i.length - 1])))
        const A = (a.x + o.x) * 0.5,
            E = (o.y + a.y) * 0.5
        ;(i.unshift(A, E), i.push(A, E))
    }
    const u = t.points,
        c = i.length / 2
    let d = i.length
    const f = u.length / 2,
        m = n.width / 2,
        p = m * m,
        g = n.miterLimit * n.miterLimit
    let _ = i[0],
        b = i[1],
        v = i[2],
        w = i[3],
        x = 0,
        P = 0,
        y = -(b - w),
        S = _ - v,
        R = 0,
        G = 0,
        N = Math.sqrt(y * y + S * S)
    ;((y /= N), (S /= N), (y *= m), (S *= m))
    const I = n.alignment,
        O = (1 - I) * 2,
        L = I * 2
    ;(h ||
        (n.cap === gi.ROUND
            ? (d +=
                  Mi(
                      _ - y * (O - L) * 0.5,
                      b - S * (O - L) * 0.5,
                      _ - y * O,
                      b - S * O,
                      _ + y * L,
                      b + S * L,
                      u,
                      !0,
                  ) + 2)
            : n.cap === gi.SQUARE && (d += Vc(_, b, y, S, O, L, !0, u))),
        u.push(_ - y * O, b - S * O, _ + y * L, b + S * L))
    for (let A = 1; A < c - 1; ++A) {
        ;((_ = i[(A - 1) * 2]),
            (b = i[(A - 1) * 2 + 1]),
            (v = i[A * 2]),
            (w = i[A * 2 + 1]),
            (x = i[(A + 1) * 2]),
            (P = i[(A + 1) * 2 + 1]),
            (y = -(b - w)),
            (S = _ - v),
            (N = Math.sqrt(y * y + S * S)),
            (y /= N),
            (S /= N),
            (y *= m),
            (S *= m),
            (R = -(w - P)),
            (G = v - x),
            (N = Math.sqrt(R * R + G * G)),
            (R /= N),
            (G /= N),
            (R *= m),
            (G *= m))
        const E = v - _,
            B = b - w,
            C = v - x,
            M = P - w,
            D = E * C + B * M,
            F = B * C - M * E,
            H = F < 0
        if (Math.abs(F) < 0.001 * Math.abs(D)) {
            ;(u.push(v - y * O, w - S * O, v + y * L, w + S * L),
                D >= 0 &&
                    (n.join === de.ROUND
                        ? (d +=
                              Mi(
                                  v,
                                  w,
                                  v - y * O,
                                  w - S * O,
                                  v - R * O,
                                  w - G * O,
                                  u,
                                  !1,
                              ) + 4)
                        : (d += 2),
                    u.push(v - R * L, w - G * L, v + R * O, w + G * O)))
            continue
        }
        const z = (-y + _) * (-S + w) - (-y + v) * (-S + b),
            K = (-R + x) * (-G + w) - (-R + v) * (-G + P),
            Z = (E * K - C * z) / F,
            J = (M * z - B * K) / F,
            rt = (Z - v) * (Z - v) + (J - w) * (J - w),
            W = v + (Z - v) * O,
            et = w + (J - w) * O,
            st = v - (Z - v) * L,
            ht = w - (J - w) * L,
            pt = Math.min(E * E + B * B, C * C + M * M),
            it = H ? O : L,
            nt = pt + it * it * p,
            Mt = rt <= nt
        let kt = n.join
        if ((kt === de.MITER && rt / p > g && (kt = de.BEVEL), Mt))
            switch (kt) {
                case de.MITER: {
                    u.push(W, et, st, ht)
                    break
                }
                case de.BEVEL: {
                    ;(H
                        ? u.push(
                              W,
                              et,
                              v + y * L,
                              w + S * L,
                              W,
                              et,
                              v + R * L,
                              w + G * L,
                          )
                        : u.push(
                              v - y * O,
                              w - S * O,
                              st,
                              ht,
                              v - R * O,
                              w - G * O,
                              st,
                              ht,
                          ),
                        (d += 2))
                    break
                }
                case de.ROUND: {
                    H
                        ? (u.push(W, et, v + y * L, w + S * L),
                          (d +=
                              Mi(
                                  v,
                                  w,
                                  v + y * L,
                                  w + S * L,
                                  v + R * L,
                                  w + G * L,
                                  u,
                                  !0,
                              ) + 4),
                          u.push(W, et, v + R * L, w + G * L))
                        : (u.push(v - y * O, w - S * O, st, ht),
                          (d +=
                              Mi(
                                  v,
                                  w,
                                  v - y * O,
                                  w - S * O,
                                  v - R * O,
                                  w - G * O,
                                  u,
                                  !1,
                              ) + 4),
                          u.push(v - R * O, w - G * O, st, ht))
                    break
                }
            }
        else {
            switch ((u.push(v - y * O, w - S * O, v + y * L, w + S * L), kt)) {
                case de.MITER: {
                    ;(H ? u.push(st, ht, st, ht) : u.push(W, et, W, et),
                        (d += 2))
                    break
                }
                case de.ROUND: {
                    H
                        ? (d +=
                              Mi(
                                  v,
                                  w,
                                  v + y * L,
                                  w + S * L,
                                  v + R * L,
                                  w + G * L,
                                  u,
                                  !0,
                              ) + 2)
                        : (d +=
                              Mi(
                                  v,
                                  w,
                                  v - y * O,
                                  w - S * O,
                                  v - R * O,
                                  w - G * O,
                                  u,
                                  !1,
                              ) + 2)
                    break
                }
            }
            ;(u.push(v - R * O, w - G * O, v + R * L, w + G * L), (d += 2))
        }
    }
    ;((_ = i[(c - 2) * 2]),
        (b = i[(c - 2) * 2 + 1]),
        (v = i[(c - 1) * 2]),
        (w = i[(c - 1) * 2 + 1]),
        (y = -(b - w)),
        (S = _ - v),
        (N = Math.sqrt(y * y + S * S)),
        (y /= N),
        (S /= N),
        (y *= m),
        (S *= m),
        u.push(v - y * O, w - S * O, v + y * L, w + S * L),
        h ||
            (n.cap === gi.ROUND
                ? (d +=
                      Mi(
                          v - y * (O - L) * 0.5,
                          w - S * (O - L) * 0.5,
                          v - y * O,
                          w - S * O,
                          v + y * L,
                          w + S * L,
                          u,
                          !1,
                      ) + 2)
                : n.cap === gi.SQUARE && (d += Vc(v, w, y, S, O, L, !1, u))))
    const V = t.indices,
        T = Dr.epsilon * Dr.epsilon
    for (let A = f; A < d + f - 2; ++A)
        ((_ = u[A * 2]),
            (b = u[A * 2 + 1]),
            (v = u[(A + 1) * 2]),
            (w = u[(A + 1) * 2 + 1]),
            (x = u[(A + 2) * 2]),
            (P = u[(A + 2) * 2 + 1]),
            !(Math.abs(_ * (w - P) + v * (P - b) + x * (b - w)) < T) &&
                V.push(A, A + 1, A + 2))
}
function X0(s, t) {
    let e = 0
    const i = s.shape,
        r = s.points || i.points,
        n = i.type !== Vt.POLY || i.closeStroke
    if (r.length === 0) return
    const a = t.points,
        o = t.indices,
        h = r.length / 2,
        l = a.length / 2
    let u = l
    for (a.push(r[0], r[1]), e = 1; e < h; e++)
        (a.push(r[e * 2], r[e * 2 + 1]), o.push(u, u + 1), u++)
    n && o.push(u, l)
}
function Xc(s, t) {
    s.lineStyle.native ? X0(s, t) : V0(s, t)
}
class qh {
    static curveLength(t, e, i, r, n, a) {
        const o = t - 2 * i + n,
            h = e - 2 * r + a,
            l = 2 * i - 2 * t,
            u = 2 * r - 2 * e,
            c = 4 * (o * o + h * h),
            d = 4 * (o * l + h * u),
            f = l * l + u * u,
            m = 2 * Math.sqrt(c + d + f),
            p = Math.sqrt(c),
            g = 2 * c * p,
            _ = 2 * Math.sqrt(f),
            b = d / p
        return (
            (g * m +
                p * d * (m - _) +
                (4 * f * c - d * d) * Math.log((2 * p + b + m) / (b + _))) /
            (4 * g)
        )
    }
    static curveTo(t, e, i, r, n) {
        const a = n[n.length - 2],
            o = n[n.length - 1],
            h = Dr._segmentsCount(qh.curveLength(a, o, t, e, i, r))
        let l = 0,
            u = 0
        for (let c = 1; c <= h; ++c) {
            const d = c / h
            ;((l = a + (t - a) * d),
                (u = o + (e - o) * d),
                n.push(
                    l + (t + (i - t) * d - l) * d,
                    u + (e + (r - e) * d - u) * d,
                ))
        }
    }
}
const xo = {
        [Vt.POLY]: If,
        [Vt.CIRC]: Tn,
        [Vt.ELIP]: Tn,
        [Vt.RECT]: G0,
        [Vt.RREC]: H0,
    },
    Wc = [],
    Ws = []
class En {
    constructor(t, e = null, i = null, r = null) {
        ;((this.points = []),
            (this.holes = []),
            (this.shape = t),
            (this.lineStyle = i),
            (this.fillStyle = e),
            (this.matrix = r),
            (this.type = t.type))
    }
    clone() {
        return new En(this.shape, this.fillStyle, this.lineStyle, this.matrix)
    }
    destroy() {
        ;((this.shape = null),
            (this.holes.length = 0),
            (this.holes = null),
            (this.points.length = 0),
            (this.points = null),
            (this.lineStyle = null),
            (this.fillStyle = null))
    }
}
const ur = new ut(),
    Mf = class Df extends Od {
        constructor() {
            ;(super(),
                (this.closePointEps = 1e-4),
                (this.boundsPadding = 0),
                (this.uvsFloat32 = null),
                (this.indicesUint16 = null),
                (this.batchable = !1),
                (this.points = []),
                (this.colors = []),
                (this.uvs = []),
                (this.indices = []),
                (this.textureIds = []),
                (this.graphicsData = []),
                (this.drawCalls = []),
                (this.batchDirty = -1),
                (this.batches = []),
                (this.dirty = 0),
                (this.cacheDirty = -1),
                (this.clearDirty = 0),
                (this.shapeIndex = 0),
                (this._bounds = new vn()),
                (this.boundsDirty = -1))
        }
        get bounds() {
            return (
                this.updateBatches(),
                this.boundsDirty !== this.dirty &&
                    ((this.boundsDirty = this.dirty), this.calculateBounds()),
                this._bounds
            )
        }
        invalidate() {
            ;((this.boundsDirty = -1),
                this.dirty++,
                this.batchDirty++,
                (this.shapeIndex = 0),
                (this.points.length = 0),
                (this.colors.length = 0),
                (this.uvs.length = 0),
                (this.indices.length = 0),
                (this.textureIds.length = 0))
            for (let t = 0; t < this.drawCalls.length; t++)
                (this.drawCalls[t].texArray.clear(), Ws.push(this.drawCalls[t]))
            this.drawCalls.length = 0
            for (let t = 0; t < this.batches.length; t++) {
                const e = this.batches[t]
                ;(e.reset(), Wc.push(e))
            }
            this.batches.length = 0
        }
        clear() {
            return (
                this.graphicsData.length > 0 &&
                    (this.invalidate(),
                    this.clearDirty++,
                    (this.graphicsData.length = 0)),
                this
            )
        }
        drawShape(t, e = null, i = null, r = null) {
            const n = new En(t, e, i, r)
            return (this.graphicsData.push(n), this.dirty++, this)
        }
        drawHole(t, e = null) {
            if (!this.graphicsData.length) return null
            const i = new En(t, null, null, e),
                r = this.graphicsData[this.graphicsData.length - 1]
            return (
                (i.lineStyle = r.lineStyle),
                r.holes.push(i),
                this.dirty++,
                this
            )
        }
        destroy() {
            super.destroy()
            for (let t = 0; t < this.graphicsData.length; ++t)
                this.graphicsData[t].destroy()
            ;((this.points.length = 0),
                (this.points = null),
                (this.colors.length = 0),
                (this.colors = null),
                (this.uvs.length = 0),
                (this.uvs = null),
                (this.indices.length = 0),
                (this.indices = null),
                this.indexBuffer.destroy(),
                (this.indexBuffer = null),
                (this.graphicsData.length = 0),
                (this.graphicsData = null),
                (this.drawCalls.length = 0),
                (this.drawCalls = null),
                (this.batches.length = 0),
                (this.batches = null),
                (this._bounds = null))
        }
        containsPoint(t) {
            const e = this.graphicsData
            for (let i = 0; i < e.length; ++i) {
                const r = e[i]
                if (
                    r.fillStyle.visible &&
                    r.shape &&
                    (r.matrix ? r.matrix.applyInverse(t, ur) : ur.copyFrom(t),
                    r.shape.contains(ur.x, ur.y))
                ) {
                    let n = !1
                    if (r.holes) {
                        for (let a = 0; a < r.holes.length; a++)
                            if (r.holes[a].shape.contains(ur.x, ur.y)) {
                                n = !0
                                break
                            }
                    }
                    if (!n) return !0
                }
            }
            return !1
        }
        updateBatches() {
            if (!this.graphicsData.length) {
                this.batchable = !0
                return
            }
            if (!this.validateBatching()) return
            this.cacheDirty = this.dirty
            const t = this.uvs,
                e = this.graphicsData
            let i = null,
                r = null
            this.batches.length > 0 &&
                ((i = this.batches[this.batches.length - 1]), (r = i.style))
            for (let h = this.shapeIndex; h < e.length; h++) {
                this.shapeIndex++
                const l = e[h],
                    u = l.fillStyle,
                    c = l.lineStyle
                ;(xo[l.type].build(l),
                    l.matrix && this.transformPoints(l.points, l.matrix),
                    (u.visible || c.visible) && this.processHoles(l.holes))
                for (let d = 0; d < 2; d++) {
                    const f = d === 0 ? u : c
                    if (!f.visible) continue
                    const m = f.texture.baseTexture,
                        p = this.indices.length,
                        g = this.points.length / 2
                    ;((m.wrapMode = xi.REPEAT),
                        d === 0 ? this.processFill(l) : this.processLine(l))
                    const _ = this.points.length / 2 - g
                    _ !== 0 &&
                        (i &&
                            !this._compareStyles(r, f) &&
                            (i.end(p, g), (i = null)),
                        i ||
                            ((i = Wc.pop() || new z0()),
                            i.begin(f, p, g),
                            this.batches.push(i),
                            (r = f)),
                        this.addUvs(this.points, t, f.texture, g, _, f.matrix))
                }
            }
            const n = this.indices.length,
                a = this.points.length / 2
            if ((i && i.end(n, a), this.batches.length === 0)) {
                this.batchable = !0
                return
            }
            const o = a > 65535
            ;(this.indicesUint16 &&
            this.indices.length === this.indicesUint16.length &&
            o === this.indicesUint16.BYTES_PER_ELEMENT > 2
                ? this.indicesUint16.set(this.indices)
                : (this.indicesUint16 = o
                      ? new Uint32Array(this.indices)
                      : new Uint16Array(this.indices)),
                (this.batchable = this.isBatchable()),
                this.batchable ? this.packBatches() : this.buildDrawCalls())
        }
        _compareStyles(t, e) {
            return !(
                !t ||
                !e ||
                t.texture.baseTexture !== e.texture.baseTexture ||
                t.color + t.alpha !== e.color + e.alpha ||
                !!t.native != !!e.native
            )
        }
        validateBatching() {
            if (this.dirty === this.cacheDirty || !this.graphicsData.length)
                return !1
            for (let t = 0, e = this.graphicsData.length; t < e; t++) {
                const i = this.graphicsData[t],
                    r = i.fillStyle,
                    n = i.lineStyle
                if (
                    (r && !r.texture.baseTexture.valid) ||
                    (n && !n.texture.baseTexture.valid)
                )
                    return !1
            }
            return !0
        }
        packBatches() {
            ;(this.batchDirty++, (this.uvsFloat32 = new Float32Array(this.uvs)))
            const t = this.batches
            for (let e = 0, i = t.length; e < i; e++) {
                const r = t[e]
                for (let n = 0; n < r.size; n++) {
                    const a = r.start + n
                    this.indicesUint16[a] =
                        this.indicesUint16[a] - r.attribStart
                }
            }
        }
        isBatchable() {
            if (this.points.length > 65535 * 2) return !1
            const t = this.batches
            for (let e = 0; e < t.length; e++) if (t[e].style.native) return !1
            return this.points.length < Df.BATCHABLE_SIZE * 2
        }
        buildDrawCalls() {
            let t = ++lt._globalBatch
            for (let c = 0; c < this.drawCalls.length; c++)
                (this.drawCalls[c].texArray.clear(), Ws.push(this.drawCalls[c]))
            this.drawCalls.length = 0
            const e = this.colors,
                i = this.textureIds
            let r = Ws.pop()
            ;(r || ((r = new Wo()), (r.texArray = new Ko())),
                (r.texArray.count = 0),
                (r.start = 0),
                (r.size = 0),
                (r.type = Ue.TRIANGLES))
            let n = 0,
                a = null,
                o = 0,
                h = !1,
                l = Ue.TRIANGLES,
                u = 0
            this.drawCalls.push(r)
            for (let c = 0; c < this.batches.length; c++) {
                const d = this.batches[c],
                    f = 8,
                    m = d.style,
                    p = m.texture.baseTexture
                ;(h !== !!m.native &&
                    ((h = !!m.native),
                    (l = h ? Ue.LINES : Ue.TRIANGLES),
                    (a = null),
                    (n = f),
                    t++),
                    a !== p &&
                        ((a = p),
                        p._batchEnabled !== t &&
                            (n === f &&
                                (t++,
                                (n = 0),
                                r.size > 0 &&
                                    ((r = Ws.pop()),
                                    r ||
                                        ((r = new Wo()),
                                        (r.texArray = new Ko())),
                                    this.drawCalls.push(r)),
                                (r.start = u),
                                (r.size = 0),
                                (r.texArray.count = 0),
                                (r.type = l)),
                            (p.touched = 1),
                            (p._batchEnabled = t),
                            (p._batchLocation = n),
                            (p.wrapMode = xi.REPEAT),
                            (r.texArray.elements[r.texArray.count++] = p),
                            n++)),
                    (r.size += d.size),
                    (u += d.size),
                    (o = p._batchLocation),
                    this.addColors(
                        e,
                        m.color,
                        m.alpha,
                        d.attribSize,
                        d.attribStart,
                    ),
                    this.addTextureIds(i, o, d.attribSize, d.attribStart))
            }
            ;((lt._globalBatch = t), this.packAttributes())
        }
        packAttributes() {
            const t = this.points,
                e = this.uvs,
                i = this.colors,
                r = this.textureIds,
                n = new ArrayBuffer(t.length * 3 * 4),
                a = new Float32Array(n),
                o = new Uint32Array(n)
            let h = 0
            for (let l = 0; l < t.length / 2; l++)
                ((a[h++] = t[l * 2]),
                    (a[h++] = t[l * 2 + 1]),
                    (a[h++] = e[l * 2]),
                    (a[h++] = e[l * 2 + 1]),
                    (o[h++] = i[l]),
                    (a[h++] = r[l]))
            ;(this._buffer.update(n),
                this._indexBuffer.update(this.indicesUint16))
        }
        processFill(t) {
            t.holes.length
                ? If.triangulate(t, this)
                : xo[t.type].triangulate(t, this)
        }
        processLine(t) {
            Xc(t, this)
            for (let e = 0; e < t.holes.length; e++) Xc(t.holes[e], this)
        }
        processHoles(t) {
            for (let e = 0; e < t.length; e++) {
                const i = t[e]
                ;(xo[i.type].build(i),
                    i.matrix && this.transformPoints(i.points, i.matrix))
            }
        }
        calculateBounds() {
            const t = this._bounds
            ;(t.clear(),
                t.addVertexData(this.points, 0, this.points.length),
                t.pad(this.boundsPadding, this.boundsPadding))
        }
        transformPoints(t, e) {
            for (let i = 0; i < t.length / 2; i++) {
                const r = t[i * 2],
                    n = t[i * 2 + 1]
                ;((t[i * 2] = e.a * r + e.c * n + e.tx),
                    (t[i * 2 + 1] = e.b * r + e.d * n + e.ty))
            }
        }
        addColors(t, e, i, r, n = 0) {
            const a = Tt.shared.setValue(e).toLittleEndianNumber(),
                o = Tt.shared.setValue(a).toPremultiplied(i)
            t.length = Math.max(t.length, n + r)
            for (let h = 0; h < r; h++) t[n + h] = o
        }
        addTextureIds(t, e, i, r = 0) {
            t.length = Math.max(t.length, r + i)
            for (let n = 0; n < i; n++) t[r + n] = e
        }
        addUvs(t, e, i, r, n, a = null) {
            let o = 0
            const h = e.length,
                l = i.frame
            for (; o < n; ) {
                let c = t[(r + o) * 2],
                    d = t[(r + o) * 2 + 1]
                if (a) {
                    const f = a.a * c + a.c * d + a.tx
                    ;((d = a.b * c + a.d * d + a.ty), (c = f))
                }
                ;(o++, e.push(c / l.width, d / l.height))
            }
            const u = i.baseTexture
            ;(l.width < u.width || l.height < u.height) &&
                this.adjustUvs(e, i, h, n)
        }
        adjustUvs(t, e, i, r) {
            const n = e.baseTexture,
                a = 1e-6,
                o = i + r * 2,
                h = e.frame,
                l = h.width / n.width,
                u = h.height / n.height
            let c = h.x / h.width,
                d = h.y / h.height,
                f = Math.floor(t[i] + a),
                m = Math.floor(t[i + 1] + a)
            for (let p = i + 2; p < o; p += 2)
                ((f = Math.min(f, Math.floor(t[p] + a))),
                    (m = Math.min(m, Math.floor(t[p + 1] + a))))
            ;((c -= f), (d -= m))
            for (let p = i; p < o; p += 2)
                ((t[p] = (t[p] + c) * l), (t[p + 1] = (t[p + 1] + d) * u))
        }
    }
Mf.BATCHABLE_SIZE = 100
let W0 = Mf
class Hn {
    constructor() {
        ;((this.color = 16777215),
            (this.alpha = 1),
            (this.texture = j.WHITE),
            (this.matrix = null),
            (this.visible = !1),
            this.reset())
    }
    clone() {
        const t = new Hn()
        return (
            (t.color = this.color),
            (t.alpha = this.alpha),
            (t.texture = this.texture),
            (t.matrix = this.matrix),
            (t.visible = this.visible),
            t
        )
    }
    reset() {
        ;((this.color = 16777215),
            (this.alpha = 1),
            (this.texture = j.WHITE),
            (this.matrix = null),
            (this.visible = !1))
    }
    destroy() {
        ;((this.texture = null), (this.matrix = null))
    }
}
class Yh extends Hn {
    constructor() {
        ;(super(...arguments),
            (this.width = 0),
            (this.alignment = 0.5),
            (this.native = !1),
            (this.cap = gi.BUTT),
            (this.join = de.MITER),
            (this.miterLimit = 10))
    }
    clone() {
        const t = new Yh()
        return (
            (t.color = this.color),
            (t.alpha = this.alpha),
            (t.texture = this.texture),
            (t.matrix = this.matrix),
            (t.visible = this.visible),
            (t.width = this.width),
            (t.alignment = this.alignment),
            (t.native = this.native),
            (t.cap = this.cap),
            (t.join = this.join),
            (t.miterLimit = this.miterLimit),
            t
        )
    }
    reset() {
        ;(super.reset(),
            (this.color = 0),
            (this.alignment = 0.5),
            (this.width = 0),
            (this.native = !1),
            (this.cap = gi.BUTT),
            (this.join = de.MITER),
            (this.miterLimit = 10))
    }
}
const bo = {},
    mh = class nn extends Kt {
        constructor(t = null) {
            ;(super(),
                (this.shader = null),
                (this.pluginName = 'batch'),
                (this.currentPath = null),
                (this.batches = []),
                (this.batchTint = -1),
                (this.batchDirty = -1),
                (this.vertexData = null),
                (this._fillStyle = new Hn()),
                (this._lineStyle = new Yh()),
                (this._matrix = null),
                (this._holeMode = !1),
                (this.state = $e.for2d()),
                (this._geometry = t || new W0()),
                this._geometry.refCount++,
                (this._transformID = -1),
                (this._tintColor = new Tt(16777215)),
                (this.blendMode = ot.NORMAL))
        }
        get geometry() {
            return this._geometry
        }
        clone() {
            return (this.finishPoly(), new nn(this._geometry))
        }
        set blendMode(t) {
            this.state.blendMode = t
        }
        get blendMode() {
            return this.state.blendMode
        }
        get tint() {
            return this._tintColor.value
        }
        set tint(t) {
            this._tintColor.setValue(t)
        }
        get fill() {
            return this._fillStyle
        }
        get line() {
            return this._lineStyle
        }
        lineStyle(t = null, e = 0, i, r = 0.5, n = !1) {
            return (
                typeof t == 'number' &&
                    (t = {
                        width: t,
                        color: e,
                        alpha: i,
                        alignment: r,
                        native: n,
                    }),
                this.lineTextureStyle(t)
            )
        }
        lineTextureStyle(t) {
            const e = {
                width: 0,
                texture: j.WHITE,
                color: t?.texture ? 16777215 : 0,
                matrix: null,
                alignment: 0.5,
                native: !1,
                cap: gi.BUTT,
                join: de.MITER,
                miterLimit: 10,
            }
            ;((t = Object.assign(e, t)),
                this.normalizeColor(t),
                this.currentPath && this.startPoly())
            const i = t.width > 0 && t.alpha > 0
            return (
                i
                    ? (t.matrix &&
                          ((t.matrix = t.matrix.clone()), t.matrix.invert()),
                      Object.assign(this._lineStyle, { visible: i }, t))
                    : this._lineStyle.reset(),
                this
            )
        }
        startPoly() {
            if (this.currentPath) {
                const t = this.currentPath.points,
                    e = this.currentPath.points.length
                e > 2 &&
                    (this.drawShape(this.currentPath),
                    (this.currentPath = new Wi()),
                    (this.currentPath.closeStroke = !1),
                    this.currentPath.points.push(t[e - 2], t[e - 1]))
            } else
                ((this.currentPath = new Wi()),
                    (this.currentPath.closeStroke = !1))
        }
        finishPoly() {
            this.currentPath &&
                (this.currentPath.points.length > 2
                    ? (this.drawShape(this.currentPath),
                      (this.currentPath = null))
                    : (this.currentPath.points.length = 0))
        }
        moveTo(t, e) {
            return (
                this.startPoly(),
                (this.currentPath.points[0] = t),
                (this.currentPath.points[1] = e),
                this
            )
        }
        lineTo(t, e) {
            this.currentPath || this.moveTo(0, 0)
            const i = this.currentPath.points,
                r = i[i.length - 2],
                n = i[i.length - 1]
            return ((r !== t || n !== e) && i.push(t, e), this)
        }
        _initCurve(t = 0, e = 0) {
            this.currentPath
                ? this.currentPath.points.length === 0 &&
                  (this.currentPath.points = [t, e])
                : this.moveTo(t, e)
        }
        quadraticCurveTo(t, e, i, r) {
            this._initCurve()
            const n = this.currentPath.points
            return (
                n.length === 0 && this.moveTo(0, 0),
                qh.curveTo(t, e, i, r, n),
                this
            )
        }
        bezierCurveTo(t, e, i, r, n, a) {
            return (
                this._initCurve(),
                jh.curveTo(t, e, i, r, n, a, this.currentPath.points),
                this
            )
        }
        arcTo(t, e, i, r, n) {
            this._initCurve(t, e)
            const a = this.currentPath.points,
                o = zc.curveTo(t, e, i, r, n, a)
            if (o) {
                const {
                    cx: h,
                    cy: l,
                    radius: u,
                    startAngle: c,
                    endAngle: d,
                    anticlockwise: f,
                } = o
                this.arc(h, l, u, c, d, f)
            }
            return this
        }
        arc(t, e, i, r, n, a = !1) {
            if (r === n) return this
            if (
                (!a && n <= r ? (n += pn) : a && r <= n && (r += pn),
                n - r === 0)
            )
                return this
            const o = t + Math.cos(r) * i,
                h = e + Math.sin(r) * i,
                l = this._geometry.closePointEps
            let u = this.currentPath ? this.currentPath.points : null
            if (u) {
                const c = Math.abs(u[u.length - 2] - o),
                    d = Math.abs(u[u.length - 1] - h)
                ;(c < l && d < l) || u.push(o, h)
            } else (this.moveTo(o, h), (u = this.currentPath.points))
            return (zc.arc(o, h, t, e, i, r, n, a, u), this)
        }
        beginFill(t = 0, e) {
            return this.beginTextureFill({
                texture: j.WHITE,
                color: t,
                alpha: e,
            })
        }
        normalizeColor(t) {
            const e = Tt.shared.setValue(t.color ?? 0)
            ;((t.color = e.toNumber()), t.alpha ?? (t.alpha = e.alpha))
        }
        beginTextureFill(t) {
            const e = { texture: j.WHITE, color: 16777215, matrix: null }
            ;((t = Object.assign(e, t)),
                this.normalizeColor(t),
                this.currentPath && this.startPoly())
            const i = t.alpha > 0
            return (
                i
                    ? (t.matrix &&
                          ((t.matrix = t.matrix.clone()), t.matrix.invert()),
                      Object.assign(this._fillStyle, { visible: i }, t))
                    : this._fillStyle.reset(),
                this
            )
        }
        endFill() {
            return (this.finishPoly(), this._fillStyle.reset(), this)
        }
        drawRect(t, e, i, r) {
            return this.drawShape(new dt(t, e, i, r))
        }
        drawRoundedRect(t, e, i, r, n) {
            return this.drawShape(new Nn(t, e, i, r, n))
        }
        drawCircle(t, e, i) {
            return this.drawShape(new Ln(t, e, i))
        }
        drawEllipse(t, e, i, r) {
            return this.drawShape(new kn(t, e, i, r))
        }
        drawPolygon(...t) {
            let e,
                i = !0
            const r = t[0]
            r.points
                ? ((i = r.closeStroke), (e = r.points))
                : Array.isArray(t[0])
                  ? (e = t[0])
                  : (e = t)
            const n = new Wi(e)
            return ((n.closeStroke = i), this.drawShape(n), this)
        }
        drawShape(t) {
            return (
                this._holeMode
                    ? this._geometry.drawHole(t, this._matrix)
                    : this._geometry.drawShape(
                          t,
                          this._fillStyle.clone(),
                          this._lineStyle.clone(),
                          this._matrix,
                      ),
                this
            )
        }
        clear() {
            return (
                this._geometry.clear(),
                this._lineStyle.reset(),
                this._fillStyle.reset(),
                this._boundsID++,
                (this._matrix = null),
                (this._holeMode = !1),
                (this.currentPath = null),
                this
            )
        }
        isFastRect() {
            const t = this._geometry.graphicsData
            return (
                t.length === 1 &&
                t[0].shape.type === Vt.RECT &&
                !t[0].matrix &&
                !t[0].holes.length &&
                !(t[0].lineStyle.visible && t[0].lineStyle.width)
            )
        }
        _render(t) {
            this.finishPoly()
            const e = this._geometry
            ;(e.updateBatches(),
                e.batchable
                    ? (this.batchDirty !== e.batchDirty &&
                          this._populateBatches(),
                      this._renderBatched(t))
                    : (t.batch.flush(), this._renderDirect(t)))
        }
        _populateBatches() {
            const t = this._geometry,
                e = this.blendMode,
                i = t.batches.length
            ;((this.batchTint = -1),
                (this._transformID = -1),
                (this.batchDirty = t.batchDirty),
                (this.batches.length = i),
                (this.vertexData = new Float32Array(t.points)))
            for (let r = 0; r < i; r++) {
                const n = t.batches[r],
                    a = n.style.color,
                    o = new Float32Array(
                        this.vertexData.buffer,
                        n.attribStart * 4 * 2,
                        n.attribSize * 2,
                    ),
                    h = new Float32Array(
                        t.uvsFloat32.buffer,
                        n.attribStart * 4 * 2,
                        n.attribSize * 2,
                    ),
                    l = new Uint16Array(
                        t.indicesUint16.buffer,
                        n.start * 2,
                        n.size,
                    ),
                    u = {
                        vertexData: o,
                        blendMode: e,
                        indices: l,
                        uvs: h,
                        _batchRGB: Tt.shared.setValue(a).toRgbArray(),
                        _tintRGB: a,
                        _texture: n.style.texture,
                        alpha: n.style.alpha,
                        worldAlpha: 1,
                    }
                this.batches[r] = u
            }
        }
        _renderBatched(t) {
            if (this.batches.length) {
                ;(t.batch.setObjectRenderer(t.plugins[this.pluginName]),
                    this.calculateVertices(),
                    this.calculateTints())
                for (let e = 0, i = this.batches.length; e < i; e++) {
                    const r = this.batches[e]
                    ;((r.worldAlpha = this.worldAlpha * r.alpha),
                        t.plugins[this.pluginName].render(r))
                }
            }
        }
        _renderDirect(t) {
            const e = this._resolveDirectShader(t),
                i = this._geometry,
                r = this.worldAlpha,
                n = e.uniforms,
                a = i.drawCalls
            ;((n.translationMatrix = this.transform.worldTransform),
                Tt.shared
                    .setValue(this._tintColor)
                    .premultiply(r)
                    .toArray(n.tint),
                t.shader.bind(e),
                t.geometry.bind(i, e),
                t.state.set(this.state))
            for (let o = 0, h = a.length; o < h; o++)
                this._renderDrawCallDirect(t, i.drawCalls[o])
        }
        _renderDrawCallDirect(t, e) {
            const { texArray: i, type: r, size: n, start: a } = e,
                o = i.count
            for (let h = 0; h < o; h++) t.texture.bind(i.elements[h], h)
            t.geometry.draw(r, n, a)
        }
        _resolveDirectShader(t) {
            let e = this.shader
            const i = this.pluginName
            if (!e) {
                if (!bo[i]) {
                    const { maxTextures: r } = t.plugins[i],
                        n = new Int32Array(r)
                    for (let h = 0; h < r; h++) n[h] = h
                    const a = {
                            tint: new Float32Array([1, 1, 1, 1]),
                            translationMatrix: new Et(),
                            default: Se.from({ uSamplers: n }, !0),
                        },
                        o = t.plugins[i]._shader.program
                    bo[i] = new Ve(o, a)
                }
                e = bo[i]
            }
            return e
        }
        _calculateBounds() {
            this.finishPoly()
            const t = this._geometry
            if (!t.graphicsData.length) return
            const { minX: e, minY: i, maxX: r, maxY: n } = t.bounds
            this._bounds.addFrame(this.transform, e, i, r, n)
        }
        containsPoint(t) {
            return (
                this.worldTransform.applyInverse(t, nn._TEMP_POINT),
                this._geometry.containsPoint(nn._TEMP_POINT)
            )
        }
        calculateTints() {
            if (this.batchTint !== this.tint) {
                this.batchTint = this._tintColor.toNumber()
                for (let t = 0; t < this.batches.length; t++) {
                    const e = this.batches[t]
                    e._tintRGB = Tt.shared
                        .setValue(this._tintColor)
                        .multiply(e._batchRGB)
                        .toLittleEndianNumber()
                }
            }
        }
        calculateVertices() {
            const t = this.transform._worldID
            if (this._transformID === t) return
            this._transformID = t
            const e = this.transform.worldTransform,
                i = e.a,
                r = e.b,
                n = e.c,
                a = e.d,
                o = e.tx,
                h = e.ty,
                l = this._geometry.points,
                u = this.vertexData
            let c = 0
            for (let d = 0; d < l.length; d += 2) {
                const f = l[d],
                    m = l[d + 1]
                ;((u[c++] = i * f + n * m + o), (u[c++] = a * m + r * f + h))
            }
        }
        closePath() {
            const t = this.currentPath
            return (t && ((t.closeStroke = !0), this.finishPoly()), this)
        }
        setMatrix(t) {
            return ((this._matrix = t), this)
        }
        beginHole() {
            return (this.finishPoly(), (this._holeMode = !0), this)
        }
        endHole() {
            return (this.finishPoly(), (this._holeMode = !1), this)
        }
        destroy(t) {
            ;(this._geometry.refCount--,
                this._geometry.refCount === 0 && this._geometry.dispose(),
                (this._matrix = null),
                (this.currentPath = null),
                this._lineStyle.destroy(),
                (this._lineStyle = null),
                this._fillStyle.destroy(),
                (this._fillStyle = null),
                (this._geometry = null),
                (this.shader = null),
                (this.vertexData = null),
                (this.batches.length = 0),
                (this.batches = null),
                super.destroy(t))
        }
    }
;((mh.curves = Dr), (mh._TEMP_POINT = new ut()))
let Kh = mh
class $0 {
    constructor(t, e) {
        ;((this.uvBuffer = t),
            (this.uvMatrix = e),
            (this.data = null),
            (this._bufferUpdateId = -1),
            (this._textureUpdateId = -1),
            (this._updateID = 0))
    }
    update(t) {
        if (
            !t &&
            this._bufferUpdateId === this.uvBuffer._updateID &&
            this._textureUpdateId === this.uvMatrix._updateID
        )
            return
        ;((this._bufferUpdateId = this.uvBuffer._updateID),
            (this._textureUpdateId = this.uvMatrix._updateID))
        const e = this.uvBuffer.data
        ;((!this.data || this.data.length !== e.length) &&
            (this.data = new Float32Array(e.length)),
            this.uvMatrix.multiplyUvs(e, this.data),
            this._updateID++)
    }
}
const wo = new ut(),
    $c = new Wi(),
    Bf = class Of extends Kt {
        constructor(t, e, i, r = Ue.TRIANGLES) {
            ;(super(),
                (this.geometry = t),
                (this.shader = e),
                (this.state = i || $e.for2d()),
                (this.drawMode = r),
                (this.start = 0),
                (this.size = 0),
                (this.uvs = null),
                (this.indices = null),
                (this.vertexData = new Float32Array(1)),
                (this.vertexDirty = -1),
                (this._transformID = -1),
                (this._roundPixels = Y.ROUND_PIXELS),
                (this.batchUvs = null))
        }
        get geometry() {
            return this._geometry
        }
        set geometry(t) {
            this._geometry !== t &&
                (this._geometry &&
                    (this._geometry.refCount--,
                    this._geometry.refCount === 0 && this._geometry.dispose()),
                (this._geometry = t),
                this._geometry && this._geometry.refCount++,
                (this.vertexDirty = -1))
        }
        get uvBuffer() {
            return this.geometry.buffers[1]
        }
        get verticesBuffer() {
            return this.geometry.buffers[0]
        }
        set material(t) {
            this.shader = t
        }
        get material() {
            return this.shader
        }
        set blendMode(t) {
            this.state.blendMode = t
        }
        get blendMode() {
            return this.state.blendMode
        }
        set roundPixels(t) {
            ;(this._roundPixels !== t && (this._transformID = -1),
                (this._roundPixels = t))
        }
        get roundPixels() {
            return this._roundPixels
        }
        get tint() {
            return 'tint' in this.shader ? this.shader.tint : null
        }
        set tint(t) {
            this.shader.tint = t
        }
        get tintValue() {
            return this.shader.tintValue
        }
        get texture() {
            return 'texture' in this.shader ? this.shader.texture : null
        }
        set texture(t) {
            this.shader.texture = t
        }
        _render(t) {
            const e = this.geometry.buffers[0].data
            this.shader.batchable &&
            this.drawMode === Ue.TRIANGLES &&
            e.length < Of.BATCHABLE_SIZE * 2
                ? this._renderToBatch(t)
                : this._renderDefault(t)
        }
        _renderDefault(t) {
            const e = this.shader
            ;((e.alpha = this.worldAlpha),
                e.update && e.update(),
                t.batch.flush(),
                (e.uniforms.translationMatrix =
                    this.transform.worldTransform.toArray(!0)),
                t.shader.bind(e),
                t.state.set(this.state),
                t.geometry.bind(this.geometry, e),
                t.geometry.draw(
                    this.drawMode,
                    this.size,
                    this.start,
                    this.geometry.instanceCount,
                ))
        }
        _renderToBatch(t) {
            const e = this.geometry,
                i = this.shader
            ;(i.uvMatrix && (i.uvMatrix.update(), this.calculateUvs()),
                this.calculateVertices(),
                (this.indices = e.indexBuffer.data),
                (this._tintRGB = i._tintRGB),
                (this._texture = i.texture))
            const r = this.material.pluginName
            ;(t.batch.setObjectRenderer(t.plugins[r]),
                t.plugins[r].render(this))
        }
        calculateVertices() {
            const t = this.geometry.buffers[0],
                e = t.data,
                i = t._updateID
            if (
                i === this.vertexDirty &&
                this._transformID === this.transform._worldID
            )
                return
            ;((this._transformID = this.transform._worldID),
                this.vertexData.length !== e.length &&
                    (this.vertexData = new Float32Array(e.length)))
            const r = this.transform.worldTransform,
                n = r.a,
                a = r.b,
                o = r.c,
                h = r.d,
                l = r.tx,
                u = r.ty,
                c = this.vertexData
            for (let d = 0; d < c.length / 2; d++) {
                const f = e[d * 2],
                    m = e[d * 2 + 1]
                ;((c[d * 2] = n * f + o * m + l),
                    (c[d * 2 + 1] = a * f + h * m + u))
            }
            if (this._roundPixels) {
                const d = Y.RESOLUTION
                for (let f = 0; f < c.length; ++f)
                    c[f] = Math.round(c[f] * d) / d
            }
            this.vertexDirty = i
        }
        calculateUvs() {
            const t = this.geometry.buffers[1],
                e = this.shader
            e.uvMatrix.isSimple
                ? (this.uvs = t.data)
                : (this.batchUvs || (this.batchUvs = new $0(t, e.uvMatrix)),
                  this.batchUvs.update(),
                  (this.uvs = this.batchUvs.data))
        }
        _calculateBounds() {
            ;(this.calculateVertices(),
                this._bounds.addVertexData(
                    this.vertexData,
                    0,
                    this.vertexData.length,
                ))
        }
        containsPoint(t) {
            if (!this.getBounds().contains(t.x, t.y)) return !1
            this.worldTransform.applyInverse(t, wo)
            const e = this.geometry.getBuffer('aVertexPosition').data,
                i = $c.points,
                r = this.geometry.getIndex().data,
                n = r.length,
                a = this.drawMode === 4 ? 3 : 1
            for (let o = 0; o + 2 < n; o += a) {
                const h = r[o] * 2,
                    l = r[o + 1] * 2,
                    u = r[o + 2] * 2
                if (
                    ((i[0] = e[h]),
                    (i[1] = e[h + 1]),
                    (i[2] = e[l]),
                    (i[3] = e[l + 1]),
                    (i[4] = e[u]),
                    (i[5] = e[u + 1]),
                    $c.contains(wo.x, wo.y))
                )
                    return !0
            }
            return !1
        }
        destroy(t) {
            ;(super.destroy(t),
                this._cachedTexture &&
                    (this._cachedTexture.destroy(),
                    (this._cachedTexture = null)),
                (this.geometry = null),
                (this.shader = null),
                (this.state = null),
                (this.uvs = null),
                (this.indices = null),
                (this.vertexData = null))
        }
    }
Bf.BATCHABLE_SIZE = 100
let gh = Bf
class Ff extends Ti {
    constructor(t, e, i) {
        super()
        const r = new Bt(t),
            n = new Bt(e, !0),
            a = new Bt(i, !0, !0)
        ;(this.addAttribute('aVertexPosition', r, 2, !1, at.FLOAT)
            .addAttribute('aTextureCoord', n, 2, !1, at.FLOAT)
            .addIndex(a),
            (this._updateId = -1))
    }
    get vertexDirtyId() {
        return this.buffers[0]._updateID
    }
}
var j0 = `varying vec2 vTextureCoord;
uniform vec4 uColor;

uniform sampler2D uSampler;

void main(void)
{
    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;
}
`,
    q0 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTextureMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;
}
`
class _h extends Ve {
    constructor(t, e) {
        const i = {
            uSampler: t,
            alpha: 1,
            uTextureMatrix: Et.IDENTITY,
            uColor: new Float32Array([1, 1, 1, 1]),
        }
        ;((e = Object.assign(
            { tint: 16777215, alpha: 1, pluginName: 'batch' },
            e,
        )),
            e.uniforms && Object.assign(i, e.uniforms),
            super(e.program || ti.from(q0, j0), i),
            (this._colorDirty = !1),
            (this.uvMatrix = new qd(t)),
            (this.batchable = e.program === void 0),
            (this.pluginName = e.pluginName),
            (this._tintColor = new Tt(e.tint)),
            (this._tintRGB = this._tintColor.toLittleEndianNumber()),
            (this._colorDirty = !0),
            (this.alpha = e.alpha))
    }
    get texture() {
        return this.uniforms.uSampler
    }
    set texture(t) {
        this.uniforms.uSampler !== t &&
            (!this.uniforms.uSampler.baseTexture.alphaMode !=
                !t.baseTexture.alphaMode && (this._colorDirty = !0),
            (this.uniforms.uSampler = t),
            (this.uvMatrix.texture = t))
    }
    set alpha(t) {
        t !== this._alpha && ((this._alpha = t), (this._colorDirty = !0))
    }
    get alpha() {
        return this._alpha
    }
    set tint(t) {
        t !== this.tint &&
            (this._tintColor.setValue(t),
            (this._tintRGB = this._tintColor.toLittleEndianNumber()),
            (this._colorDirty = !0))
    }
    get tint() {
        return this._tintColor.value
    }
    get tintValue() {
        return this._tintColor.toNumber()
    }
    update() {
        if (this._colorDirty) {
            this._colorDirty = !1
            const t = this.texture.baseTexture.alphaMode
            Tt.shared
                .setValue(this._tintColor)
                .premultiply(this._alpha, t)
                .toArray(this.uniforms.uColor)
        }
        this.uvMatrix.update() &&
            (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord)
    }
}
class Y0 extends Ff {
    constructor(t = 100, e = 100, i = 10, r = 10) {
        ;(super(),
            (this.segWidth = i),
            (this.segHeight = r),
            (this.width = t),
            (this.height = e),
            this.build())
    }
    build() {
        const t = this.segWidth * this.segHeight,
            e = [],
            i = [],
            r = [],
            n = this.segWidth - 1,
            a = this.segHeight - 1,
            o = this.width / n,
            h = this.height / a
        for (let u = 0; u < t; u++) {
            const c = u % this.segWidth,
                d = (u / this.segWidth) | 0
            ;(e.push(c * o, d * h), i.push(c / n, d / a))
        }
        const l = n * a
        for (let u = 0; u < l; u++) {
            const c = u % n,
                d = (u / n) | 0,
                f = d * this.segWidth + c,
                m = d * this.segWidth + c + 1,
                p = (d + 1) * this.segWidth + c,
                g = (d + 1) * this.segWidth + c + 1
            r.push(f, m, p, m, g, p)
        }
        ;((this.buffers[0].data = new Float32Array(e)),
            (this.buffers[1].data = new Float32Array(i)),
            (this.indexBuffer.data = new Uint16Array(r)),
            this.buffers[0].update(),
            this.buffers[1].update(),
            this.indexBuffer.update())
    }
}
class K0 extends gh {
    constructor(t, e, i) {
        const r = new Y0(t.width, t.height, e, i),
            n = new _h(j.WHITE)
        ;(super(r, n), (this.texture = t), (this.autoResize = !0))
    }
    textureUpdated() {
        this._textureID = this.shader.texture._updateID
        const t = this.geometry,
            { width: e, height: i } = this.shader.texture
        this.autoResize &&
            (t.width !== e || t.height !== i) &&
            ((t.width = this.shader.texture.width),
            (t.height = this.shader.texture.height),
            t.build())
    }
    set texture(t) {
        this.shader.texture !== t &&
            ((this.shader.texture = t),
            (this._textureID = -1),
            t.baseTexture.valid
                ? this.textureUpdated()
                : t.once('update', this.textureUpdated, this))
    }
    get texture() {
        return this.shader.texture
    }
    _render(t) {
        ;(this._textureID !== this.shader.texture._updateID &&
            this.textureUpdated(),
            super._render(t))
    }
    destroy(t) {
        ;(this.shader.texture.off('update', this.textureUpdated, this),
            super.destroy(t))
    }
}
const $s = 10
class Z0 extends K0 {
    constructor(t, e, i, r, n) {
        ;(super(j.WHITE, 4, 4),
            (this._origWidth = t.orig.width),
            (this._origHeight = t.orig.height),
            (this._width = this._origWidth),
            (this._height = this._origHeight),
            (this._leftWidth = e ?? t.defaultBorders?.left ?? $s),
            (this._rightWidth = r ?? t.defaultBorders?.right ?? $s),
            (this._topHeight = i ?? t.defaultBorders?.top ?? $s),
            (this._bottomHeight = n ?? t.defaultBorders?.bottom ?? $s),
            (this.texture = t))
    }
    textureUpdated() {
        ;((this._textureID = this.shader.texture._updateID), this._refresh())
    }
    get vertices() {
        return this.geometry.getBuffer('aVertexPosition').data
    }
    set vertices(t) {
        this.geometry.getBuffer('aVertexPosition').data = t
    }
    updateHorizontalVertices() {
        const t = this.vertices,
            e = this._getMinScale()
        ;((t[9] = t[11] = t[13] = t[15] = this._topHeight * e),
            (t[17] =
                t[19] =
                t[21] =
                t[23] =
                    this._height - this._bottomHeight * e),
            (t[25] = t[27] = t[29] = t[31] = this._height))
    }
    updateVerticalVertices() {
        const t = this.vertices,
            e = this._getMinScale()
        ;((t[2] = t[10] = t[18] = t[26] = this._leftWidth * e),
            (t[4] = t[12] = t[20] = t[28] = this._width - this._rightWidth * e),
            (t[6] = t[14] = t[22] = t[30] = this._width))
    }
    _getMinScale() {
        const t = this._leftWidth + this._rightWidth,
            e = this._width > t ? 1 : this._width / t,
            i = this._topHeight + this._bottomHeight,
            r = this._height > i ? 1 : this._height / i
        return Math.min(e, r)
    }
    get width() {
        return this._width
    }
    set width(t) {
        ;((this._width = t), this._refresh())
    }
    get height() {
        return this._height
    }
    set height(t) {
        ;((this._height = t), this._refresh())
    }
    get leftWidth() {
        return this._leftWidth
    }
    set leftWidth(t) {
        ;((this._leftWidth = t), this._refresh())
    }
    get rightWidth() {
        return this._rightWidth
    }
    set rightWidth(t) {
        ;((this._rightWidth = t), this._refresh())
    }
    get topHeight() {
        return this._topHeight
    }
    set topHeight(t) {
        ;((this._topHeight = t), this._refresh())
    }
    get bottomHeight() {
        return this._bottomHeight
    }
    set bottomHeight(t) {
        ;((this._bottomHeight = t), this._refresh())
    }
    _refresh() {
        const t = this.texture,
            e = this.geometry.buffers[1].data
        ;((this._origWidth = t.orig.width), (this._origHeight = t.orig.height))
        const i = 1 / this._origWidth,
            r = 1 / this._origHeight
        ;((e[0] = e[8] = e[16] = e[24] = 0),
            (e[1] = e[3] = e[5] = e[7] = 0),
            (e[6] = e[14] = e[22] = e[30] = 1),
            (e[25] = e[27] = e[29] = e[31] = 1),
            (e[2] = e[10] = e[18] = e[26] = i * this._leftWidth),
            (e[4] = e[12] = e[20] = e[28] = 1 - i * this._rightWidth),
            (e[9] = e[11] = e[13] = e[15] = r * this._topHeight),
            (e[17] = e[19] = e[21] = e[23] = 1 - r * this._bottomHeight),
            this.updateHorizontalVertices(),
            this.updateVerticalVertices(),
            this.geometry.buffers[0].update(),
            this.geometry.buffers[1].update())
    }
}
class jc {
    constructor(t, e, i) {
        ;((this.geometry = new Ti()),
            (this.indexBuffer = null),
            (this.size = i),
            (this.dynamicProperties = []),
            (this.staticProperties = []))
        for (let r = 0; r < t.length; ++r) {
            let n = t[r]
            ;((n = {
                attributeName: n.attributeName,
                size: n.size,
                uploadFunction: n.uploadFunction,
                type: n.type || at.FLOAT,
                offset: n.offset,
            }),
                e[r]
                    ? this.dynamicProperties.push(n)
                    : this.staticProperties.push(n))
        }
        ;((this.staticStride = 0),
            (this.staticBuffer = null),
            (this.staticData = null),
            (this.staticDataUint32 = null),
            (this.dynamicStride = 0),
            (this.dynamicBuffer = null),
            (this.dynamicData = null),
            (this.dynamicDataUint32 = null),
            (this._updateID = 0),
            this.initBuffers())
    }
    initBuffers() {
        const t = this.geometry
        let e = 0
        ;((this.indexBuffer = new Bt(gg(this.size), !0, !0)),
            t.addIndex(this.indexBuffer),
            (this.dynamicStride = 0))
        for (let a = 0; a < this.dynamicProperties.length; ++a) {
            const o = this.dynamicProperties[a]
            ;((o.offset = e), (e += o.size), (this.dynamicStride += o.size))
        }
        const i = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4)
        ;((this.dynamicData = new Float32Array(i)),
            (this.dynamicDataUint32 = new Uint32Array(i)),
            (this.dynamicBuffer = new Bt(this.dynamicData, !1, !1)))
        let r = 0
        this.staticStride = 0
        for (let a = 0; a < this.staticProperties.length; ++a) {
            const o = this.staticProperties[a]
            ;((o.offset = r), (r += o.size), (this.staticStride += o.size))
        }
        const n = new ArrayBuffer(this.size * this.staticStride * 4 * 4)
        ;((this.staticData = new Float32Array(n)),
            (this.staticDataUint32 = new Uint32Array(n)),
            (this.staticBuffer = new Bt(this.staticData, !0, !1)))
        for (let a = 0; a < this.dynamicProperties.length; ++a) {
            const o = this.dynamicProperties[a]
            t.addAttribute(
                o.attributeName,
                this.dynamicBuffer,
                0,
                o.type === at.UNSIGNED_BYTE,
                o.type,
                this.dynamicStride * 4,
                o.offset * 4,
            )
        }
        for (let a = 0; a < this.staticProperties.length; ++a) {
            const o = this.staticProperties[a]
            t.addAttribute(
                o.attributeName,
                this.staticBuffer,
                0,
                o.type === at.UNSIGNED_BYTE,
                o.type,
                this.staticStride * 4,
                o.offset * 4,
            )
        }
    }
    uploadDynamic(t, e, i) {
        for (let r = 0; r < this.dynamicProperties.length; r++) {
            const n = this.dynamicProperties[r]
            n.uploadFunction(
                t,
                e,
                i,
                n.type === at.UNSIGNED_BYTE
                    ? this.dynamicDataUint32
                    : this.dynamicData,
                this.dynamicStride,
                n.offset,
            )
        }
        this.dynamicBuffer._updateID++
    }
    uploadStatic(t, e, i) {
        for (let r = 0; r < this.staticProperties.length; r++) {
            const n = this.staticProperties[r]
            n.uploadFunction(
                t,
                e,
                i,
                n.type === at.UNSIGNED_BYTE
                    ? this.staticDataUint32
                    : this.staticData,
                this.staticStride,
                n.offset,
            )
        }
        this.staticBuffer._updateID++
    }
    destroy() {
        ;((this.indexBuffer = null),
            (this.dynamicProperties = null),
            (this.dynamicBuffer = null),
            (this.dynamicData = null),
            (this.dynamicDataUint32 = null),
            (this.staticProperties = null),
            (this.staticBuffer = null),
            (this.staticData = null),
            (this.staticDataUint32 = null),
            this.geometry.destroy())
    }
}
var Q0 = `varying vec2 vTextureCoord;
varying vec4 vColor;

uniform sampler2D uSampler;

void main(void){
    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
    gl_FragColor = color;
}`,
    J0 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;

attribute vec2 aPositionCoord;
attribute float aRotation;

uniform mat3 translationMatrix;
uniform vec4 uColor;

varying vec2 vTextureCoord;
varying vec4 vColor;

void main(void){
    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);
    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);

    vec2 v = vec2(x, y);
    v = v + aPositionCoord;

    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vColor = aColor * uColor;
}
`
class Lf extends Un {
    constructor(t) {
        ;(super(t),
            (this.shader = null),
            (this.properties = null),
            (this.tempMatrix = new Et()),
            (this.properties = [
                {
                    attributeName: 'aVertexPosition',
                    size: 2,
                    uploadFunction: this.uploadVertices,
                    offset: 0,
                },
                {
                    attributeName: 'aPositionCoord',
                    size: 2,
                    uploadFunction: this.uploadPosition,
                    offset: 0,
                },
                {
                    attributeName: 'aRotation',
                    size: 1,
                    uploadFunction: this.uploadRotation,
                    offset: 0,
                },
                {
                    attributeName: 'aTextureCoord',
                    size: 2,
                    uploadFunction: this.uploadUvs,
                    offset: 0,
                },
                {
                    attributeName: 'aColor',
                    size: 1,
                    type: at.UNSIGNED_BYTE,
                    uploadFunction: this.uploadTint,
                    offset: 0,
                },
            ]),
            (this.shader = Ve.from(J0, Q0, {})),
            (this.state = $e.for2d()))
    }
    render(t) {
        const e = t.children,
            i = t._maxSize,
            r = t._batchSize,
            n = this.renderer
        let a = e.length
        if (a === 0) return
        a > i && !t.autoResize && (a = i)
        let o = t._buffers
        o || (o = t._buffers = this.generateBuffers(t))
        const h = e[0]._texture.baseTexture,
            l = h.alphaMode > 0
        ;((this.state.blendMode = Md(t.blendMode, l)), n.state.set(this.state))
        const u = n.gl,
            c = t.worldTransform.copyTo(this.tempMatrix)
        ;(c.prepend(n.globalUniforms.uniforms.projectionMatrix),
            (this.shader.uniforms.translationMatrix = c.toArray(!0)),
            (this.shader.uniforms.uColor = Tt.shared
                .setValue(t.tintRgb)
                .premultiply(t.worldAlpha, l)
                .toArray(this.shader.uniforms.uColor)),
            (this.shader.uniforms.uSampler = h),
            this.renderer.shader.bind(this.shader))
        let d = !1
        for (let f = 0, m = 0; f < a; f += r, m += 1) {
            let p = a - f
            ;(p > r && (p = r),
                m >= o.length && o.push(this._generateOneMoreBuffer(t)))
            const g = o[m]
            g.uploadDynamic(e, f, p)
            const _ = t._bufferUpdateIDs[m] || 0
            ;((d = d || g._updateID < _),
                d && ((g._updateID = t._updateID), g.uploadStatic(e, f, p)),
                n.geometry.bind(g.geometry),
                u.drawElements(u.TRIANGLES, p * 6, u.UNSIGNED_SHORT, 0))
        }
    }
    generateBuffers(t) {
        const e = [],
            i = t._maxSize,
            r = t._batchSize,
            n = t._properties
        for (let a = 0; a < i; a += r) e.push(new jc(this.properties, n, r))
        return e
    }
    _generateOneMoreBuffer(t) {
        const e = t._batchSize,
            i = t._properties
        return new jc(this.properties, i, e)
    }
    uploadVertices(t, e, i, r, n, a) {
        let o = 0,
            h = 0,
            l = 0,
            u = 0
        for (let c = 0; c < i; ++c) {
            const d = t[e + c],
                f = d._texture,
                m = d.scale.x,
                p = d.scale.y,
                g = f.trim,
                _ = f.orig
            ;(g
                ? ((h = g.x - d.anchor.x * _.width),
                  (o = h + g.width),
                  (u = g.y - d.anchor.y * _.height),
                  (l = u + g.height))
                : ((o = _.width * (1 - d.anchor.x)),
                  (h = _.width * -d.anchor.x),
                  (l = _.height * (1 - d.anchor.y)),
                  (u = _.height * -d.anchor.y)),
                (r[a] = h * m),
                (r[a + 1] = u * p),
                (r[a + n] = o * m),
                (r[a + n + 1] = u * p),
                (r[a + n * 2] = o * m),
                (r[a + n * 2 + 1] = l * p),
                (r[a + n * 3] = h * m),
                (r[a + n * 3 + 1] = l * p),
                (a += n * 4))
        }
    }
    uploadPosition(t, e, i, r, n, a) {
        for (let o = 0; o < i; o++) {
            const h = t[e + o].position
            ;((r[a] = h.x),
                (r[a + 1] = h.y),
                (r[a + n] = h.x),
                (r[a + n + 1] = h.y),
                (r[a + n * 2] = h.x),
                (r[a + n * 2 + 1] = h.y),
                (r[a + n * 3] = h.x),
                (r[a + n * 3 + 1] = h.y),
                (a += n * 4))
        }
    }
    uploadRotation(t, e, i, r, n, a) {
        for (let o = 0; o < i; o++) {
            const h = t[e + o].rotation
            ;((r[a] = h),
                (r[a + n] = h),
                (r[a + n * 2] = h),
                (r[a + n * 3] = h),
                (a += n * 4))
        }
    }
    uploadUvs(t, e, i, r, n, a) {
        for (let o = 0; o < i; ++o) {
            const h = t[e + o]._texture._uvs
            h
                ? ((r[a] = h.x0),
                  (r[a + 1] = h.y0),
                  (r[a + n] = h.x1),
                  (r[a + n + 1] = h.y1),
                  (r[a + n * 2] = h.x2),
                  (r[a + n * 2 + 1] = h.y2),
                  (r[a + n * 3] = h.x3),
                  (r[a + n * 3 + 1] = h.y3),
                  (a += n * 4))
                : ((r[a] = 0),
                  (r[a + 1] = 0),
                  (r[a + n] = 0),
                  (r[a + n + 1] = 0),
                  (r[a + n * 2] = 0),
                  (r[a + n * 2 + 1] = 0),
                  (r[a + n * 3] = 0),
                  (r[a + n * 3 + 1] = 0),
                  (a += n * 4))
        }
    }
    uploadTint(t, e, i, r, n, a) {
        for (let o = 0; o < i; ++o) {
            const h = t[e + o],
                l = Tt.shared
                    .setValue(h._tintRGB)
                    .toPremultiplied(
                        h.alpha,
                        h.texture.baseTexture.alphaMode > 0,
                    )
            ;((r[a] = l),
                (r[a + n] = l),
                (r[a + n * 2] = l),
                (r[a + n * 3] = l),
                (a += n * 4))
        }
    }
    destroy() {
        ;(super.destroy(),
            this.shader && (this.shader.destroy(), (this.shader = null)),
            (this.tempMatrix = null))
    }
}
Lf.extension = { name: 'particle', type: $.RendererPlugin }
Q.add(Lf)
var zn = (s => (
    (s[(s.LINEAR_VERTICAL = 0)] = 'LINEAR_VERTICAL'),
    (s[(s.LINEAR_HORIZONTAL = 1)] = 'LINEAR_HORIZONTAL'),
    s
))(zn || {})
const js = { willReadFrequently: !0 },
    De = class tt {
        static get experimentalLetterSpacingSupported() {
            let t = tt._experimentalLetterSpacingSupported
            if (t !== void 0) {
                const e = Y.ADAPTER.getCanvasRenderingContext2D().prototype
                t = tt._experimentalLetterSpacingSupported =
                    'letterSpacing' in e || 'textLetterSpacing' in e
            }
            return t
        }
        constructor(t, e, i, r, n, a, o, h, l) {
            ;((this.text = t),
                (this.style = e),
                (this.width = i),
                (this.height = r),
                (this.lines = n),
                (this.lineWidths = a),
                (this.lineHeight = o),
                (this.maxLineWidth = h),
                (this.fontProperties = l))
        }
        static measureText(t, e, i, r = tt._canvas) {
            i = i ?? e.wordWrap
            const n = e.toFontString(),
                a = tt.measureFont(n)
            a.fontSize === 0 &&
                ((a.fontSize = e.fontSize), (a.ascent = e.fontSize))
            const o = r.getContext('2d', js)
            o.font = n
            const h = (i ? tt.wordWrap(t, e, r) : t).split(/(?:\r\n|\r|\n)/),
                l = new Array(h.length)
            let u = 0
            for (let m = 0; m < h.length; m++) {
                const p = tt._measureText(h[m], e.letterSpacing, o)
                ;((l[m] = p), (u = Math.max(u, p)))
            }
            let c = u + e.strokeThickness
            e.dropShadow && (c += e.dropShadowDistance)
            const d = e.lineHeight || a.fontSize + e.strokeThickness
            let f =
                Math.max(d, a.fontSize + e.strokeThickness * 2) +
                e.leading +
                (h.length - 1) * (d + e.leading)
            return (
                e.dropShadow && (f += e.dropShadowDistance),
                new tt(t, e, c, f, h, l, d + e.leading, u, a)
            )
        }
        static _measureText(t, e, i) {
            let r = !1
            tt.experimentalLetterSpacingSupported &&
                (tt.experimentalLetterSpacing
                    ? ((i.letterSpacing = `${e}px`),
                      (i.textLetterSpacing = `${e}px`),
                      (r = !0))
                    : ((i.letterSpacing = '0px'),
                      (i.textLetterSpacing = '0px')))
            let n = i.measureText(t).width
            return (
                n > 0 &&
                    (r
                        ? (n -= e)
                        : (n += (tt.graphemeSegmenter(t).length - 1) * e)),
                n
            )
        }
        static wordWrap(t, e, i = tt._canvas) {
            const r = i.getContext('2d', js)
            let n = 0,
                a = '',
                o = ''
            const h = Object.create(null),
                { letterSpacing: l, whiteSpace: u } = e,
                c = tt.collapseSpaces(u),
                d = tt.collapseNewlines(u)
            let f = !c
            const m = e.wordWrapWidth + l,
                p = tt.tokenize(t)
            for (let g = 0; g < p.length; g++) {
                let _ = p[g]
                if (tt.isNewline(_)) {
                    if (!d) {
                        ;((o += tt.addLine(a)), (f = !c), (a = ''), (n = 0))
                        continue
                    }
                    _ = ' '
                }
                if (c) {
                    const v = tt.isBreakingSpace(_),
                        w = tt.isBreakingSpace(a[a.length - 1])
                    if (v && w) continue
                }
                const b = tt.getFromCache(_, l, h, r)
                if (b > m)
                    if (
                        (a !== '' && ((o += tt.addLine(a)), (a = ''), (n = 0)),
                        tt.canBreakWords(_, e.breakWords))
                    ) {
                        const v = tt.wordWrapSplit(_)
                        for (let w = 0; w < v.length; w++) {
                            let x = v[w],
                                P = x,
                                y = 1
                            for (; v[w + y]; ) {
                                const R = v[w + y]
                                if (!tt.canBreakChars(P, R, _, w, e.breakWords))
                                    x += R
                                else break
                                ;((P = R), y++)
                            }
                            w += y - 1
                            const S = tt.getFromCache(x, l, h, r)
                            ;(S + n > m &&
                                ((o += tt.addLine(a)),
                                (f = !1),
                                (a = ''),
                                (n = 0)),
                                (a += x),
                                (n += S))
                        }
                    } else {
                        a.length > 0 &&
                            ((o += tt.addLine(a)), (a = ''), (n = 0))
                        const v = g === p.length - 1
                        ;((o += tt.addLine(_, !v)), (f = !1), (a = ''), (n = 0))
                    }
                else
                    (b + n > m &&
                        ((f = !1), (o += tt.addLine(a)), (a = ''), (n = 0)),
                        (a.length > 0 || !tt.isBreakingSpace(_) || f) &&
                            ((a += _), (n += b)))
            }
            return ((o += tt.addLine(a, !1)), o)
        }
        static addLine(t, e = !0) {
            return (
                (t = tt.trimRight(t)),
                (t = e
                    ? `${t}
`
                    : t),
                t
            )
        }
        static getFromCache(t, e, i, r) {
            let n = i[t]
            return (
                typeof n != 'number' &&
                    ((n = tt._measureText(t, e, r) + e), (i[t] = n)),
                n
            )
        }
        static collapseSpaces(t) {
            return t === 'normal' || t === 'pre-line'
        }
        static collapseNewlines(t) {
            return t === 'normal'
        }
        static trimRight(t) {
            if (typeof t != 'string') return ''
            for (let e = t.length - 1; e >= 0; e--) {
                const i = t[e]
                if (!tt.isBreakingSpace(i)) break
                t = t.slice(0, -1)
            }
            return t
        }
        static isNewline(t) {
            return typeof t != 'string'
                ? !1
                : tt._newlines.includes(t.charCodeAt(0))
        }
        static isBreakingSpace(t, e) {
            return typeof t != 'string'
                ? !1
                : tt._breakingSpaces.includes(t.charCodeAt(0))
        }
        static tokenize(t) {
            const e = []
            let i = ''
            if (typeof t != 'string') return e
            for (let r = 0; r < t.length; r++) {
                const n = t[r],
                    a = t[r + 1]
                if (tt.isBreakingSpace(n, a) || tt.isNewline(n)) {
                    ;(i !== '' && (e.push(i), (i = '')), e.push(n))
                    continue
                }
                i += n
            }
            return (i !== '' && e.push(i), e)
        }
        static canBreakWords(t, e) {
            return e
        }
        static canBreakChars(t, e, i, r, n) {
            return !0
        }
        static wordWrapSplit(t) {
            return tt.graphemeSegmenter(t)
        }
        static measureFont(t) {
            if (tt._fonts[t]) return tt._fonts[t]
            const e = { ascent: 0, descent: 0, fontSize: 0 },
                i = tt._canvas,
                r = tt._context
            r.font = t
            const n = tt.METRICS_STRING + tt.BASELINE_SYMBOL,
                a = Math.ceil(r.measureText(n).width)
            let o = Math.ceil(r.measureText(tt.BASELINE_SYMBOL).width)
            const h = Math.ceil(tt.HEIGHT_MULTIPLIER * o)
            if (((o = (o * tt.BASELINE_MULTIPLIER) | 0), a === 0 || h === 0))
                return ((tt._fonts[t] = e), e)
            ;((i.width = a),
                (i.height = h),
                (r.fillStyle = '#f00'),
                r.fillRect(0, 0, a, h),
                (r.font = t),
                (r.textBaseline = 'alphabetic'),
                (r.fillStyle = '#000'),
                r.fillText(n, 0, o))
            const l = r.getImageData(0, 0, a, h).data,
                u = l.length,
                c = a * 4
            let d = 0,
                f = 0,
                m = !1
            for (d = 0; d < o; ++d) {
                for (let p = 0; p < c; p += 4)
                    if (l[f + p] !== 255) {
                        m = !0
                        break
                    }
                if (!m) f += c
                else break
            }
            for (e.ascent = o - d, f = u - c, m = !1, d = h; d > o; --d) {
                for (let p = 0; p < c; p += 4)
                    if (l[f + p] !== 255) {
                        m = !0
                        break
                    }
                if (!m) f -= c
                else break
            }
            return (
                (e.descent = d - o),
                (e.fontSize = e.ascent + e.descent),
                (tt._fonts[t] = e),
                e
            )
        }
        static clearMetrics(t = '') {
            t ? delete tt._fonts[t] : (tt._fonts = {})
        }
        static get _canvas() {
            if (!tt.__canvas) {
                let t
                try {
                    const e = new OffscreenCanvas(0, 0)
                    if (e.getContext('2d', js)?.measureText)
                        return ((tt.__canvas = e), e)
                    t = Y.ADAPTER.createCanvas()
                } catch {
                    t = Y.ADAPTER.createCanvas()
                }
                ;((t.width = t.height = 10), (tt.__canvas = t))
            }
            return tt.__canvas
        }
        static get _context() {
            return (
                tt.__context ||
                    (tt.__context = tt._canvas.getContext('2d', js)),
                tt.__context
            )
        }
    }
;((De.METRICS_STRING = '|q'),
    (De.BASELINE_SYMBOL = 'M'),
    (De.BASELINE_MULTIPLIER = 1.4),
    (De.HEIGHT_MULTIPLIER = 2),
    (De.graphemeSegmenter = (() => {
        if (typeof Intl?.Segmenter == 'function') {
            const s = new Intl.Segmenter()
            return t => [...s.segment(t)].map(e => e.segment)
        }
        return s => [...s]
    })()),
    (De.experimentalLetterSpacing = !1),
    (De._fonts = {}),
    (De._newlines = [10, 13]),
    (De._breakingSpaces = [
        9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287,
        12288,
    ]))
let fi = De
const tv = [
        'serif',
        'sans-serif',
        'monospace',
        'cursive',
        'fantasy',
        'system-ui',
    ],
    kf = class es {
        constructor(t) {
            ;((this.styleID = 0), this.reset(), Eo(this, t, t))
        }
        clone() {
            const t = {}
            return (Eo(t, this, es.defaultStyle), new es(t))
        }
        reset() {
            Eo(this, es.defaultStyle, es.defaultStyle)
        }
        get align() {
            return this._align
        }
        set align(t) {
            this._align !== t && ((this._align = t), this.styleID++)
        }
        get breakWords() {
            return this._breakWords
        }
        set breakWords(t) {
            this._breakWords !== t && ((this._breakWords = t), this.styleID++)
        }
        get dropShadow() {
            return this._dropShadow
        }
        set dropShadow(t) {
            this._dropShadow !== t && ((this._dropShadow = t), this.styleID++)
        }
        get dropShadowAlpha() {
            return this._dropShadowAlpha
        }
        set dropShadowAlpha(t) {
            this._dropShadowAlpha !== t &&
                ((this._dropShadowAlpha = t), this.styleID++)
        }
        get dropShadowAngle() {
            return this._dropShadowAngle
        }
        set dropShadowAngle(t) {
            this._dropShadowAngle !== t &&
                ((this._dropShadowAngle = t), this.styleID++)
        }
        get dropShadowBlur() {
            return this._dropShadowBlur
        }
        set dropShadowBlur(t) {
            this._dropShadowBlur !== t &&
                ((this._dropShadowBlur = t), this.styleID++)
        }
        get dropShadowColor() {
            return this._dropShadowColor
        }
        set dropShadowColor(t) {
            const e = To(t)
            this._dropShadowColor !== e &&
                ((this._dropShadowColor = e), this.styleID++)
        }
        get dropShadowDistance() {
            return this._dropShadowDistance
        }
        set dropShadowDistance(t) {
            this._dropShadowDistance !== t &&
                ((this._dropShadowDistance = t), this.styleID++)
        }
        get fill() {
            return this._fill
        }
        set fill(t) {
            const e = To(t)
            this._fill !== e && ((this._fill = e), this.styleID++)
        }
        get fillGradientType() {
            return this._fillGradientType
        }
        set fillGradientType(t) {
            this._fillGradientType !== t &&
                ((this._fillGradientType = t), this.styleID++)
        }
        get fillGradientStops() {
            return this._fillGradientStops
        }
        set fillGradientStops(t) {
            ev(this._fillGradientStops, t) ||
                ((this._fillGradientStops = t), this.styleID++)
        }
        get fontFamily() {
            return this._fontFamily
        }
        set fontFamily(t) {
            this.fontFamily !== t && ((this._fontFamily = t), this.styleID++)
        }
        get fontSize() {
            return this._fontSize
        }
        set fontSize(t) {
            this._fontSize !== t && ((this._fontSize = t), this.styleID++)
        }
        get fontStyle() {
            return this._fontStyle
        }
        set fontStyle(t) {
            this._fontStyle !== t && ((this._fontStyle = t), this.styleID++)
        }
        get fontVariant() {
            return this._fontVariant
        }
        set fontVariant(t) {
            this._fontVariant !== t && ((this._fontVariant = t), this.styleID++)
        }
        get fontWeight() {
            return this._fontWeight
        }
        set fontWeight(t) {
            this._fontWeight !== t && ((this._fontWeight = t), this.styleID++)
        }
        get letterSpacing() {
            return this._letterSpacing
        }
        set letterSpacing(t) {
            this._letterSpacing !== t &&
                ((this._letterSpacing = t), this.styleID++)
        }
        get lineHeight() {
            return this._lineHeight
        }
        set lineHeight(t) {
            this._lineHeight !== t && ((this._lineHeight = t), this.styleID++)
        }
        get leading() {
            return this._leading
        }
        set leading(t) {
            this._leading !== t && ((this._leading = t), this.styleID++)
        }
        get lineJoin() {
            return this._lineJoin
        }
        set lineJoin(t) {
            this._lineJoin !== t && ((this._lineJoin = t), this.styleID++)
        }
        get miterLimit() {
            return this._miterLimit
        }
        set miterLimit(t) {
            this._miterLimit !== t && ((this._miterLimit = t), this.styleID++)
        }
        get padding() {
            return this._padding
        }
        set padding(t) {
            this._padding !== t && ((this._padding = t), this.styleID++)
        }
        get stroke() {
            return this._stroke
        }
        set stroke(t) {
            const e = To(t)
            this._stroke !== e && ((this._stroke = e), this.styleID++)
        }
        get strokeThickness() {
            return this._strokeThickness
        }
        set strokeThickness(t) {
            this._strokeThickness !== t &&
                ((this._strokeThickness = t), this.styleID++)
        }
        get textBaseline() {
            return this._textBaseline
        }
        set textBaseline(t) {
            this._textBaseline !== t &&
                ((this._textBaseline = t), this.styleID++)
        }
        get trim() {
            return this._trim
        }
        set trim(t) {
            this._trim !== t && ((this._trim = t), this.styleID++)
        }
        get whiteSpace() {
            return this._whiteSpace
        }
        set whiteSpace(t) {
            this._whiteSpace !== t && ((this._whiteSpace = t), this.styleID++)
        }
        get wordWrap() {
            return this._wordWrap
        }
        set wordWrap(t) {
            this._wordWrap !== t && ((this._wordWrap = t), this.styleID++)
        }
        get wordWrapWidth() {
            return this._wordWrapWidth
        }
        set wordWrapWidth(t) {
            this._wordWrapWidth !== t &&
                ((this._wordWrapWidth = t), this.styleID++)
        }
        toFontString() {
            const t =
                typeof this.fontSize == 'number'
                    ? `${this.fontSize}px`
                    : this.fontSize
            let e = this.fontFamily
            Array.isArray(this.fontFamily) || (e = this.fontFamily.split(','))
            for (let i = e.length - 1; i >= 0; i--) {
                let r = e[i].trim()
                ;(!/([\"\'])[^\'\"]+\1/.test(r) &&
                    !tv.includes(r) &&
                    (r = `"${r}"`),
                    (e[i] = r))
            }
            return `${this.fontStyle} ${this.fontVariant} ${this.fontWeight} ${t} ${e.join(',')}`
        }
    }
kf.defaultStyle = {
    align: 'left',
    breakWords: !1,
    dropShadow: !1,
    dropShadowAlpha: 1,
    dropShadowAngle: Math.PI / 6,
    dropShadowBlur: 0,
    dropShadowColor: 'black',
    dropShadowDistance: 5,
    fill: 'black',
    fillGradientType: zn.LINEAR_VERTICAL,
    fillGradientStops: [],
    fontFamily: 'Arial',
    fontSize: 26,
    fontStyle: 'normal',
    fontVariant: 'normal',
    fontWeight: 'normal',
    leading: 0,
    letterSpacing: 0,
    lineHeight: 0,
    lineJoin: 'miter',
    miterLimit: 10,
    padding: 0,
    stroke: 'black',
    strokeThickness: 0,
    textBaseline: 'alphabetic',
    trim: !1,
    whiteSpace: 'pre',
    wordWrap: !1,
    wordWrapWidth: 100,
}
let si = kf
function To(s) {
    const t = Tt.shared,
        e = i => {
            const r = t.setValue(i)
            return r.alpha === 1 ? r.toHex() : r.toRgbaString()
        }
    return Array.isArray(s) ? s.map(e) : e(s)
}
function ev(s, t) {
    if (!Array.isArray(s) || !Array.isArray(t) || s.length !== t.length)
        return !1
    for (let e = 0; e < s.length; ++e) if (s[e] !== t[e]) return !1
    return !0
}
function Eo(s, t, e) {
    for (const i in e)
        Array.isArray(t[i]) ? (s[i] = t[i].slice()) : (s[i] = t[i])
}
const iv = { texture: !0, children: !1, baseTexture: !0 },
    Nf = class yh extends Gr {
        constructor(t, e, i) {
            let r = !1
            ;(i || ((i = Y.ADAPTER.createCanvas()), (r = !0)),
                (i.width = 3),
                (i.height = 3))
            const n = j.from(i)
            ;((n.orig = new dt()),
                (n.trim = new dt()),
                super(n),
                (this._ownCanvas = r),
                (this.canvas = i),
                (this.context = i.getContext('2d', { willReadFrequently: !0 })),
                (this._resolution = yh.defaultResolution ?? Y.RESOLUTION),
                (this._autoResolution = yh.defaultAutoResolution),
                (this._text = null),
                (this._style = null),
                (this._styleListener = null),
                (this._font = ''),
                (this.text = t),
                (this.style = e),
                (this.localStyleID = -1))
        }
        static get experimentalLetterSpacing() {
            return fi.experimentalLetterSpacing
        }
        static set experimentalLetterSpacing(t) {
            ;(ft(
                '7.1.0',
                'Text.experimentalLetterSpacing is deprecated, use TextMetrics.experimentalLetterSpacing',
            ),
                (fi.experimentalLetterSpacing = t))
        }
        updateText(t) {
            const e = this._style
            if (
                (this.localStyleID !== e.styleID &&
                    ((this.dirty = !0), (this.localStyleID = e.styleID)),
                !this.dirty && t)
            )
                return
            this._font = this._style.toFontString()
            const i = this.context,
                r = fi.measureText(
                    this._text || ' ',
                    this._style,
                    this._style.wordWrap,
                    this.canvas,
                ),
                n = r.width,
                a = r.height,
                o = r.lines,
                h = r.lineHeight,
                l = r.lineWidths,
                u = r.maxLineWidth,
                c = r.fontProperties
            ;((this.canvas.width = Math.ceil(
                Math.ceil(Math.max(1, n) + e.padding * 2) * this._resolution,
            )),
                (this.canvas.height = Math.ceil(
                    Math.ceil(Math.max(1, a) + e.padding * 2) *
                        this._resolution,
                )),
                i.scale(this._resolution, this._resolution),
                i.clearRect(0, 0, this.canvas.width, this.canvas.height),
                (i.font = this._font),
                (i.lineWidth = e.strokeThickness),
                (i.textBaseline = e.textBaseline),
                (i.lineJoin = e.lineJoin),
                (i.miterLimit = e.miterLimit))
            let d, f
            const m = e.dropShadow ? 2 : 1
            for (let p = 0; p < m; ++p) {
                const g = e.dropShadow && p === 0,
                    _ = g ? Math.ceil(Math.max(1, a) + e.padding * 2) : 0,
                    b = _ * this._resolution
                if (g) {
                    ;((i.fillStyle = 'black'), (i.strokeStyle = 'black'))
                    const w = e.dropShadowColor,
                        x = e.dropShadowBlur * this._resolution,
                        P = e.dropShadowDistance * this._resolution
                    ;((i.shadowColor = Tt.shared
                        .setValue(w)
                        .setAlpha(e.dropShadowAlpha)
                        .toRgbaString()),
                        (i.shadowBlur = x),
                        (i.shadowOffsetX = Math.cos(e.dropShadowAngle) * P),
                        (i.shadowOffsetY = Math.sin(e.dropShadowAngle) * P + b))
                } else
                    ((i.fillStyle = this._generateFillStyle(e, o, r)),
                        (i.strokeStyle = e.stroke),
                        (i.shadowColor = 'black'),
                        (i.shadowBlur = 0),
                        (i.shadowOffsetX = 0),
                        (i.shadowOffsetY = 0))
                let v = (h - c.fontSize) / 2
                h - c.fontSize < 0 && (v = 0)
                for (let w = 0; w < o.length; w++)
                    ((d = e.strokeThickness / 2),
                        (f = e.strokeThickness / 2 + w * h + c.ascent + v),
                        e.align === 'right'
                            ? (d += u - l[w])
                            : e.align === 'center' && (d += (u - l[w]) / 2),
                        e.stroke &&
                            e.strokeThickness &&
                            this.drawLetterSpacing(
                                o[w],
                                d + e.padding,
                                f + e.padding - _,
                                !0,
                            ),
                        e.fill &&
                            this.drawLetterSpacing(
                                o[w],
                                d + e.padding,
                                f + e.padding - _,
                            ))
            }
            this.updateTexture()
        }
        drawLetterSpacing(t, e, i, r = !1) {
            const n = this._style.letterSpacing
            let a = !1
            if (
                (fi.experimentalLetterSpacingSupported &&
                    (fi.experimentalLetterSpacing
                        ? ((this.context.letterSpacing = `${n}px`),
                          (this.context.textLetterSpacing = `${n}px`),
                          (a = !0))
                        : ((this.context.letterSpacing = '0px'),
                          (this.context.textLetterSpacing = '0px'))),
                n === 0 || a)
            ) {
                r
                    ? this.context.strokeText(t, e, i)
                    : this.context.fillText(t, e, i)
                return
            }
            let o = e
            const h = fi.graphemeSegmenter(t)
            let l = this.context.measureText(t).width,
                u = 0
            for (let c = 0; c < h.length; ++c) {
                const d = h[c]
                r
                    ? this.context.strokeText(d, o, i)
                    : this.context.fillText(d, o, i)
                let f = ''
                for (let m = c + 1; m < h.length; ++m) f += h[m]
                ;((u = this.context.measureText(f).width),
                    (o += l - u + n),
                    (l = u))
            }
        }
        updateTexture() {
            const t = this.canvas
            if (this._style.trim) {
                const a = xg(t)
                a.data &&
                    ((t.width = a.width),
                    (t.height = a.height),
                    this.context.putImageData(a.data, 0, 0))
            }
            const e = this._texture,
                i = this._style,
                r = i.trim ? 0 : i.padding,
                n = e.baseTexture
            ;((e.trim.width = e._frame.width = t.width / this._resolution),
                (e.trim.height = e._frame.height = t.height / this._resolution),
                (e.trim.x = -r),
                (e.trim.y = -r),
                (e.orig.width = e._frame.width - r * 2),
                (e.orig.height = e._frame.height - r * 2),
                this._onTextureUpdate(),
                n.setRealSize(t.width, t.height, this._resolution),
                e.updateUvs(),
                (this.dirty = !1))
        }
        _render(t) {
            ;(this._autoResolution &&
                this._resolution !== t.resolution &&
                ((this._resolution = t.resolution), (this.dirty = !0)),
                this.updateText(!0),
                super._render(t))
        }
        updateTransform() {
            ;(this.updateText(!0), super.updateTransform())
        }
        getBounds(t, e) {
            return (
                this.updateText(!0),
                this._textureID === -1 && (t = !1),
                super.getBounds(t, e)
            )
        }
        getLocalBounds(t) {
            return (this.updateText(!0), super.getLocalBounds.call(this, t))
        }
        _calculateBounds() {
            ;(this.calculateVertices(), this._bounds.addQuad(this.vertexData))
        }
        _generateFillStyle(t, e, i) {
            const r = t.fill
            if (Array.isArray(r)) {
                if (r.length === 1) return r[0]
            } else return r
            let n
            const a = t.dropShadow ? t.dropShadowDistance : 0,
                o = t.padding || 0,
                h = this.canvas.width / this._resolution - a - o * 2,
                l = this.canvas.height / this._resolution - a - o * 2,
                u = r.slice(),
                c = t.fillGradientStops.slice()
            if (!c.length) {
                const d = u.length + 1
                for (let f = 1; f < d; ++f) c.push(f / d)
            }
            if (
                (u.unshift(r[0]),
                c.unshift(0),
                u.push(r[r.length - 1]),
                c.push(1),
                t.fillGradientType === zn.LINEAR_VERTICAL)
            ) {
                n = this.context.createLinearGradient(h / 2, o, h / 2, l + o)
                const d = i.fontProperties.fontSize + t.strokeThickness
                for (let f = 0; f < e.length; f++) {
                    const m = i.lineHeight * (f - 1) + d,
                        p = i.lineHeight * f
                    let g = p
                    f > 0 && m > p && (g = (p + m) / 2)
                    const _ = p + d,
                        b = i.lineHeight * (f + 1)
                    let v = _
                    f + 1 < e.length && b < _ && (v = (_ + b) / 2)
                    const w = (v - g) / l
                    for (let x = 0; x < u.length; x++) {
                        let P = 0
                        typeof c[x] == 'number'
                            ? (P = c[x])
                            : (P = x / u.length)
                        let y = Math.min(1, Math.max(0, g / l + P * w))
                        ;((y = Number(y.toFixed(5))), n.addColorStop(y, u[x]))
                    }
                }
            } else {
                n = this.context.createLinearGradient(o, l / 2, h + o, l / 2)
                const d = u.length + 1
                let f = 1
                for (let m = 0; m < u.length; m++) {
                    let p
                    ;(typeof c[m] == 'number' ? (p = c[m]) : (p = f / d),
                        n.addColorStop(p, u[m]),
                        f++)
                }
            }
            return n
        }
        destroy(t) {
            ;(typeof t == 'boolean' && (t = { children: t }),
                (t = Object.assign({}, iv, t)),
                super.destroy(t),
                this._ownCanvas && (this.canvas.height = this.canvas.width = 0),
                (this.context = null),
                (this.canvas = null),
                (this._style = null))
        }
        get width() {
            return (
                this.updateText(!0),
                Math.abs(this.scale.x) * this._texture.orig.width
            )
        }
        set width(t) {
            this.updateText(!0)
            const e = mi(this.scale.x) || 1
            ;((this.scale.x = (e * t) / this._texture.orig.width),
                (this._width = t))
        }
        get height() {
            return (
                this.updateText(!0),
                Math.abs(this.scale.y) * this._texture.orig.height
            )
        }
        set height(t) {
            this.updateText(!0)
            const e = mi(this.scale.y) || 1
            ;((this.scale.y = (e * t) / this._texture.orig.height),
                (this._height = t))
        }
        get style() {
            return this._style
        }
        set style(t) {
            ;((t = t || {}),
                t instanceof si ? (this._style = t) : (this._style = new si(t)),
                (this.localStyleID = -1),
                (this.dirty = !0))
        }
        get text() {
            return this._text
        }
        set text(t) {
            ;((t = String(t ?? '')),
                this._text !== t && ((this._text = t), (this.dirty = !0)))
        }
        get resolution() {
            return this._resolution
        }
        set resolution(t) {
            ;((this._autoResolution = !1),
                this._resolution !== t &&
                    ((this._resolution = t), (this.dirty = !0)))
        }
    }
Nf.defaultAutoResolution = !0
let Zh = Nf
class rv {
    constructor(t) {
        ;((this.maxItemsPerFrame = t), (this.itemsLeft = 0))
    }
    beginFrame() {
        this.itemsLeft = this.maxItemsPerFrame
    }
    allowedToUpload() {
        return this.itemsLeft-- > 0
    }
}
function sv(s, t) {
    let e = !1
    if (s?._textures?.length) {
        for (let i = 0; i < s._textures.length; i++)
            if (s._textures[i] instanceof j) {
                const r = s._textures[i].baseTexture
                t.includes(r) || (t.push(r), (e = !0))
            }
    }
    return e
}
function nv(s, t) {
    if (s.baseTexture instanceof lt) {
        const e = s.baseTexture
        return (t.includes(e) || t.push(e), !0)
    }
    return !1
}
function av(s, t) {
    if (s._texture && s._texture instanceof j) {
        const e = s._texture.baseTexture
        return (t.includes(e) || t.push(e), !0)
    }
    return !1
}
function ov(s, t) {
    return t instanceof Zh ? (t.updateText(!0), !0) : !1
}
function hv(s, t) {
    if (t instanceof si) {
        const e = t.toFontString()
        return (fi.measureFont(e), !0)
    }
    return !1
}
function lv(s, t) {
    if (s instanceof Zh) {
        ;(t.includes(s.style) || t.push(s.style), t.includes(s) || t.push(s))
        const e = s._texture.baseTexture
        return (t.includes(e) || t.push(e), !0)
    }
    return !1
}
function uv(s, t) {
    return s instanceof si ? (t.includes(s) || t.push(s), !0) : !1
}
const Uf = class Gf {
    constructor(t) {
        ;((this.limiter = new rv(Gf.uploadsPerFrame)),
            (this.renderer = t),
            (this.uploadHookHelper = null),
            (this.queue = []),
            (this.addHooks = []),
            (this.uploadHooks = []),
            (this.completes = []),
            (this.ticking = !1),
            (this.delayedTick = () => {
                this.queue && this.prepareItems()
            }),
            this.registerFindHook(lv),
            this.registerFindHook(uv),
            this.registerFindHook(sv),
            this.registerFindHook(nv),
            this.registerFindHook(av),
            this.registerUploadHook(ov),
            this.registerUploadHook(hv))
    }
    upload(t) {
        return new Promise(e => {
            ;(t && this.add(t),
                this.queue.length
                    ? (this.completes.push(e),
                      this.ticking ||
                          ((this.ticking = !0),
                          Yt.system.addOnce(this.tick, this, Qi.UTILITY)))
                    : e())
        })
    }
    tick() {
        setTimeout(this.delayedTick, 0)
    }
    prepareItems() {
        for (
            this.limiter.beginFrame();
            this.queue.length && this.limiter.allowedToUpload();

        ) {
            const t = this.queue[0]
            let e = !1
            if (t && !t._destroyed) {
                for (let i = 0, r = this.uploadHooks.length; i < r; i++)
                    if (this.uploadHooks[i](this.uploadHookHelper, t)) {
                        ;(this.queue.shift(), (e = !0))
                        break
                    }
            }
            e || this.queue.shift()
        }
        if (this.queue.length) Yt.system.addOnce(this.tick, this, Qi.UTILITY)
        else {
            this.ticking = !1
            const t = this.completes.slice(0)
            this.completes.length = 0
            for (let e = 0, i = t.length; e < i; e++) t[e]()
        }
    }
    registerFindHook(t) {
        return (t && this.addHooks.push(t), this)
    }
    registerUploadHook(t) {
        return (t && this.uploadHooks.push(t), this)
    }
    add(t) {
        for (
            let e = 0, i = this.addHooks.length;
            e < i && !this.addHooks[e](t, this.queue);
            e++
        );
        if (t instanceof Kt)
            for (let e = t.children.length - 1; e >= 0; e--)
                this.add(t.children[e])
        return this
    }
    destroy() {
        ;(this.ticking && Yt.system.remove(this.tick, this),
            (this.ticking = !1),
            (this.addHooks = null),
            (this.uploadHooks = null),
            (this.renderer = null),
            (this.completes = null),
            (this.queue = null),
            (this.limiter = null),
            (this.uploadHookHelper = null))
    }
}
Uf.uploadsPerFrame = 4
let vh = Uf
Object.defineProperties(Y, {
    UPLOADS_PER_FRAME: {
        get() {
            return vh.uploadsPerFrame
        },
        set(s) {
            ;(ft(
                '7.1.0',
                'settings.UPLOADS_PER_FRAME is deprecated, use prepare.BasePrepare.uploadsPerFrame',
            ),
                (vh.uploadsPerFrame = s))
        },
    },
})
function Hf(s, t) {
    return t instanceof lt
        ? (t._glTextures[s.CONTEXT_UID] || s.texture.bind(t), !0)
        : !1
}
function cv(s, t) {
    if (!(t instanceof Kh)) return !1
    const { geometry: e } = t
    ;(t.finishPoly(), e.updateBatches())
    const { batches: i } = e
    for (let r = 0; r < i.length; r++) {
        const { texture: n } = i[r].style
        n && Hf(s, n.baseTexture)
    }
    return (e.batchable || s.geometry.bind(e, t._resolveDirectShader(s)), !0)
}
function dv(s, t) {
    return s instanceof Kh ? (t.push(s), !0) : !1
}
class zf extends vh {
    constructor(t) {
        ;(super(t),
            (this.uploadHookHelper = this.renderer),
            this.registerFindHook(dv),
            this.registerUploadHook(Hf),
            this.registerUploadHook(cv))
    }
}
zf.extension = { name: 'prepare', type: $.RendererSystem }
Q.add(zf)
var fv = `#version 300 es
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

in vec2 vTextureCoord;

out vec4 fragmentColor;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0

    fragmentColor = texSample * uColor;
}
`,
    pv = `#version 300 es
#define SHADER_NAME Tiling-Sprite-300

precision lowp float;

in vec2 aVertexPosition;
in vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

out vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`,
    mv = `#version 100
#ifdef GL_EXT_shader_texture_lod
    #extension GL_EXT_shader_texture_lod : enable
#endif
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    #ifdef GL_EXT_shader_texture_lod
        vec4 texSample = unclamped == coord
            ? texture2D(uSampler, coord) 
            : texture2DLodEXT(uSampler, coord, 0);
    #else
        vec4 texSample = texture2D(uSampler, coord);
    #endif

    gl_FragColor = texSample * uColor;
}
`,
    qc = `#version 100
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`,
    gv = `#version 100
#define SHADER_NAME Tiling-Sprite-Simple-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;

void main(void)
{
    vec4 texSample = texture2D(uSampler, vTextureCoord);
    gl_FragColor = texSample * uColor;
}
`
const qs = new Et()
class Vf extends Un {
    constructor(t) {
        ;(super(t),
            t.runners.contextChange.add(this),
            (this.quad = new Xd()),
            (this.state = $e.for2d()))
    }
    contextChange() {
        const t = this.renderer,
            e = { globals: t.globalUniforms }
        ;((this.simpleShader = Ve.from(qc, gv, e)),
            (this.shader =
                t.context.webGLVersion > 1
                    ? Ve.from(pv, fv, e)
                    : Ve.from(qc, mv, e)))
    }
    render(t) {
        const e = this.renderer,
            i = this.quad
        let r = i.vertices
        ;((r[0] = r[6] = t._width * -t.anchor.x),
            (r[1] = r[3] = t._height * -t.anchor.y),
            (r[2] = r[4] = t._width * (1 - t.anchor.x)),
            (r[5] = r[7] = t._height * (1 - t.anchor.y)))
        const n = t.uvRespectAnchor ? t.anchor.x : 0,
            a = t.uvRespectAnchor ? t.anchor.y : 0
        ;((r = i.uvs),
            (r[0] = r[6] = -n),
            (r[1] = r[3] = -a),
            (r[2] = r[4] = 1 - n),
            (r[5] = r[7] = 1 - a),
            i.invalidate())
        const o = t._texture,
            h = o.baseTexture,
            l = h.alphaMode > 0,
            u = t.tileTransform.localTransform,
            c = t.uvMatrix
        let d =
            h.isPowerOfTwo &&
            o.frame.width === h.width &&
            o.frame.height === h.height
        d &&
            (h._glTextures[e.CONTEXT_UID]
                ? (d = h.wrapMode !== xi.CLAMP)
                : h.wrapMode === xi.CLAMP && (h.wrapMode = xi.REPEAT))
        const f = d ? this.simpleShader : this.shader,
            m = o.width,
            p = o.height,
            g = t._width,
            _ = t._height
        ;(qs.set(
            (u.a * m) / g,
            (u.b * m) / _,
            (u.c * p) / g,
            (u.d * p) / _,
            u.tx / g,
            u.ty / _,
        ),
            qs.invert(),
            d
                ? qs.prepend(c.mapCoord)
                : ((f.uniforms.uMapCoord = c.mapCoord.toArray(!0)),
                  (f.uniforms.uClampFrame = c.uClampFrame),
                  (f.uniforms.uClampOffset = c.uClampOffset)),
            (f.uniforms.uTransform = qs.toArray(!0)),
            (f.uniforms.uColor = Tt.shared
                .setValue(t.tint)
                .premultiply(t.worldAlpha, l)
                .toArray(f.uniforms.uColor)),
            (f.uniforms.translationMatrix =
                t.transform.worldTransform.toArray(!0)),
            (f.uniforms.uSampler = o),
            e.shader.bind(f),
            e.geometry.bind(i),
            (this.state.blendMode = Md(t.blendMode, l)),
            e.state.set(this.state),
            e.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0))
    }
}
Vf.extension = { name: 'tilingSprite', type: $.RendererPlugin }
Q.add(Vf)
const Xf = class is {
    constructor(t, e, i) {
        ;((this.linkedSheets = []),
            (t instanceof lt || t instanceof j) &&
                (t = { texture: t, data: e, resolutionFilename: i }))
        const {
            texture: r,
            data: n,
            resolutionFilename: a = null,
            cachePrefix: o = '',
        } = t
        ;((this.cachePrefix = o),
            (this._texture = r instanceof j ? r : null),
            (this.baseTexture =
                r instanceof lt ? r : this._texture.baseTexture),
            (this.textures = {}),
            (this.animations = {}),
            (this.data = n))
        const h = this.baseTexture.resource
        ;((this.resolution = this._updateResolution(a || (h ? h.url : null))),
            (this._frames = this.data.frames),
            (this._frameKeys = Object.keys(this._frames)),
            (this._batchIndex = 0),
            (this._callback = null))
    }
    _updateResolution(t = null) {
        const { scale: e } = this.data.meta
        let i = ii(t, null)
        return (
            i === null && (i = typeof e == 'number' ? e : parseFloat(e ?? '1')),
            i !== 1 && this.baseTexture.setResolution(i),
            i
        )
    }
    parse() {
        return new Promise(t => {
            ;((this._callback = t),
                (this._batchIndex = 0),
                this._frameKeys.length <= is.BATCH_SIZE
                    ? (this._processFrames(0),
                      this._processAnimations(),
                      this._parseComplete())
                    : this._nextBatch())
        })
    }
    _processFrames(t) {
        let e = t
        const i = is.BATCH_SIZE
        for (; e - t < i && e < this._frameKeys.length; ) {
            const r = this._frameKeys[e],
                n = this._frames[r],
                a = n.frame
            if (a) {
                let o = null,
                    h = null
                const l =
                        n.trimmed !== !1 && n.sourceSize
                            ? n.sourceSize
                            : n.frame,
                    u = new dt(
                        0,
                        0,
                        Math.floor(l.w) / this.resolution,
                        Math.floor(l.h) / this.resolution,
                    )
                ;(n.rotated
                    ? (o = new dt(
                          Math.floor(a.x) / this.resolution,
                          Math.floor(a.y) / this.resolution,
                          Math.floor(a.h) / this.resolution,
                          Math.floor(a.w) / this.resolution,
                      ))
                    : (o = new dt(
                          Math.floor(a.x) / this.resolution,
                          Math.floor(a.y) / this.resolution,
                          Math.floor(a.w) / this.resolution,
                          Math.floor(a.h) / this.resolution,
                      )),
                    n.trimmed !== !1 &&
                        n.spriteSourceSize &&
                        (h = new dt(
                            Math.floor(n.spriteSourceSize.x) / this.resolution,
                            Math.floor(n.spriteSourceSize.y) / this.resolution,
                            Math.floor(a.w) / this.resolution,
                            Math.floor(a.h) / this.resolution,
                        )),
                    (this.textures[r] = new j(
                        this.baseTexture,
                        o,
                        u,
                        h,
                        n.rotated ? 2 : 0,
                        n.anchor,
                        n.borders,
                    )),
                    j.addToCache(
                        this.textures[r],
                        this.cachePrefix + r.toString(),
                    ))
            }
            e++
        }
    }
    _processAnimations() {
        const t = this.data.animations || {}
        for (const e in t) {
            this.animations[e] = []
            for (let i = 0; i < t[e].length; i++) {
                const r = t[e][i]
                this.animations[e].push(this.textures[r])
            }
        }
    }
    _parseComplete() {
        const t = this._callback
        ;((this._callback = null),
            (this._batchIndex = 0),
            t.call(this, this.textures))
    }
    _nextBatch() {
        ;(this._processFrames(this._batchIndex * is.BATCH_SIZE),
            this._batchIndex++,
            setTimeout(() => {
                this._batchIndex * is.BATCH_SIZE < this._frameKeys.length
                    ? this._nextBatch()
                    : (this._processAnimations(), this._parseComplete())
            }, 0))
    }
    destroy(t = !1) {
        for (const e in this.textures) this.textures[e].destroy()
        ;((this._frames = null),
            (this._frameKeys = null),
            (this.data = null),
            (this.textures = null),
            t && (this._texture?.destroy(), this.baseTexture.destroy()),
            (this._texture = null),
            (this.baseTexture = null),
            (this.linkedSheets = []))
    }
}
Xf.BATCH_SIZE = 1e3
let Yc = Xf
const _v = [
    'jpg',
    'png',
    'jpeg',
    'avif',
    'webp',
    's3tc',
    's3tc_sRGB',
    'etc',
    'etc1',
    'pvrtc',
    'atc',
    'astc',
    'bptc',
]
function Wf(s, t, e) {
    const i = {}
    if (
        (s.forEach(r => {
            i[r] = t
        }),
        Object.keys(t.textures).forEach(r => {
            i[`${t.cachePrefix}${r}`] = t.textures[r]
        }),
        !e)
    ) {
        const r = Gt.dirname(s[0])
        t.linkedSheets.forEach((n, a) => {
            Object.assign(
                i,
                Wf([`${r}/${t.data.meta.related_multi_packs[a]}`], n, !0),
            )
        })
    }
    return i
}
const yv = {
    extension: $.Asset,
    cache: {
        test: s => s instanceof Yc,
        getCacheableAssets: (s, t) => Wf(s, t, !1),
    },
    resolver: {
        test: s => {
            const t = s.split('?')[0].split('.'),
                e = t.pop(),
                i = t.pop()
            return e === 'json' && _v.includes(i)
        },
        parse: s => {
            const t = s.split('.')
            return {
                resolution: parseFloat(Y.RETINA_PREFIX.exec(s)?.[1] ?? '1'),
                format: t[t.length - 2],
                src: s,
            }
        },
    },
    loader: {
        name: 'spritesheetLoader',
        extension: { type: $.LoadParser, priority: Pe.Normal },
        async testParse(s, t) {
            return Gt.extname(t.src).toLowerCase() === '.json' && !!s.frames
        },
        async parse(s, t, e) {
            const {
                texture: i,
                imageFilename: r,
                cachePrefix: n,
            } = t?.data ?? {}
            let a = Gt.dirname(t.src)
            a && a.lastIndexOf('/') !== a.length - 1 && (a += '/')
            let o
            if (i && i.baseTexture) o = i
            else {
                const u = dh(a + (r ?? s.meta.image), t.src)
                o = (await e.load([u]))[u]
            }
            const h = new Yc({
                texture: o.baseTexture,
                data: s,
                resolutionFilename: t.src,
                cachePrefix: n,
            })
            await h.parse()
            const l = s?.meta?.related_multi_packs
            if (Array.isArray(l)) {
                const u = []
                for (const d of l) {
                    if (typeof d != 'string') continue
                    let f = a + d
                    t.data?.ignoreMultiPack ||
                        ((f = dh(f, t.src)),
                        u.push(
                            e.load({ src: f, data: { ignoreMultiPack: !0 } }),
                        ))
                }
                const c = await Promise.all(u)
                ;((h.linkedSheets = c),
                    c.forEach(d => {
                        d.linkedSheets = [h].concat(
                            h.linkedSheets.filter(f => f !== d),
                        )
                    }))
            }
            return h
        },
        unload(s) {
            s.destroy(!0)
        },
    },
}
Q.add(yv)
class An {
    constructor() {
        ;((this.info = []),
            (this.common = []),
            (this.page = []),
            (this.char = []),
            (this.kerning = []),
            (this.distanceField = []))
    }
}
class an {
    static test(t) {
        return typeof t == 'string' && t.startsWith('info face=')
    }
    static parse(t) {
        const e = t.match(/^[a-z]+\s+.+$/gm),
            i = {
                info: [],
                common: [],
                page: [],
                char: [],
                chars: [],
                kerning: [],
                kernings: [],
                distanceField: [],
            }
        for (const n in e) {
            const a = e[n].match(/^[a-z]+/gm)[0],
                o = e[n].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm),
                h = {}
            for (const l in o) {
                const u = o[l].split('='),
                    c = u[0],
                    d = u[1].replace(/"/gm, ''),
                    f = parseFloat(d),
                    m = isNaN(f) ? d : f
                h[c] = m
            }
            i[a].push(h)
        }
        const r = new An()
        return (
            i.info.forEach(n =>
                r.info.push({ face: n.face, size: parseInt(n.size, 10) }),
            ),
            i.common.forEach(n =>
                r.common.push({ lineHeight: parseInt(n.lineHeight, 10) }),
            ),
            i.page.forEach(n =>
                r.page.push({ id: parseInt(n.id, 10), file: n.file }),
            ),
            i.char.forEach(n =>
                r.char.push({
                    id: parseInt(n.id, 10),
                    page: parseInt(n.page, 10),
                    x: parseInt(n.x, 10),
                    y: parseInt(n.y, 10),
                    width: parseInt(n.width, 10),
                    height: parseInt(n.height, 10),
                    xoffset: parseInt(n.xoffset, 10),
                    yoffset: parseInt(n.yoffset, 10),
                    xadvance: parseInt(n.xadvance, 10),
                }),
            ),
            i.kerning.forEach(n =>
                r.kerning.push({
                    first: parseInt(n.first, 10),
                    second: parseInt(n.second, 10),
                    amount: parseInt(n.amount, 10),
                }),
            ),
            i.distanceField.forEach(n =>
                r.distanceField.push({
                    distanceRange: parseInt(n.distanceRange, 10),
                    fieldType: n.fieldType,
                }),
            ),
            r
        )
    }
}
class xh {
    static test(t) {
        const e = t
        return (
            typeof t != 'string' &&
            'getElementsByTagName' in t &&
            e.getElementsByTagName('page').length &&
            e.getElementsByTagName('info')[0].getAttribute('face') !== null
        )
    }
    static parse(t) {
        const e = new An(),
            i = t.getElementsByTagName('info'),
            r = t.getElementsByTagName('common'),
            n = t.getElementsByTagName('page'),
            a = t.getElementsByTagName('char'),
            o = t.getElementsByTagName('kerning'),
            h = t.getElementsByTagName('distanceField')
        for (let l = 0; l < i.length; l++)
            e.info.push({
                face: i[l].getAttribute('face'),
                size: parseInt(i[l].getAttribute('size'), 10),
            })
        for (let l = 0; l < r.length; l++)
            e.common.push({
                lineHeight: parseInt(r[l].getAttribute('lineHeight'), 10),
            })
        for (let l = 0; l < n.length; l++)
            e.page.push({
                id: parseInt(n[l].getAttribute('id'), 10) || 0,
                file: n[l].getAttribute('file'),
            })
        for (let l = 0; l < a.length; l++) {
            const u = a[l]
            e.char.push({
                id: parseInt(u.getAttribute('id'), 10),
                page: parseInt(u.getAttribute('page'), 10) || 0,
                x: parseInt(u.getAttribute('x'), 10),
                y: parseInt(u.getAttribute('y'), 10),
                width: parseInt(u.getAttribute('width'), 10),
                height: parseInt(u.getAttribute('height'), 10),
                xoffset: parseInt(u.getAttribute('xoffset'), 10),
                yoffset: parseInt(u.getAttribute('yoffset'), 10),
                xadvance: parseInt(u.getAttribute('xadvance'), 10),
            })
        }
        for (let l = 0; l < o.length; l++)
            e.kerning.push({
                first: parseInt(o[l].getAttribute('first'), 10),
                second: parseInt(o[l].getAttribute('second'), 10),
                amount: parseInt(o[l].getAttribute('amount'), 10),
            })
        for (let l = 0; l < h.length; l++)
            e.distanceField.push({
                fieldType: h[l].getAttribute('fieldType'),
                distanceRange: parseInt(h[l].getAttribute('distanceRange'), 10),
            })
        return e
    }
}
class bh {
    static test(t) {
        return typeof t == 'string' && t.includes('<font>')
            ? xh.test(Y.ADAPTER.parseXML(t))
            : !1
    }
    static parse(t) {
        return xh.parse(Y.ADAPTER.parseXML(t))
    }
}
const Ao = [an, xh, bh]
function vv(s) {
    for (let t = 0; t < Ao.length; t++) if (Ao[t].test(s)) return Ao[t]
    return null
}
function xv(s, t, e, i, r, n) {
    const a = e.fill
    if (Array.isArray(a)) {
        if (a.length === 1) return a[0]
    } else return a
    let o
    const h = e.dropShadow ? e.dropShadowDistance : 0,
        l = e.padding || 0,
        u = s.width / i - h - l * 2,
        c = s.height / i - h - l * 2,
        d = a.slice(),
        f = e.fillGradientStops.slice()
    if (!f.length) {
        const m = d.length + 1
        for (let p = 1; p < m; ++p) f.push(p / m)
    }
    if (
        (d.unshift(a[0]),
        f.unshift(0),
        d.push(a[a.length - 1]),
        f.push(1),
        e.fillGradientType === zn.LINEAR_VERTICAL)
    ) {
        o = t.createLinearGradient(u / 2, l, u / 2, c + l)
        let m = 0
        const p = (n.fontProperties.fontSize + e.strokeThickness) / c
        for (let g = 0; g < r.length; g++) {
            const _ = n.lineHeight * g
            for (let b = 0; b < d.length; b++) {
                let v = 0
                typeof f[b] == 'number' ? (v = f[b]) : (v = b / d.length)
                const w = _ / c + v * p
                let x = Math.max(m, w)
                ;((x = Math.min(x, 1)), o.addColorStop(x, d[b]), (m = x))
            }
        }
    } else {
        o = t.createLinearGradient(l, c / 2, u + l, c / 2)
        const m = d.length + 1
        let p = 1
        for (let g = 0; g < d.length; g++) {
            let _
            ;(typeof f[g] == 'number' ? (_ = f[g]) : (_ = p / m),
                o.addColorStop(_, d[g]),
                p++)
        }
    }
    return o
}
function bv(s, t, e, i, r, n, a) {
    const o = e.text,
        h = e.fontProperties
    ;(t.translate(i, r), t.scale(n, n))
    const l = a.strokeThickness / 2,
        u = -(a.strokeThickness / 2)
    if (
        ((t.font = a.toFontString()),
        (t.lineWidth = a.strokeThickness),
        (t.textBaseline = a.textBaseline),
        (t.lineJoin = a.lineJoin),
        (t.miterLimit = a.miterLimit),
        (t.fillStyle = xv(s, t, a, n, [o], e)),
        (t.strokeStyle = a.stroke),
        a.dropShadow)
    ) {
        const c = a.dropShadowColor,
            d = a.dropShadowBlur * n,
            f = a.dropShadowDistance * n
        ;((t.shadowColor = Tt.shared
            .setValue(c)
            .setAlpha(a.dropShadowAlpha)
            .toRgbaString()),
            (t.shadowBlur = d),
            (t.shadowOffsetX = Math.cos(a.dropShadowAngle) * f),
            (t.shadowOffsetY = Math.sin(a.dropShadowAngle) * f))
    } else
        ((t.shadowColor = 'black'),
            (t.shadowBlur = 0),
            (t.shadowOffsetX = 0),
            (t.shadowOffsetY = 0))
    ;(a.stroke &&
        a.strokeThickness &&
        t.strokeText(o, l, u + e.lineHeight - h.descent),
        a.fill && t.fillText(o, l, u + e.lineHeight - h.descent),
        t.setTransform(1, 0, 0, 1, 0, 0),
        (t.fillStyle = 'rgba(0, 0, 0, 0)'))
}
function on(s) {
    return s.codePointAt ? s.codePointAt(0) : s.charCodeAt(0)
}
function $f(s) {
    return Array.from ? Array.from(s) : s.split('')
}
function wv(s) {
    typeof s == 'string' && (s = [s])
    const t = []
    for (let e = 0, i = s.length; e < i; e++) {
        const r = s[e]
        if (Array.isArray(r)) {
            if (r.length !== 2)
                throw new Error(
                    `[BitmapFont]: Invalid character range length, expecting 2 got ${r.length}.`,
                )
            const n = r[0].charCodeAt(0),
                a = r[1].charCodeAt(0)
            if (a < n) throw new Error('[BitmapFont]: Invalid character range.')
            for (let o = n, h = a; o <= h; o++) t.push(String.fromCharCode(o))
        } else t.push(...$f(r))
    }
    if (t.length === 0)
        throw new Error('[BitmapFont]: Empty set when resolving characters.')
    return t
}
const ci = class Be {
    constructor(t, e, i) {
        const [r] = t.info,
            [n] = t.common,
            [a] = t.page,
            [o] = t.distanceField,
            h = ii(a.file),
            l = {}
        ;((this._ownsTextures = i),
            (this.font = r.face),
            (this.size = r.size),
            (this.lineHeight = n.lineHeight / h),
            (this.chars = {}),
            (this.pageTextures = l))
        for (let u = 0; u < t.page.length; u++) {
            const { id: c, file: d } = t.page[u]
            ;((l[c] = e instanceof Array ? e[u] : e[d]),
                o?.fieldType &&
                    o.fieldType !== 'none' &&
                    ((l[c].baseTexture.alphaMode = Zt.NO_PREMULTIPLIED_ALPHA),
                    (l[c].baseTexture.mipmap = Xe.OFF)))
        }
        for (let u = 0; u < t.char.length; u++) {
            const { id: c, page: d } = t.char[u]
            let {
                x: f,
                y: m,
                width: p,
                height: g,
                xoffset: _,
                yoffset: b,
                xadvance: v,
            } = t.char[u]
            ;((f /= h),
                (m /= h),
                (p /= h),
                (g /= h),
                (_ /= h),
                (b /= h),
                (v /= h))
            const w = new dt(f + l[d].frame.x / h, m + l[d].frame.y / h, p, g)
            this.chars[c] = {
                xOffset: _,
                yOffset: b,
                xAdvance: v,
                kerning: {},
                texture: new j(l[d].baseTexture, w),
                page: d,
            }
        }
        for (let u = 0; u < t.kerning.length; u++) {
            let { first: c, second: d, amount: f } = t.kerning[u]
            ;((c /= h),
                (d /= h),
                (f /= h),
                this.chars[d] && (this.chars[d].kerning[c] = f))
        }
        ;((this.distanceFieldRange = o?.distanceRange),
            (this.distanceFieldType = o?.fieldType?.toLowerCase() ?? 'none'))
    }
    destroy() {
        for (const t in this.chars)
            (this.chars[t].texture.destroy(), (this.chars[t].texture = null))
        for (const t in this.pageTextures)
            (this._ownsTextures && this.pageTextures[t].destroy(!0),
                (this.pageTextures[t] = null))
        ;((this.chars = null), (this.pageTextures = null))
    }
    static install(t, e, i) {
        let r
        if (t instanceof An) r = t
        else {
            const a = vv(t)
            if (!a) throw new Error('Unrecognized data format for font.')
            r = a.parse(t)
        }
        e instanceof j && (e = [e])
        const n = new Be(r, e, i)
        return ((Be.available[n.font] = n), n)
    }
    static uninstall(t) {
        const e = Be.available[t]
        if (!e) throw new Error(`No font found named '${t}'`)
        ;(e.destroy(), delete Be.available[t])
    }
    static from(t, e, i) {
        if (!t) throw new Error('[BitmapFont] Property `name` is required.')
        const {
                chars: r,
                padding: n,
                resolution: a,
                textureWidth: o,
                textureHeight: h,
                ...l
            } = Object.assign({}, Be.defaultOptions, i),
            u = wv(r),
            c = e instanceof si ? e : new si(e),
            d = o,
            f = new An()
        ;((f.info[0] = { face: c.fontFamily, size: c.fontSize }),
            (f.common[0] = { lineHeight: c.fontSize }))
        let m = 0,
            p = 0,
            g,
            _,
            b,
            v = 0
        const w = []
        for (let P = 0; P < u.length; P++) {
            g ||
                ((g = Y.ADAPTER.createCanvas()),
                (g.width = o),
                (g.height = h),
                (_ = g.getContext('2d')),
                (b = new lt(g, { resolution: a, ...l })),
                w.push(new j(b)),
                f.page.push({ id: w.length - 1, file: '' }))
            const y = u[P],
                S = fi.measureText(y, c, !1, g),
                R = S.width,
                G = Math.ceil(S.height),
                N = Math.ceil((c.fontStyle === 'italic' ? 2 : 1) * R)
            if (p >= h - G * a) {
                if (p === 0)
                    throw new Error(
                        `[BitmapFont] textureHeight ${h}px is too small (fontFamily: '${c.fontFamily}', fontSize: ${c.fontSize}px, char: '${y}')`,
                    )
                ;(--P,
                    (g = null),
                    (_ = null),
                    (b = null),
                    (p = 0),
                    (m = 0),
                    (v = 0))
                continue
            }
            if (
                ((v = Math.max(G + S.fontProperties.descent, v)),
                N * a + m >= d)
            ) {
                if (m === 0)
                    throw new Error(
                        `[BitmapFont] textureWidth ${o}px is too small (fontFamily: '${c.fontFamily}', fontSize: ${c.fontSize}px, char: '${y}')`,
                    )
                ;(--P, (p += v * a), (p = Math.ceil(p)), (m = 0), (v = 0))
                continue
            }
            bv(g, _, S, m, p, a, c)
            const I = on(S.text)
            ;(f.char.push({
                id: I,
                page: w.length - 1,
                x: m / a,
                y: p / a,
                width: N,
                height: G,
                xoffset: 0,
                yoffset: 0,
                xadvance:
                    R -
                    (c.dropShadow ? c.dropShadowDistance : 0) -
                    (c.stroke ? c.strokeThickness : 0),
            }),
                (m += (N + 2 * n) * a),
                (m = Math.ceil(m)))
        }
        if (!i?.skipKerning)
            for (let P = 0, y = u.length; P < y; P++) {
                const S = u[P]
                for (let R = 0; R < y; R++) {
                    const G = u[R],
                        N = _.measureText(S).width,
                        I = _.measureText(G).width,
                        O = _.measureText(S + G).width - (N + I)
                    O &&
                        f.kerning.push({
                            first: on(S),
                            second: on(G),
                            amount: O,
                        })
                }
            }
        const x = new Be(f, w, !0)
        return (
            Be.available[t] !== void 0 && Be.uninstall(t),
            (Be.available[t] = x),
            x
        )
    }
}
;((ci.ALPHA = [['a', 'z'], ['A', 'Z'], ' ']),
    (ci.NUMERIC = [['0', '9']]),
    (ci.ALPHANUMERIC = [['a', 'z'], ['A', 'Z'], ['0', '9'], ' ']),
    (ci.ASCII = [[' ', '~']]),
    (ci.defaultOptions = {
        resolution: 1,
        textureWidth: 512,
        textureHeight: 512,
        padding: 4,
        chars: ci.ALPHANUMERIC,
    }),
    (ci.available = {}))
let di = ci
var Tv = `// Pixi texture info\r
varying vec2 vTextureCoord;\r
uniform sampler2D uSampler;\r
\r
// Tint\r
uniform vec4 uColor;\r
\r
// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r
uniform float uFWidth;\r
\r
void main(void) {\r
\r
  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r
  vec4 texColor = texture2D(uSampler, vTextureCoord);\r
\r
  // MSDF\r
  float median = texColor.r + texColor.g + texColor.b -\r
                  min(texColor.r, min(texColor.g, texColor.b)) -\r
                  max(texColor.r, max(texColor.g, texColor.b));\r
  // SDF\r
  median = min(median, texColor.a);\r
\r
  float screenPxDistance = uFWidth * (median - 0.5);\r
  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r
  if (median < 0.01) {\r
    alpha = 0.0;\r
  } else if (median > 0.99) {\r
    alpha = 1.0;\r
  }\r
\r
  // Gamma correction for coverage-like alpha\r
  float luma = dot(uColor.rgb, vec3(0.299, 0.587, 0.114));\r
  float gamma = mix(1.0, 1.0 / 2.2, luma);\r
  float coverage = pow(uColor.a * alpha, gamma);  \r
\r
  // NPM Textures, NPM outputs\r
  gl_FragColor = vec4(uColor.rgb, coverage);\r
}\r
`,
    Ev = `// Mesh material default fragment\r
attribute vec2 aVertexPosition;\r
attribute vec2 aTextureCoord;\r
\r
uniform mat3 projectionMatrix;\r
uniform mat3 translationMatrix;\r
uniform mat3 uTextureMatrix;\r
\r
varying vec2 vTextureCoord;\r
\r
void main(void)\r
{\r
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r
\r
    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r
}\r
`
const Kc = [],
    Zc = [],
    Qc = [],
    Av = class jf extends Kt {
        constructor(t, e = {}) {
            super()
            const {
                align: i,
                tint: r,
                maxWidth: n,
                letterSpacing: a,
                fontName: o,
                fontSize: h,
            } = Object.assign({}, jf.styleDefaults, e)
            if (!di.available[o]) throw new Error(`Missing BitmapFont "${o}"`)
            ;((this._activePagesMeshData = []),
                (this._textWidth = 0),
                (this._textHeight = 0),
                (this._align = i),
                (this._tintColor = new Tt(r)),
                (this._font = void 0),
                (this._fontName = o),
                (this._fontSize = h),
                (this.text = t),
                (this._maxWidth = n),
                (this._maxLineHeight = 0),
                (this._letterSpacing = a),
                (this._anchor = new Je(
                    () => {
                        this.dirty = !0
                    },
                    this,
                    0,
                    0,
                )),
                (this._roundPixels = Y.ROUND_PIXELS),
                (this.dirty = !0),
                (this._resolution = Y.RESOLUTION),
                (this._autoResolution = !0),
                (this._textureCache = {}))
        }
        updateText() {
            const t = di.available[this._fontName],
                e = this.fontSize,
                i = e / t.size,
                r = new ut(),
                n = [],
                a = [],
                o = [],
                h =
                    this._text.replace(
                        /(?:\r\n|\r)/g,
                        `
`,
                    ) || ' ',
                l = $f(h),
                u = (this._maxWidth * t.size) / e,
                c = t.distanceFieldType === 'none' ? Kc : Zc
            let d = null,
                f = 0,
                m = 0,
                p = 0,
                g = -1,
                _ = 0,
                b = 0,
                v = 0,
                w = 0
            for (let N = 0; N < l.length; N++) {
                const I = l[N],
                    O = on(I)
                if (
                    (/(?:\s)/.test(I) && ((g = N), (_ = f), w++),
                    I === '\r' ||
                        I ===
                            `
`)
                ) {
                    ;(a.push(f),
                        o.push(-1),
                        (m = Math.max(m, f)),
                        ++p,
                        ++b,
                        (r.x = 0),
                        (r.y += t.lineHeight),
                        (d = null),
                        (w = 0))
                    continue
                }
                const L = t.chars[O]
                if (!L) continue
                d && L.kerning[d] && (r.x += L.kerning[d])
                const V = Qc.pop() || {
                    texture: j.EMPTY,
                    line: 0,
                    charCode: 0,
                    prevSpaces: 0,
                    position: new ut(),
                }
                ;((V.texture = L.texture),
                    (V.line = p),
                    (V.charCode = O),
                    (V.position.x = Math.round(
                        r.x + L.xOffset + this._letterSpacing / 2,
                    )),
                    (V.position.y = Math.round(r.y + L.yOffset)),
                    (V.prevSpaces = w),
                    n.push(V),
                    (f =
                        V.position.x +
                        Math.max(L.xAdvance - L.xOffset, L.texture.orig.width)),
                    (r.x += L.xAdvance + this._letterSpacing),
                    (v = Math.max(v, L.yOffset + L.texture.height)),
                    (d = O),
                    g !== -1 &&
                        u > 0 &&
                        r.x > u &&
                        (++b,
                        Er(n, 1 + g - b, 1 + N - g),
                        (N = g),
                        (g = -1),
                        a.push(_),
                        o.push(n.length > 0 ? n[n.length - 1].prevSpaces : 0),
                        (m = Math.max(m, _)),
                        p++,
                        (r.x = 0),
                        (r.y += t.lineHeight),
                        (d = null),
                        (w = 0)))
            }
            const x = l[l.length - 1]
            x !== '\r' &&
                x !==
                    `
` &&
                (/(?:\s)/.test(x) && (f = _),
                a.push(f),
                (m = Math.max(m, f)),
                o.push(-1))
            const P = []
            for (let N = 0; N <= p; N++) {
                let I = 0
                ;(this._align === 'right'
                    ? (I = m - a[N])
                    : this._align === 'center'
                      ? (I = (m - a[N]) / 2)
                      : this._align === 'justify' &&
                        (I = o[N] < 0 ? 0 : (m - a[N]) / o[N]),
                    P.push(I))
            }
            const y = n.length,
                S = {},
                R = [],
                G = this._activePagesMeshData
            c.push(...G)
            for (let N = 0; N < y; N++) {
                const I = n[N].texture,
                    O = I.baseTexture.uid
                if (!S[O]) {
                    let L = c.pop()
                    if (!L) {
                        const T = new Ff()
                        let A, E
                        t.distanceFieldType === 'none'
                            ? ((A = new _h(j.EMPTY)), (E = ot.NORMAL))
                            : ((A = new _h(j.EMPTY, {
                                  program: ti.from(Ev, Tv),
                                  uniforms: { uFWidth: 0 },
                              })),
                              (E = ot.NORMAL_NPM))
                        const B = new gh(T, A)
                        ;((B.blendMode = E),
                            (L = {
                                index: 0,
                                indexCount: 0,
                                vertexCount: 0,
                                uvsCount: 0,
                                total: 0,
                                mesh: B,
                                vertices: null,
                                uvs: null,
                                indices: null,
                            }))
                    }
                    ;((L.index = 0),
                        (L.indexCount = 0),
                        (L.vertexCount = 0),
                        (L.uvsCount = 0),
                        (L.total = 0))
                    const { _textureCache: V } = this
                    ;((V[O] = V[O] || new j(I.baseTexture)),
                        (L.mesh.texture = V[O]),
                        (L.mesh.tint = this._tintColor.value),
                        R.push(L),
                        (S[O] = L))
                }
                S[O].total++
            }
            for (let N = 0; N < G.length; N++)
                R.includes(G[N]) || this.removeChild(G[N].mesh)
            for (let N = 0; N < R.length; N++)
                R[N].mesh.parent !== this && this.addChild(R[N].mesh)
            this._activePagesMeshData = R
            for (const N in S) {
                const I = S[N],
                    O = I.total
                if (
                    !(I.indices?.length > 6 * O) ||
                    I.vertices.length < gh.BATCHABLE_SIZE * 2
                )
                    ((I.vertices = new Float32Array(4 * 2 * O)),
                        (I.uvs = new Float32Array(4 * 2 * O)),
                        (I.indices = new Uint16Array(6 * O)))
                else {
                    const L = I.total,
                        V = I.vertices
                    for (let T = L * 4 * 2; T < V.length; T++) V[T] = 0
                }
                I.mesh.size = 6 * O
            }
            for (let N = 0; N < y; N++) {
                const I = n[N]
                let O =
                    I.position.x +
                    P[I.line] * (this._align === 'justify' ? I.prevSpaces : 1)
                this._roundPixels && (O = Math.round(O))
                const L = O * i,
                    V = I.position.y * i,
                    T = I.texture,
                    A = S[T.baseTexture.uid],
                    E = T.frame,
                    B = T._uvs,
                    C = A.index++
                ;((A.indices[C * 6 + 0] = 0 + C * 4),
                    (A.indices[C * 6 + 1] = 1 + C * 4),
                    (A.indices[C * 6 + 2] = 2 + C * 4),
                    (A.indices[C * 6 + 3] = 0 + C * 4),
                    (A.indices[C * 6 + 4] = 2 + C * 4),
                    (A.indices[C * 6 + 5] = 3 + C * 4),
                    (A.vertices[C * 8 + 0] = L),
                    (A.vertices[C * 8 + 1] = V),
                    (A.vertices[C * 8 + 2] = L + E.width * i),
                    (A.vertices[C * 8 + 3] = V),
                    (A.vertices[C * 8 + 4] = L + E.width * i),
                    (A.vertices[C * 8 + 5] = V + E.height * i),
                    (A.vertices[C * 8 + 6] = L),
                    (A.vertices[C * 8 + 7] = V + E.height * i),
                    (A.uvs[C * 8 + 0] = B.x0),
                    (A.uvs[C * 8 + 1] = B.y0),
                    (A.uvs[C * 8 + 2] = B.x1),
                    (A.uvs[C * 8 + 3] = B.y1),
                    (A.uvs[C * 8 + 4] = B.x2),
                    (A.uvs[C * 8 + 5] = B.y2),
                    (A.uvs[C * 8 + 6] = B.x3),
                    (A.uvs[C * 8 + 7] = B.y3))
            }
            ;((this._textWidth = m * i),
                (this._textHeight = (r.y + t.lineHeight) * i))
            for (const N in S) {
                const I = S[N]
                if (this.anchor.x !== 0 || this.anchor.y !== 0) {
                    let T = 0
                    const A = this._textWidth * this.anchor.x,
                        E = this._textHeight * this.anchor.y
                    for (let B = 0; B < I.total; B++)
                        ((I.vertices[T++] -= A),
                            (I.vertices[T++] -= E),
                            (I.vertices[T++] -= A),
                            (I.vertices[T++] -= E),
                            (I.vertices[T++] -= A),
                            (I.vertices[T++] -= E),
                            (I.vertices[T++] -= A),
                            (I.vertices[T++] -= E))
                }
                this._maxLineHeight = v * i
                const O = I.mesh.geometry.getBuffer('aVertexPosition'),
                    L = I.mesh.geometry.getBuffer('aTextureCoord'),
                    V = I.mesh.geometry.getIndex()
                ;((O.data = I.vertices),
                    (L.data = I.uvs),
                    (V.data = I.indices),
                    O.update(),
                    L.update(),
                    V.update())
            }
            for (let N = 0; N < n.length; N++) Qc.push(n[N])
            ;((this._font = t), (this.dirty = !1))
        }
        updateTransform() {
            ;(this.validate(), this.containerUpdateTransform())
        }
        _render(t) {
            this._autoResolution &&
                this._resolution !== t.resolution &&
                ((this._resolution = t.resolution), (this.dirty = !0))
            const {
                distanceFieldRange: e,
                distanceFieldType: i,
                size: r,
            } = di.available[this._fontName]
            if (i !== 'none') {
                const { a: n, b: a, c: o, d: h } = this.worldTransform,
                    l = Math.sqrt(n * n + a * a),
                    u = Math.sqrt(o * o + h * h),
                    c = (Math.abs(l) + Math.abs(u)) / 2,
                    d = this.fontSize / r,
                    f = t._view.resolution
                for (const m of this._activePagesMeshData)
                    m.mesh.shader.uniforms.uFWidth = c * e * d * f
            }
            super._render(t)
        }
        getLocalBounds() {
            return (this.validate(), super.getLocalBounds())
        }
        validate() {
            const t = di.available[this._fontName]
            if (!t) throw new Error(`Missing BitmapFont "${this._fontName}"`)
            ;(this._font !== t && (this.dirty = !0),
                this.dirty && this.updateText())
        }
        get tint() {
            return this._tintColor.value
        }
        set tint(t) {
            if (this.tint !== t) {
                this._tintColor.setValue(t)
                for (let e = 0; e < this._activePagesMeshData.length; e++)
                    this._activePagesMeshData[e].mesh.tint = t
            }
        }
        get align() {
            return this._align
        }
        set align(t) {
            this._align !== t && ((this._align = t), (this.dirty = !0))
        }
        get fontName() {
            return this._fontName
        }
        set fontName(t) {
            if (!di.available[t]) throw new Error(`Missing BitmapFont "${t}"`)
            this._fontName !== t && ((this._fontName = t), (this.dirty = !0))
        }
        get fontSize() {
            return this._fontSize ?? di.available[this._fontName].size
        }
        set fontSize(t) {
            this._fontSize !== t && ((this._fontSize = t), (this.dirty = !0))
        }
        get anchor() {
            return this._anchor
        }
        set anchor(t) {
            typeof t == 'number'
                ? this._anchor.set(t)
                : this._anchor.copyFrom(t)
        }
        get text() {
            return this._text
        }
        set text(t) {
            ;((t = String(t ?? '')),
                this._text !== t && ((this._text = t), (this.dirty = !0)))
        }
        get maxWidth() {
            return this._maxWidth
        }
        set maxWidth(t) {
            this._maxWidth !== t && ((this._maxWidth = t), (this.dirty = !0))
        }
        get maxLineHeight() {
            return (this.validate(), this._maxLineHeight)
        }
        get textWidth() {
            return (this.validate(), this._textWidth)
        }
        get letterSpacing() {
            return this._letterSpacing
        }
        set letterSpacing(t) {
            this._letterSpacing !== t &&
                ((this._letterSpacing = t), (this.dirty = !0))
        }
        get roundPixels() {
            return this._roundPixels
        }
        set roundPixels(t) {
            t !== this._roundPixels &&
                ((this._roundPixels = t), (this.dirty = !0))
        }
        get textHeight() {
            return (this.validate(), this._textHeight)
        }
        get resolution() {
            return this._resolution
        }
        set resolution(t) {
            ;((this._autoResolution = !1),
                this._resolution !== t &&
                    ((this._resolution = t), (this.dirty = !0)))
        }
        destroy(t) {
            const { _textureCache: e } = this,
                i =
                    di.available[this._fontName].distanceFieldType === 'none'
                        ? Kc
                        : Zc
            i.push(...this._activePagesMeshData)
            for (const r of this._activePagesMeshData) this.removeChild(r.mesh)
            ;((this._activePagesMeshData = []),
                i
                    .filter(r => e[r.mesh.texture.baseTexture.uid])
                    .forEach(r => {
                        r.mesh.texture = j.EMPTY
                    }))
            for (const r in e) (e[r].destroy(), delete e[r])
            ;((this._font = null),
                (this._tintColor = null),
                (this._textureCache = null),
                super.destroy(t))
        }
    }
Av.styleDefaults = {
    align: 'left',
    tint: 16777215,
    maxWidth: 0,
    letterSpacing: 0,
}
const Sv = ['.xml', '.fnt'],
    Cv = {
        extension: { type: $.LoadParser, priority: Pe.Normal },
        name: 'loadBitmapFont',
        test(s) {
            return Sv.includes(Gt.extname(s).toLowerCase())
        },
        async testParse(s) {
            return an.test(s) || bh.test(s)
        },
        async parse(s, t, e) {
            const i = an.test(s) ? an.parse(s) : bh.parse(s),
                { src: r } = t,
                { page: n } = i,
                a = []
            for (let l = 0; l < n.length; ++l) {
                const u = n[l].file
                let c = Gt.join(Gt.dirname(r), u)
                ;((c = dh(c, r)), a.push(c))
            }
            const o = await e.load(a),
                h = a.map(l => o[l])
            return di.install(i, h, !0)
        },
        async load(s, t) {
            return (await Y.ADAPTER.fetch(s)).text()
        },
        unload(s) {
            s.destroy()
        },
    }
Q.add(Cv)
const wh = class _r extends si {
    constructor() {
        ;(super(...arguments),
            (this._fonts = []),
            (this._overrides = []),
            (this._stylesheet = ''),
            (this.fontsDirty = !1))
    }
    static from(t) {
        return new _r(
            Object.keys(_r.defaultOptions).reduce(
                (e, i) => ({ ...e, [i]: t[i] }),
                {},
            ),
        )
    }
    cleanFonts() {
        this._fonts.length > 0 &&
            (this._fonts.forEach(t => {
                ;(URL.revokeObjectURL(t.src),
                    t.refs--,
                    t.refs === 0 &&
                        (t.fontFace && document.fonts.delete(t.fontFace),
                        delete _r.availableFonts[t.originalUrl]))
            }),
            (this.fontFamily = 'Arial'),
            (this._fonts.length = 0),
            this.styleID++,
            (this.fontsDirty = !0))
    }
    loadFont(t, e = {}) {
        const { availableFonts: i } = _r
        if (i[t]) {
            const r = i[t]
            return (
                this._fonts.push(r),
                r.refs++,
                this.styleID++,
                (this.fontsDirty = !0),
                Promise.resolve()
            )
        }
        return Y.ADAPTER.fetch(t)
            .then(r => r.blob())
            .then(
                async r =>
                    new Promise((n, a) => {
                        const o = URL.createObjectURL(r),
                            h = new FileReader()
                        ;((h.onload = () => n([o, h.result])),
                            (h.onerror = a),
                            h.readAsDataURL(r))
                    }),
            )
            .then(async ([r, n]) => {
                const a = Object.assign(
                    {
                        family: Gt.basename(t, Gt.extname(t)),
                        weight: 'normal',
                        style: 'normal',
                        display: 'auto',
                        src: r,
                        dataSrc: n,
                        refs: 1,
                        originalUrl: t,
                        fontFace: null,
                    },
                    e,
                )
                ;((i[t] = a), this._fonts.push(a), this.styleID++)
                const o = new FontFace(a.family, `url(${a.src})`, {
                    weight: a.weight,
                    style: a.style,
                    display: a.display,
                })
                ;((a.fontFace = o),
                    await o.load(),
                    document.fonts.add(o),
                    await document.fonts.ready,
                    this.styleID++,
                    (this.fontsDirty = !0))
            })
    }
    addOverride(...t) {
        const e = t.filter(i => !this._overrides.includes(i))
        e.length > 0 && (this._overrides.push(...e), this.styleID++)
    }
    removeOverride(...t) {
        const e = t.filter(i => this._overrides.includes(i))
        e.length > 0 &&
            ((this._overrides = this._overrides.filter(i => !e.includes(i))),
            this.styleID++)
    }
    toCSS(t) {
        return [
            `transform: scale(${t})`,
            'transform-origin: top left',
            'display: inline-block',
            `color: ${this.normalizeColor(this.fill)}`,
            `font-size: ${this.fontSize}px`,
            `font-family: ${this.fontFamily}`,
            `font-weight: ${this.fontWeight}`,
            `font-style: ${this.fontStyle}`,
            `font-variant: ${this.fontVariant}`,
            `letter-spacing: ${this.letterSpacing}px`,
            `text-align: ${this.align}`,
            `padding: ${this.padding}px`,
            `white-space: ${this.whiteSpace}`,
            ...(this.lineHeight ? [`line-height: ${this.lineHeight}px`] : []),
            ...(this.wordWrap
                ? [
                      `word-wrap: ${this.breakWords ? 'break-all' : 'break-word'}`,
                      `max-width: ${this.wordWrapWidth}px`,
                  ]
                : []),
            ...(this.strokeThickness
                ? [
                      `-webkit-text-stroke-width: ${this.strokeThickness}px`,
                      `-webkit-text-stroke-color: ${this.normalizeColor(this.stroke)}`,
                      `text-stroke-width: ${this.strokeThickness}px`,
                      `text-stroke-color: ${this.normalizeColor(this.stroke)}`,
                      'paint-order: stroke',
                  ]
                : []),
            ...(this.dropShadow ? [this.dropShadowToCSS()] : []),
            ...this._overrides,
        ].join(';')
    }
    toGlobalCSS() {
        return this._fonts.reduce(
            (t, e) => `${t}
            @font-face {
                font-family: "${e.family}";
                src: url('${e.dataSrc}');
                font-weight: ${e.weight};
                font-style: ${e.style};
                font-display: ${e.display};
            }`,
            this._stylesheet,
        )
    }
    get stylesheet() {
        return this._stylesheet
    }
    set stylesheet(t) {
        this._stylesheet !== t && ((this._stylesheet = t), this.styleID++)
    }
    normalizeColor(t) {
        return (
            Array.isArray(t) && (t = pg(t)),
            typeof t == 'number' ? fg(t) : t
        )
    }
    dropShadowToCSS() {
        let t = this.normalizeColor(this.dropShadowColor)
        const e = this.dropShadowAlpha,
            i = Math.round(
                Math.cos(this.dropShadowAngle) * this.dropShadowDistance,
            ),
            r = Math.round(
                Math.sin(this.dropShadowAngle) * this.dropShadowDistance,
            )
        t.startsWith('#') &&
            e < 1 &&
            (t += ((e * 255) | 0).toString(16).padStart(2, '0'))
        const n = `${i}px ${r}px`
        return this.dropShadowBlur > 0
            ? `text-shadow: ${n} ${this.dropShadowBlur}px ${t}`
            : `text-shadow: ${n} ${t}`
    }
    reset() {
        Object.assign(this, _r.defaultOptions)
    }
    onBeforeDraw() {
        const { fontsDirty: t } = this
        return (
            (this.fontsDirty = !1),
            this.isSafari && this._fonts.length > 0 && t
                ? new Promise(e => setTimeout(e, 100))
                : Promise.resolve()
        )
    }
    get isSafari() {
        const { userAgent: t } = Y.ADAPTER.getNavigator()
        return /^((?!chrome|android).)*safari/i.test(t)
    }
    set fillGradientStops(t) {
        console.warn(
            '[HTMLTextStyle] fillGradientStops is not supported by HTMLText',
        )
    }
    get fillGradientStops() {
        return super.fillGradientStops
    }
    set fillGradientType(t) {
        console.warn(
            '[HTMLTextStyle] fillGradientType is not supported by HTMLText',
        )
    }
    get fillGradientType() {
        return super.fillGradientType
    }
    set miterLimit(t) {
        console.warn('[HTMLTextStyle] miterLimit is not supported by HTMLText')
    }
    get miterLimit() {
        return super.miterLimit
    }
    set trim(t) {
        console.warn('[HTMLTextStyle] trim is not supported by HTMLText')
    }
    get trim() {
        return super.trim
    }
    set textBaseline(t) {
        console.warn(
            '[HTMLTextStyle] textBaseline is not supported by HTMLText',
        )
    }
    get textBaseline() {
        return super.textBaseline
    }
    set leading(t) {
        console.warn('[HTMLTextStyle] leading is not supported by HTMLText')
    }
    get leading() {
        return super.leading
    }
    set lineJoin(t) {
        console.warn('[HTMLTextStyle] lineJoin is not supported by HTMLText')
    }
    get lineJoin() {
        return super.lineJoin
    }
}
;((wh.availableFonts = {}),
    (wh.defaultOptions = {
        align: 'left',
        breakWords: !1,
        dropShadow: !1,
        dropShadowAlpha: 1,
        dropShadowAngle: Math.PI / 6,
        dropShadowBlur: 0,
        dropShadowColor: 'black',
        dropShadowDistance: 5,
        fill: 'black',
        fontFamily: 'Arial',
        fontSize: 26,
        fontStyle: 'normal',
        fontVariant: 'normal',
        fontWeight: 'normal',
        letterSpacing: 0,
        lineHeight: 0,
        padding: 0,
        stroke: 'black',
        strokeThickness: 0,
        whiteSpace: 'normal',
        wordWrap: !1,
        wordWrapWidth: 100,
    }))
let So = wh
const Ys = class yr extends Gr {
    constructor(t = '', e = {}) {
        ;(super(j.EMPTY),
            (this._text = null),
            (this._style = null),
            (this._autoResolution = !0),
            (this.localStyleID = -1),
            (this.dirty = !1),
            (this._updateID = 0),
            (this.ownsStyle = !1))
        const i = new Image(),
            r = j.from(i, {
                scaleMode: Y.SCALE_MODE,
                resourceOptions: { autoLoad: !1 },
            })
        ;((r.orig = new dt()), (r.trim = new dt()), (this.texture = r))
        const n = 'http://www.w3.org/2000/svg',
            a = 'http://www.w3.org/1999/xhtml',
            o = document.createElementNS(n, 'svg'),
            h = document.createElementNS(n, 'foreignObject'),
            l = document.createElementNS(a, 'div'),
            u = document.createElementNS(a, 'style')
        ;(h.setAttribute('width', '10000'),
            h.setAttribute('height', '10000'),
            (h.style.overflow = 'hidden'),
            o.appendChild(h),
            (this.maxWidth = yr.defaultMaxWidth),
            (this.maxHeight = yr.defaultMaxHeight),
            (this._domElement = l),
            (this._styleElement = u),
            (this._svgRoot = o),
            (this._foreignObject = h),
            this._foreignObject.appendChild(u),
            this._foreignObject.appendChild(l),
            (this._image = i),
            (this._loadImage = new Image()),
            (this._autoResolution = yr.defaultAutoResolution),
            (this._resolution = yr.defaultResolution ?? Y.RESOLUTION),
            (this.text = t),
            (this.style = e))
    }
    measureText(t) {
        const {
            text: e,
            style: i,
            resolution: r,
        } = Object.assign(
            {
                text: this._text,
                style: this._style,
                resolution: this._resolution,
            },
            t,
        )
        ;(Object.assign(this._domElement, { innerHTML: e, style: i.toCSS(r) }),
            (this._styleElement.textContent = i.toGlobalCSS()),
            document.body.appendChild(this._svgRoot))
        const n = this._domElement.getBoundingClientRect()
        this._svgRoot.remove()
        const { width: a, height: o } = n
        ;(a > this.maxWidth || o > this.maxHeight) &&
            console.warn(
                '[HTMLText] Large expanse of text, increase HTMLText.maxWidth or HTMLText.maxHeight property.',
            )
        const h = Math.min(this.maxWidth, Math.ceil(a)),
            l = Math.min(this.maxHeight, Math.ceil(o))
        return (
            this._svgRoot.setAttribute('width', h.toString()),
            this._svgRoot.setAttribute('height', l.toString()),
            e !== this._text && (this._domElement.innerHTML = this._text),
            i !== this._style &&
                (Object.assign(this._domElement, {
                    style: this._style?.toCSS(r),
                }),
                (this._styleElement.textContent = this._style?.toGlobalCSS())),
            { width: h + i.padding * 2, height: l + i.padding * 2 }
        )
    }
    async updateText(t = !0) {
        const { style: e, _image: i, _loadImage: r } = this
        if (
            (this.localStyleID !== e.styleID &&
                ((this.dirty = !0), (this.localStyleID = e.styleID)),
            !this.dirty && t)
        )
            return
        const { width: n, height: a } = this.measureText()
        ;((i.width = r.width = Math.ceil(Math.max(1, n))),
            (i.height = r.height = Math.ceil(Math.max(1, a))),
            this._updateID++)
        const o = this._updateID
        await new Promise(h => {
            r.onload = async () => {
                if (o < this._updateID) {
                    h()
                    return
                }
                ;(await e.onBeforeDraw(),
                    (i.src = r.src),
                    (r.onload = null),
                    (r.src = ''),
                    this.updateTexture(),
                    h())
            }
            const l = new XMLSerializer().serializeToString(this._svgRoot)
            r.src = `data:image/svg+xml;charset=utf8,${encodeURIComponent(l)}`
        })
    }
    get source() {
        return this._image
    }
    updateTexture() {
        const { style: t, texture: e, _image: i, resolution: r } = this,
            { padding: n } = t,
            { baseTexture: a } = e
        ;((e.trim.width = e._frame.width = i.width / r),
            (e.trim.height = e._frame.height = i.height / r),
            (e.trim.x = -n),
            (e.trim.y = -n),
            (e.orig.width = e._frame.width - n * 2),
            (e.orig.height = e._frame.height - n * 2),
            this._onTextureUpdate(),
            a.setRealSize(i.width, i.height, r),
            (this.dirty = !1))
    }
    _render(t) {
        ;(this._autoResolution &&
            this._resolution !== t.resolution &&
            ((this._resolution = t.resolution), (this.dirty = !0)),
            this.updateText(!0),
            super._render(t))
    }
    _renderCanvas(t) {
        ;(this._autoResolution &&
            this._resolution !== t.resolution &&
            ((this._resolution = t.resolution), (this.dirty = !0)),
            this.updateText(!0),
            super._renderCanvas(t))
    }
    getLocalBounds(t) {
        return (this.updateText(!0), super.getLocalBounds(t))
    }
    _calculateBounds() {
        ;(this.updateText(!0),
            this.calculateVertices(),
            this._bounds.addQuad(this.vertexData))
    }
    _onStyleChange() {
        this.dirty = !0
    }
    destroy(t) {
        ;(typeof t == 'boolean' && (t = { children: t }),
            (t = Object.assign({}, yr.defaultDestroyOptions, t)),
            super.destroy(t))
        const e = null
        ;(this.ownsStyle && this._style?.cleanFonts(),
            (this._style = e),
            this._svgRoot?.remove(),
            (this._svgRoot = e),
            this._domElement?.remove(),
            (this._domElement = e),
            this._foreignObject?.remove(),
            (this._foreignObject = e),
            this._styleElement?.remove(),
            (this._styleElement = e),
            (this._loadImage.src = ''),
            (this._loadImage.onload = null),
            (this._loadImage = e),
            (this._image.src = ''),
            (this._image = e))
    }
    get width() {
        return (
            this.updateText(!0),
            (Math.abs(this.scale.x) * this._image.width) / this.resolution
        )
    }
    set width(t) {
        this.updateText(!0)
        const e = mi(this.scale.x) || 1
        ;((this.scale.x = (e * t) / this._image.width / this.resolution),
            (this._width = t))
    }
    get height() {
        return (
            this.updateText(!0),
            (Math.abs(this.scale.y) * this._image.height) / this.resolution
        )
    }
    set height(t) {
        this.updateText(!0)
        const e = mi(this.scale.y) || 1
        ;((this.scale.y = (e * t) / this._image.height / this.resolution),
            (this._height = t))
    }
    get style() {
        return this._style
    }
    set style(t) {
        this._style !== t &&
            ((t = t || {}),
            t instanceof So
                ? ((this.ownsStyle = !1), (this._style = t))
                : t instanceof si
                  ? (console.warn(
                        '[HTMLText] Cloning TextStyle, if this is not what you want, use HTMLTextStyle',
                    ),
                    (this.ownsStyle = !0),
                    (this._style = So.from(t)))
                  : ((this.ownsStyle = !0), (this._style = new So(t))),
            (this.localStyleID = -1),
            (this.dirty = !0))
    }
    get text() {
        return this._text
    }
    set text(t) {
        ;((t = String(t === '' || t === null || t === void 0 ? ' ' : t)),
            (t = this.sanitiseText(t)),
            this._text !== t && ((this._text = t), (this.dirty = !0)))
    }
    get resolution() {
        return this._resolution
    }
    set resolution(t) {
        ;((this._autoResolution = !1),
            this._resolution !== t &&
                ((this._resolution = t), (this.dirty = !0)))
    }
    sanitiseText(t) {
        return t
            .replace(/<br>/gi, '<br/>')
            .replace(/<hr>/gi, '<hr/>')
            .replace(/&nbsp;/gi, '&#160;')
    }
}
;((Ys.defaultDestroyOptions = { texture: !0, children: !1, baseTexture: !0 }),
    (Ys.defaultMaxWidth = 2024),
    (Ys.defaultMaxHeight = 2024),
    (Ys.defaultAutoResolution = !0))
class Pv {
    constructor(t) {
        ;((this.fontsLoaded = !1),
            (this.preloaderFinished = !1),
            (this.endCallback = t))
    }
    cdnPath(t) {
        return './assets/' + t
    }
    async preload() {
        const t = []
        for (const e in sa)
            e != 'fonts' &&
                sa[e].forEach(i => {
                    const r = this.cdnPath(e + '/' + i)
                    t.push(xr.load(r))
                })
        ;(this.loadFonts(),
            await Promise.all(t),
            (this.preloaderFinished = !0),
            this.finish())
    }
    loadFonts() {
        console.log('LOAD FONTS')
        const t = [],
            e = document?.styleSheets[0]
        ;(sa.fonts?.forEach(i => {
            const r = i.split('.')[0],
                n = './fonts/' + i
            ;(console.log(n),
                e.insertRule(
                    `@font-face {font-family: "${r}"; src: url("${n}");}`,
                ),
                t.push(new hm(r).load()))
        }),
            Promise.all(t).then(
                () => {
                    ;((this.fontsLoaded = !0), this.finish())
                },
                i => {
                    console.error('Failed to load fonts!', i)
                },
            ))
    }
    finish() {
        this.fontsLoaded &&
            this.preloaderFinished &&
            (console.log('ASSETS PRELOADING FINISHED'),
            this.endCallback && this.endCallback())
    }
}
class ws extends Kt {
    constructor(t) {
        ;(super(), (this.gameController = t))
    }
}
var us = (s => (
    (s[(s.PORTRAIT = 0)] = 'PORTRAIT'),
    (s[(s.LANDSCAPE = 1)] = 'LANDSCAPE'),
    s
))(us || {})
class Rv {
    constructor(t) {
        ;((this.width = 0), (this.height = 0), (this.gameController = t))
    }
    fitLayout() {
        const t = window.innerWidth,
            e = window.innerHeight
        if (this.width === t && this.height === e) return
        ;((this.gameController.app.view.style.width = t + 'px'),
            (this.gameController.app.view.style.height = e + 'px'),
            (this.orientation = t > e ? 1 : 0))
        const i = this.gameController.size.w / this.gameController.size.h,
            r = t / e
        let n, a
        if (
            (i > r
                ? ((a = this.gameController.size.h), (n = Math.floor(a * r)))
                : ((n = this.gameController.size.w), (a = Math.floor(n * r))),
            this.orientation == 1)
        ) {
            const o = n
            ;((n = a), (a = o))
        }
        ;((this.width = n),
            (this.height = a),
            this.gameController.app.renderer.resize(n, a))
    }
}
class Le extends Gr {
    constructor(t) {
        if (typeof t == 'string')
            try {
                t = j.from(t)
            } catch {
                ;(console.log('no texture with name ' + t), (t = void 0))
            }
        ;(super(t), this.anchor.set(0.5))
    }
}
class Ks extends Le {
    constructor(t, e, i) {
        if ((super(t), i)) {
            const r = new si({
                    fontFamily: 'RobotoCondensed-VariableFont_wght.ttf',
                    fontSize: 50,
                    fill: 'white',
                    stroke: '#8c6600',
                    strokeThickness: 4,
                }),
                n = new Zh(i, r)
            ;(this.addChild(n), n.position.set(-n.width / 2, -n.height / 2))
        }
        ;((this.eventMode = 'static'), this.on('pointerdown', e))
    }
}
function Ye(s) {
    if (s === void 0)
        throw new ReferenceError(
            "this hasn't been initialised - super() hasn't been called",
        )
    return s
}
function qf(s, t) {
    ;((s.prototype = Object.create(t.prototype)),
        (s.prototype.constructor = s),
        (s.__proto__ = t))
}
/*!
 * GSAP 3.13.0
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
 */ var he = {
        autoSleep: 120,
        force3D: 'auto',
        nullTargetWarn: 1,
        units: { lineHeight: '' },
    },
    Br = { duration: 0.5, overwrite: !1, delay: 0 },
    Qh,
    Xt,
    At,
    me = 1e8,
    vt = 1 / me,
    Th = Math.PI * 2,
    Iv = Th / 4,
    Mv = 0,
    Yf = Math.sqrt,
    Dv = Math.cos,
    Bv = Math.sin,
    Ht = function (t) {
        return typeof t == 'string'
    },
    It = function (t) {
        return typeof t == 'function'
    },
    ni = function (t) {
        return typeof t == 'number'
    },
    Jh = function (t) {
        return typeof t > 'u'
    },
    We = function (t) {
        return typeof t == 'object'
    },
    Qt = function (t) {
        return t !== !1
    },
    tl = function () {
        return typeof window < 'u'
    },
    Zs = function (t) {
        return It(t) || Ht(t)
    },
    Kf =
        (typeof ArrayBuffer == 'function' && ArrayBuffer.isView) ||
        function () {},
    $t = Array.isArray,
    Eh = /(?:-?\.?\d|\.)+/gi,
    Zf = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
    br = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
    Co = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
    Qf = /[+-]=-?[.\d]+/,
    Jf = /[^,'"\[\]\s]+/gi,
    Ov = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
    Ct,
    Oe,
    Ah,
    el,
    le = {},
    Sn = {},
    tp,
    ep = function (t) {
        return (Sn = Or(t, le)) && ie
    },
    il = function (t, e) {
        return console.warn(
            'Invalid property',
            t,
            'set to',
            e,
            'Missing plugin? gsap.registerPlugin()',
        )
    },
    cs = function (t, e) {
        return !e && console.warn(t)
    },
    ip = function (t, e) {
        return (t && (le[t] = e) && Sn && (Sn[t] = e)) || le
    },
    ds = function () {
        return 0
    },
    Fv = { suppressEvents: !0, isStart: !0, kill: !1 },
    hn = { suppressEvents: !0, kill: !1 },
    Lv = { suppressEvents: !0 },
    rl = {},
    bi = [],
    Sh = {},
    rp,
    ne = {},
    Po = {},
    Jc = 30,
    ln = [],
    sl = '',
    nl = function (t) {
        var e = t[0],
            i,
            r
        if ((We(e) || It(e) || (t = [t]), !(i = (e._gsap || {}).harness))) {
            for (r = ln.length; r-- && !ln[r].targetTest(e); );
            i = ln[r]
        }
        for (r = t.length; r--; )
            (t[r] && (t[r]._gsap || (t[r]._gsap = new Cp(t[r], i)))) ||
                t.splice(r, 1)
        return t
    },
    ji = function (t) {
        return t._gsap || nl(ge(t))[0]._gsap
    },
    sp = function (t, e, i) {
        return (i = t[e]) && It(i)
            ? t[e]()
            : (Jh(i) && t.getAttribute && t.getAttribute(e)) || i
    },
    Jt = function (t, e) {
        return (t = t.split(',')).forEach(e) || t
    },
    Dt = function (t) {
        return Math.round(t * 1e5) / 1e5 || 0
    },
    Lt = function (t) {
        return Math.round(t * 1e7) / 1e7 || 0
    },
    Rr = function (t, e) {
        var i = e.charAt(0),
            r = parseFloat(e.substr(2))
        return (
            (t = parseFloat(t)),
            i === '+' ? t + r : i === '-' ? t - r : i === '*' ? t * r : t / r
        )
    },
    kv = function (t, e) {
        for (var i = e.length, r = 0; t.indexOf(e[r]) < 0 && ++r < i; );
        return r < i
    },
    Cn = function () {
        var t = bi.length,
            e = bi.slice(0),
            i,
            r
        for (Sh = {}, bi.length = 0, i = 0; i < t; i++)
            ((r = e[i]),
                r &&
                    r._lazy &&
                    (r.render(r._lazy[0], r._lazy[1], !0)._lazy = 0))
    },
    al = function (t) {
        return !!(t._initted || t._startAt || t.add)
    },
    np = function (t, e, i, r) {
        ;(bi.length && !Xt && Cn(),
            t.render(e, i, !!(Xt && e < 0 && al(t))),
            bi.length && !Xt && Cn())
    },
    ap = function (t) {
        var e = parseFloat(t)
        return (e || e === 0) && (t + '').match(Jf).length < 2
            ? e
            : Ht(t)
              ? t.trim()
              : t
    },
    op = function (t) {
        return t
    },
    ue = function (t, e) {
        for (var i in e) i in t || (t[i] = e[i])
        return t
    },
    Nv = function (t) {
        return function (e, i) {
            for (var r in i)
                r in e ||
                    (r === 'duration' && t) ||
                    r === 'ease' ||
                    (e[r] = i[r])
        }
    },
    Or = function (t, e) {
        for (var i in e) t[i] = e[i]
        return t
    },
    td = function s(t, e) {
        for (var i in e)
            i !== '__proto__' &&
                i !== 'constructor' &&
                i !== 'prototype' &&
                (t[i] = We(e[i]) ? s(t[i] || (t[i] = {}), e[i]) : e[i])
        return t
    },
    Pn = function (t, e) {
        var i = {},
            r
        for (r in t) r in e || (i[r] = t[r])
        return i
    },
    as = function (t) {
        var e = t.parent || Ct,
            i = t.keyframes ? Nv($t(t.keyframes)) : ue
        if (Qt(t.inherit))
            for (; e; ) (i(t, e.vars.defaults), (e = e.parent || e._dp))
        return t
    },
    Uv = function (t, e) {
        for (var i = t.length, r = i === e.length; r && i-- && t[i] === e[i]; );
        return i < 0
    },
    hp = function (t, e, i, r, n) {
        var a = t[r],
            o
        if (n) for (o = e[n]; a && a[n] > o; ) a = a._prev
        return (
            a
                ? ((e._next = a._next), (a._next = e))
                : ((e._next = t[i]), (t[i] = e)),
            e._next ? (e._next._prev = e) : (t[r] = e),
            (e._prev = a),
            (e.parent = e._dp = t),
            e
        )
    },
    Vn = function (t, e, i, r) {
        ;(i === void 0 && (i = '_first'), r === void 0 && (r = '_last'))
        var n = e._prev,
            a = e._next
        ;(n ? (n._next = a) : t[i] === e && (t[i] = a),
            a ? (a._prev = n) : t[r] === e && (t[r] = n),
            (e._next = e._prev = e.parent = null))
    },
    Ei = function (t, e) {
        ;(t.parent &&
            (!e || t.parent.autoRemoveChildren) &&
            t.parent.remove &&
            t.parent.remove(t),
            (t._act = 0))
    },
    qi = function (t, e) {
        if (t && (!e || e._end > t._dur || e._start < 0))
            for (var i = t; i; ) ((i._dirty = 1), (i = i.parent))
        return t
    },
    Gv = function (t) {
        for (var e = t.parent; e && e.parent; )
            ((e._dirty = 1), e.totalDuration(), (e = e.parent))
        return t
    },
    Ch = function (t, e, i, r) {
        return (
            t._startAt &&
            (Xt
                ? t._startAt.revert(hn)
                : (t.vars.immediateRender && !t.vars.autoRevert) ||
                  t._startAt.render(e, !0, r))
        )
    },
    Hv = function s(t) {
        return !t || (t._ts && s(t.parent))
    },
    ed = function (t) {
        return t._repeat ? Fr(t._tTime, (t = t.duration() + t._rDelay)) * t : 0
    },
    Fr = function (t, e) {
        var i = Math.floor((t = Lt(t / e)))
        return t && i === t ? i - 1 : i
    },
    Rn = function (t, e) {
        return (
            (t - e._start) * e._ts +
            (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur)
        )
    },
    Xn = function (t) {
        return (t._end = Lt(
            t._start + (t._tDur / Math.abs(t._ts || t._rts || vt) || 0),
        ))
    },
    Wn = function (t, e) {
        var i = t._dp
        return (
            i &&
                i.smoothChildTiming &&
                t._ts &&
                ((t._start = Lt(
                    i._time -
                        (t._ts > 0
                            ? e / t._ts
                            : ((t._dirty ? t.totalDuration() : t._tDur) - e) /
                              -t._ts),
                )),
                Xn(t),
                i._dirty || qi(i, t)),
            t
        )
    },
    lp = function (t, e) {
        var i
        if (
            ((e._time ||
                (!e._dur && e._initted) ||
                (e._start < t._time && (e._dur || !e.add))) &&
                ((i = Rn(t.rawTime(), e)),
                (!e._dur || Ts(0, e.totalDuration(), i) - e._tTime > vt) &&
                    e.render(i, !0)),
            qi(t, e)._dp && t._initted && t._time >= t._dur && t._ts)
        ) {
            if (t._dur < t.duration())
                for (i = t; i._dp; )
                    (i.rawTime() >= 0 && i.totalTime(i._tTime), (i = i._dp))
            t._zTime = -vt
        }
    },
    ke = function (t, e, i, r) {
        return (
            e.parent && Ei(e),
            (e._start = Lt(
                (ni(i) ? i : i || t !== Ct ? ce(t, i, e) : t._time) + e._delay,
            )),
            (e._end = Lt(
                e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0),
            )),
            hp(t, e, '_first', '_last', t._sort ? '_start' : 0),
            Ph(e) || (t._recent = e),
            r || lp(t, e),
            t._ts < 0 && Wn(t, t._tTime),
            t
        )
    },
    up = function (t, e) {
        return (
            (le.ScrollTrigger || il('scrollTrigger', e)) &&
            le.ScrollTrigger.create(e, t)
        )
    },
    cp = function (t, e, i, r, n) {
        if ((hl(t, e, n), !t._initted)) return 1
        if (
            !i &&
            t._pt &&
            !Xt &&
            ((t._dur && t.vars.lazy !== !1) || (!t._dur && t.vars.lazy)) &&
            rp !== ae.frame
        )
            return (bi.push(t), (t._lazy = [n, r]), 1)
    },
    zv = function s(t) {
        var e = t.parent
        return e && e._ts && e._initted && !e._lock && (e.rawTime() < 0 || s(e))
    },
    Ph = function (t) {
        var e = t.data
        return e === 'isFromStart' || e === 'isStart'
    },
    Vv = function (t, e, i, r) {
        var n = t.ratio,
            a =
                e < 0 ||
                (!e &&
                    ((!t._start && zv(t) && !(!t._initted && Ph(t))) ||
                        ((t._ts < 0 || t._dp._ts < 0) && !Ph(t))))
                    ? 0
                    : 1,
            o = t._rDelay,
            h = 0,
            l,
            u,
            c
        if (
            (o &&
                t._repeat &&
                ((h = Ts(0, t._tDur, e)),
                (u = Fr(h, o)),
                t._yoyo && u & 1 && (a = 1 - a),
                u !== Fr(t._tTime, o) &&
                    ((n = 1 - a),
                    t.vars.repeatRefresh && t._initted && t.invalidate())),
            a !== n || Xt || r || t._zTime === vt || (!e && t._zTime))
        ) {
            if (!t._initted && cp(t, e, r, i, h)) return
            for (
                c = t._zTime,
                    t._zTime = e || (i ? vt : 0),
                    i || (i = e && !c),
                    t.ratio = a,
                    t._from && (a = 1 - a),
                    t._time = 0,
                    t._tTime = h,
                    l = t._pt;
                l;

            )
                (l.r(a, l.d), (l = l._next))
            ;(e < 0 && Ch(t, e, i, !0),
                t._onUpdate && !i && oe(t, 'onUpdate'),
                h && t._repeat && !i && t.parent && oe(t, 'onRepeat'),
                (e >= t._tDur || e < 0) &&
                    t.ratio === a &&
                    (a && Ei(t, 1),
                    !i &&
                        !Xt &&
                        (oe(t, a ? 'onComplete' : 'onReverseComplete', !0),
                        t._prom && t._prom())))
        } else t._zTime || (t._zTime = e)
    },
    Xv = function (t, e, i) {
        var r
        if (i > e)
            for (r = t._first; r && r._start <= i; ) {
                if (r.data === 'isPause' && r._start > e) return r
                r = r._next
            }
        else
            for (r = t._last; r && r._start >= i; ) {
                if (r.data === 'isPause' && r._start < e) return r
                r = r._prev
            }
    },
    Lr = function (t, e, i, r) {
        var n = t._repeat,
            a = Lt(e) || 0,
            o = t._tTime / t._tDur
        return (
            o && !r && (t._time *= a / t._dur),
            (t._dur = a),
            (t._tDur = n
                ? n < 0
                    ? 1e10
                    : Lt(a * (n + 1) + t._rDelay * n)
                : a),
            o > 0 && !r && Wn(t, (t._tTime = t._tDur * o)),
            t.parent && Xn(t),
            i || qi(t.parent, t),
            t
        )
    },
    id = function (t) {
        return t instanceof jt ? qi(t) : Lr(t, t._dur)
    },
    Wv = { _start: 0, endTime: ds, totalDuration: ds },
    ce = function s(t, e, i) {
        var r = t.labels,
            n = t._recent || Wv,
            a = t.duration() >= me ? n.endTime(!1) : t._dur,
            o,
            h,
            l
        return Ht(e) && (isNaN(e) || e in r)
            ? ((h = e.charAt(0)),
              (l = e.substr(-1) === '%'),
              (o = e.indexOf('=')),
              h === '<' || h === '>'
                  ? (o >= 0 && (e = e.replace(/=/, '')),
                    (h === '<' ? n._start : n.endTime(n._repeat >= 0)) +
                        (parseFloat(e.substr(1)) || 0) *
                            (l ? (o < 0 ? n : i).totalDuration() / 100 : 1))
                  : o < 0
                    ? (e in r || (r[e] = a), r[e])
                    : ((h = parseFloat(e.charAt(o - 1) + e.substr(o + 1))),
                      l &&
                          i &&
                          (h = (h / 100) * ($t(i) ? i[0] : i).totalDuration()),
                      o > 1 ? s(t, e.substr(0, o - 1), i) + h : a + h))
            : e == null
              ? a
              : +e
    },
    os = function (t, e, i) {
        var r = ni(e[1]),
            n = (r ? 2 : 1) + (t < 2 ? 0 : 1),
            a = e[n],
            o,
            h
        if ((r && (a.duration = e[1]), (a.parent = i), t)) {
            for (o = a, h = i; h && !('immediateRender' in o); )
                ((o = h.vars.defaults || {}),
                    (h = Qt(h.vars.inherit) && h.parent))
            ;((a.immediateRender = Qt(o.immediateRender)),
                t < 2 ? (a.runBackwards = 1) : (a.startAt = e[n - 1]))
        }
        return new Ot(e[0], a, e[n + 1])
    },
    Ci = function (t, e) {
        return t || t === 0 ? e(t) : e
    },
    Ts = function (t, e, i) {
        return i < t ? t : i > e ? e : i
    },
    Wt = function (t, e) {
        return !Ht(t) || !(e = Ov.exec(t)) ? '' : e[1]
    },
    $v = function (t, e, i) {
        return Ci(i, function (r) {
            return Ts(t, e, r)
        })
    },
    Rh = [].slice,
    dp = function (t, e) {
        return (
            t &&
            We(t) &&
            'length' in t &&
            ((!e && !t.length) || (t.length - 1 in t && We(t[0]))) &&
            !t.nodeType &&
            t !== Oe
        )
    },
    jv = function (t, e, i) {
        return (
            i === void 0 && (i = []),
            t.forEach(function (r) {
                var n
                return (Ht(r) && !e) || dp(r, 1)
                    ? (n = i).push.apply(n, ge(r))
                    : i.push(r)
            }) || i
        )
    },
    ge = function (t, e, i) {
        return At && !e && At.selector
            ? At.selector(t)
            : Ht(t) && !i && (Ah || !kr())
              ? Rh.call((e || el).querySelectorAll(t), 0)
              : $t(t)
                ? jv(t, i)
                : dp(t)
                  ? Rh.call(t, 0)
                  : t
                    ? [t]
                    : []
    },
    Ih = function (t) {
        return (
            (t = ge(t)[0] || cs('Invalid scope') || {}),
            function (e) {
                var i = t.current || t.nativeElement || t
                return ge(
                    e,
                    i.querySelectorAll
                        ? i
                        : i === t
                          ? cs('Invalid scope') || el.createElement('div')
                          : t,
                )
            }
        )
    },
    fp = function (t) {
        return t.sort(function () {
            return 0.5 - Math.random()
        })
    },
    pp = function (t) {
        if (It(t)) return t
        var e = We(t) ? t : { each: t },
            i = Yi(e.ease),
            r = e.from || 0,
            n = parseFloat(e.base) || 0,
            a = {},
            o = r > 0 && r < 1,
            h = isNaN(r) || o,
            l = e.axis,
            u = r,
            c = r
        return (
            Ht(r)
                ? (u = c = { center: 0.5, edges: 0.5, end: 1 }[r] || 0)
                : !o && h && ((u = r[0]), (c = r[1])),
            function (d, f, m) {
                var p = (m || e).length,
                    g = a[p],
                    _,
                    b,
                    v,
                    w,
                    x,
                    P,
                    y,
                    S,
                    R
                if (!g) {
                    if (
                        ((R = e.grid === 'auto' ? 0 : (e.grid || [1, me])[1]),
                        !R)
                    ) {
                        for (
                            y = -me;
                            y < (y = m[R++].getBoundingClientRect().left) &&
                            R < p;

                        );
                        R < p && R--
                    }
                    for (
                        g = a[p] = [],
                            _ = h ? Math.min(R, p) * u - 0.5 : r % R,
                            b =
                                R === me
                                    ? 0
                                    : h
                                      ? (p * c) / R - 0.5
                                      : (r / R) | 0,
                            y = 0,
                            S = me,
                            P = 0;
                        P < p;
                        P++
                    )
                        ((v = (P % R) - _),
                            (w = b - ((P / R) | 0)),
                            (g[P] = x =
                                l
                                    ? Math.abs(l === 'y' ? w : v)
                                    : Yf(v * v + w * w)),
                            x > y && (y = x),
                            x < S && (S = x))
                    ;(r === 'random' && fp(g),
                        (g.max = y - S),
                        (g.min = S),
                        (g.v = p =
                            (parseFloat(e.amount) ||
                                parseFloat(e.each) *
                                    (R > p
                                        ? p - 1
                                        : l
                                          ? l === 'y'
                                              ? p / R
                                              : R
                                          : Math.max(R, p / R)) ||
                                0) * (r === 'edges' ? -1 : 1)),
                        (g.b = p < 0 ? n - p : n),
                        (g.u = Wt(e.amount || e.each) || 0),
                        (i = i && p < 0 ? Ep(i) : i))
                }
                return (
                    (p = (g[d] - g.min) / g.max || 0),
                    Lt(g.b + (i ? i(p) : p) * g.v) + g.u
                )
            }
        )
    },
    Mh = function (t) {
        var e = Math.pow(10, ((t + '').split('.')[1] || '').length)
        return function (i) {
            var r = Lt(Math.round(parseFloat(i) / t) * t * e)
            return (r - (r % 1)) / e + (ni(i) ? 0 : Wt(i))
        }
    },
    mp = function (t, e) {
        var i = $t(t),
            r,
            n
        return (
            !i &&
                We(t) &&
                ((r = i = t.radius || me),
                t.values
                    ? ((t = ge(t.values)), (n = !ni(t[0])) && (r *= r))
                    : (t = Mh(t.increment))),
            Ci(
                e,
                i
                    ? It(t)
                        ? function (a) {
                              return ((n = t(a)), Math.abs(n - a) <= r ? n : a)
                          }
                        : function (a) {
                              for (
                                  var o = parseFloat(n ? a.x : a),
                                      h = parseFloat(n ? a.y : 0),
                                      l = me,
                                      u = 0,
                                      c = t.length,
                                      d,
                                      f;
                                  c--;

                              )
                                  (n
                                      ? ((d = t[c].x - o),
                                        (f = t[c].y - h),
                                        (d = d * d + f * f))
                                      : (d = Math.abs(t[c] - o)),
                                      d < l && ((l = d), (u = c)))
                              return (
                                  (u = !r || l <= r ? t[u] : a),
                                  n || u === a || ni(a) ? u : u + Wt(a)
                              )
                          }
                    : Mh(t),
            )
        )
    },
    gp = function (t, e, i, r) {
        return Ci($t(t) ? !e : i === !0 ? !!(i = 0) : !r, function () {
            return $t(t)
                ? t[~~(Math.random() * t.length)]
                : (i = i || 1e-5) &&
                      (r = i < 1 ? Math.pow(10, (i + '').length - 2) : 1) &&
                      Math.floor(
                          Math.round(
                              (t - i / 2 + Math.random() * (e - t + i * 0.99)) /
                                  i,
                          ) *
                              i *
                              r,
                      ) / r
        })
    },
    qv = function () {
        for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++)
            e[i] = arguments[i]
        return function (r) {
            return e.reduce(function (n, a) {
                return a(n)
            }, r)
        }
    },
    Yv = function (t, e) {
        return function (i) {
            return t(parseFloat(i)) + (e || Wt(i))
        }
    },
    Kv = function (t, e, i) {
        return yp(t, e, 0, 1, i)
    },
    _p = function (t, e, i) {
        return Ci(i, function (r) {
            return t[~~e(r)]
        })
    },
    Zv = function s(t, e, i) {
        var r = e - t
        return $t(t)
            ? _p(t, s(0, t.length), e)
            : Ci(i, function (n) {
                  return ((r + ((n - t) % r)) % r) + t
              })
    },
    Qv = function s(t, e, i) {
        var r = e - t,
            n = r * 2
        return $t(t)
            ? _p(t, s(0, t.length - 1), e)
            : Ci(i, function (a) {
                  return (
                      (a = (n + ((a - t) % n)) % n || 0),
                      t + (a > r ? n - a : a)
                  )
              })
    },
    fs = function (t) {
        for (var e = 0, i = '', r, n, a, o; ~(r = t.indexOf('random(', e)); )
            ((a = t.indexOf(')', r)),
                (o = t.charAt(r + 7) === '['),
                (n = t.substr(r + 7, a - r - 7).match(o ? Jf : Eh)),
                (i +=
                    t.substr(e, r - e) +
                    gp(o ? n : +n[0], o ? 0 : +n[1], +n[2] || 1e-5)),
                (e = a + 1))
        return i + t.substr(e, t.length - e)
    },
    yp = function (t, e, i, r, n) {
        var a = e - t,
            o = r - i
        return Ci(n, function (h) {
            return i + (((h - t) / a) * o || 0)
        })
    },
    Jv = function s(t, e, i, r) {
        var n = isNaN(t + e)
            ? 0
            : function (f) {
                  return (1 - f) * t + f * e
              }
        if (!n) {
            var a = Ht(t),
                o = {},
                h,
                l,
                u,
                c,
                d
            if ((i === !0 && (r = 1) && (i = null), a))
                ((t = { p: t }), (e = { p: e }))
            else if ($t(t) && !$t(e)) {
                for (u = [], c = t.length, d = c - 2, l = 1; l < c; l++)
                    u.push(s(t[l - 1], t[l]))
                ;(c--,
                    (n = function (m) {
                        m *= c
                        var p = Math.min(d, ~~m)
                        return u[p](m - p)
                    }),
                    (i = e))
            } else r || (t = Or($t(t) ? [] : {}, t))
            if (!u) {
                for (h in e) ol.call(o, t, h, 'get', e[h])
                n = function (m) {
                    return cl(m, o) || (a ? t.p : t)
                }
            }
        }
        return Ci(i, n)
    },
    rd = function (t, e, i) {
        var r = t.labels,
            n = me,
            a,
            o,
            h
        for (a in r)
            ((o = r[a] - e),
                o < 0 == !!i &&
                    o &&
                    n > (o = Math.abs(o)) &&
                    ((h = a), (n = o)))
        return h
    },
    oe = function (t, e, i) {
        var r = t.vars,
            n = r[e],
            a = At,
            o = t._ctx,
            h,
            l,
            u
        if (n)
            return (
                (h = r[e + 'Params']),
                (l = r.callbackScope || t),
                i && bi.length && Cn(),
                o && (At = o),
                (u = h ? n.apply(l, h) : n.call(l)),
                (At = a),
                u
            )
    },
    rs = function (t) {
        return (
            Ei(t),
            t.scrollTrigger && t.scrollTrigger.kill(!!Xt),
            t.progress() < 1 && oe(t, 'onInterrupt'),
            t
        )
    },
    wr,
    vp = [],
    xp = function (t) {
        if (t)
            if (((t = (!t.name && t.default) || t), tl() || t.headless)) {
                var e = t.name,
                    i = It(t),
                    r =
                        e && !i && t.init
                            ? function () {
                                  this._props = []
                              }
                            : t,
                    n = {
                        init: ds,
                        render: cl,
                        add: ol,
                        kill: mx,
                        modifier: px,
                        rawVars: 0,
                    },
                    a = {
                        targetTest: 0,
                        get: 0,
                        getSetter: ul,
                        aliases: {},
                        register: 0,
                    }
                if ((kr(), t !== r)) {
                    if (ne[e]) return
                    ;(ue(r, ue(Pn(t, n), a)),
                        Or(r.prototype, Or(n, Pn(t, a))),
                        (ne[(r.prop = e)] = r),
                        t.targetTest && (ln.push(r), (rl[e] = 1)),
                        (e =
                            (e === 'css'
                                ? 'CSS'
                                : e.charAt(0).toUpperCase() + e.substr(1)) +
                            'Plugin'))
                }
                ;(ip(e, r), t.register && t.register(ie, r, te))
            } else vp.push(t)
    },
    yt = 255,
    ss = {
        aqua: [0, yt, yt],
        lime: [0, yt, 0],
        silver: [192, 192, 192],
        black: [0, 0, 0],
        maroon: [128, 0, 0],
        teal: [0, 128, 128],
        blue: [0, 0, yt],
        navy: [0, 0, 128],
        white: [yt, yt, yt],
        olive: [128, 128, 0],
        yellow: [yt, yt, 0],
        orange: [yt, 165, 0],
        gray: [128, 128, 128],
        purple: [128, 0, 128],
        green: [0, 128, 0],
        red: [yt, 0, 0],
        pink: [yt, 192, 203],
        cyan: [0, yt, yt],
        transparent: [yt, yt, yt, 0],
    },
    Ro = function (t, e, i) {
        return (
            (t += t < 0 ? 1 : t > 1 ? -1 : 0),
            ((t * 6 < 1
                ? e + (i - e) * t * 6
                : t < 0.5
                  ? i
                  : t * 3 < 2
                    ? e + (i - e) * (2 / 3 - t) * 6
                    : e) *
                yt +
                0.5) |
                0
        )
    },
    bp = function (t, e, i) {
        var r = t ? (ni(t) ? [t >> 16, (t >> 8) & yt, t & yt] : 0) : ss.black,
            n,
            a,
            o,
            h,
            l,
            u,
            c,
            d,
            f,
            m
        if (!r) {
            if (
                (t.substr(-1) === ',' && (t = t.substr(0, t.length - 1)), ss[t])
            )
                r = ss[t]
            else if (t.charAt(0) === '#') {
                if (
                    (t.length < 6 &&
                        ((n = t.charAt(1)),
                        (a = t.charAt(2)),
                        (o = t.charAt(3)),
                        (t =
                            '#' +
                            n +
                            n +
                            a +
                            a +
                            o +
                            o +
                            (t.length === 5 ? t.charAt(4) + t.charAt(4) : ''))),
                    t.length === 9)
                )
                    return (
                        (r = parseInt(t.substr(1, 6), 16)),
                        [
                            r >> 16,
                            (r >> 8) & yt,
                            r & yt,
                            parseInt(t.substr(7), 16) / 255,
                        ]
                    )
                ;((t = parseInt(t.substr(1), 16)),
                    (r = [t >> 16, (t >> 8) & yt, t & yt]))
            } else if (t.substr(0, 3) === 'hsl') {
                if (((r = m = t.match(Eh)), !e))
                    ((h = (+r[0] % 360) / 360),
                        (l = +r[1] / 100),
                        (u = +r[2] / 100),
                        (a = u <= 0.5 ? u * (l + 1) : u + l - u * l),
                        (n = u * 2 - a),
                        r.length > 3 && (r[3] *= 1),
                        (r[0] = Ro(h + 1 / 3, n, a)),
                        (r[1] = Ro(h, n, a)),
                        (r[2] = Ro(h - 1 / 3, n, a)))
                else if (~t.indexOf('='))
                    return (
                        (r = t.match(Zf)),
                        i && r.length < 4 && (r[3] = 1),
                        r
                    )
            } else r = t.match(Eh) || ss.transparent
            r = r.map(Number)
        }
        return (
            e &&
                !m &&
                ((n = r[0] / yt),
                (a = r[1] / yt),
                (o = r[2] / yt),
                (c = Math.max(n, a, o)),
                (d = Math.min(n, a, o)),
                (u = (c + d) / 2),
                c === d
                    ? (h = l = 0)
                    : ((f = c - d),
                      (l = u > 0.5 ? f / (2 - c - d) : f / (c + d)),
                      (h =
                          c === n
                              ? (a - o) / f + (a < o ? 6 : 0)
                              : c === a
                                ? (o - n) / f + 2
                                : (n - a) / f + 4),
                      (h *= 60)),
                (r[0] = ~~(h + 0.5)),
                (r[1] = ~~(l * 100 + 0.5)),
                (r[2] = ~~(u * 100 + 0.5))),
            i && r.length < 4 && (r[3] = 1),
            r
        )
    },
    wp = function (t) {
        var e = [],
            i = [],
            r = -1
        return (
            t.split(wi).forEach(function (n) {
                var a = n.match(br) || []
                ;(e.push.apply(e, a), i.push((r += a.length + 1)))
            }),
            (e.c = i),
            e
        )
    },
    sd = function (t, e, i) {
        var r = '',
            n = (t + r).match(wi),
            a = e ? 'hsla(' : 'rgba(',
            o = 0,
            h,
            l,
            u,
            c
        if (!n) return t
        if (
            ((n = n.map(function (d) {
                return (
                    (d = bp(d, e, 1)) &&
                    a +
                        (e
                            ? d[0] + ',' + d[1] + '%,' + d[2] + '%,' + d[3]
                            : d.join(',')) +
                        ')'
                )
            })),
            i && ((u = wp(t)), (h = i.c), h.join(r) !== u.c.join(r)))
        )
            for (l = t.replace(wi, '1').split(br), c = l.length - 1; o < c; o++)
                r +=
                    l[o] +
                    (~h.indexOf(o)
                        ? n.shift() || a + '0,0,0,0)'
                        : (u.length ? u : n.length ? n : i).shift())
        if (!l)
            for (l = t.split(wi), c = l.length - 1; o < c; o++) r += l[o] + n[o]
        return r + l[c]
    },
    wi = (function () {
        var s =
                '(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b',
            t
        for (t in ss) s += '|' + t + '\\b'
        return new RegExp(s + ')', 'gi')
    })(),
    tx = /hsl[a]?\(/,
    Tp = function (t) {
        var e = t.join(' '),
            i
        if (((wi.lastIndex = 0), wi.test(e)))
            return (
                (i = tx.test(e)),
                (t[1] = sd(t[1], i)),
                (t[0] = sd(t[0], i, wp(t[1]))),
                !0
            )
    },
    ps,
    ae = (function () {
        var s = Date.now,
            t = 500,
            e = 33,
            i = s(),
            r = i,
            n = 1e3 / 240,
            a = n,
            o = [],
            h,
            l,
            u,
            c,
            d,
            f,
            m = function p(g) {
                var _ = s() - r,
                    b = g === !0,
                    v,
                    w,
                    x,
                    P
                if (
                    ((_ > t || _ < 0) && (i += _ - e),
                    (r += _),
                    (x = r - i),
                    (v = x - a),
                    (v > 0 || b) &&
                        ((P = ++c.frame),
                        (d = x - c.time * 1e3),
                        (c.time = x = x / 1e3),
                        (a += v + (v >= n ? 4 : n - v)),
                        (w = 1)),
                    b || (h = l(p)),
                    w)
                )
                    for (f = 0; f < o.length; f++) o[f](x, d, P, g)
            }
        return (
            (c = {
                time: 0,
                frame: 0,
                tick: function () {
                    m(!0)
                },
                deltaRatio: function (g) {
                    return d / (1e3 / (g || 60))
                },
                wake: function () {
                    tp &&
                        (!Ah &&
                            tl() &&
                            ((Oe = Ah = window),
                            (el = Oe.document || {}),
                            (le.gsap = ie),
                            (Oe.gsapVersions || (Oe.gsapVersions = [])).push(
                                ie.version,
                            ),
                            ep(
                                Sn ||
                                    Oe.GreenSockGlobals ||
                                    (!Oe.gsap && Oe) ||
                                    {},
                            ),
                            vp.forEach(xp)),
                        (u =
                            typeof requestAnimationFrame < 'u' &&
                            requestAnimationFrame),
                        h && c.sleep(),
                        (l =
                            u ||
                            function (g) {
                                return setTimeout(g, (a - c.time * 1e3 + 1) | 0)
                            }),
                        (ps = 1),
                        m(2))
                },
                sleep: function () {
                    ;((u ? cancelAnimationFrame : clearTimeout)(h),
                        (ps = 0),
                        (l = ds))
                },
                lagSmoothing: function (g, _) {
                    ;((t = g || 1 / 0), (e = Math.min(_ || 33, t)))
                },
                fps: function (g) {
                    ;((n = 1e3 / (g || 240)), (a = c.time * 1e3 + n))
                },
                add: function (g, _, b) {
                    var v = _
                        ? function (w, x, P, y) {
                              ;(g(w, x, P, y), c.remove(v))
                          }
                        : g
                    return (c.remove(g), o[b ? 'unshift' : 'push'](v), kr(), v)
                },
                remove: function (g, _) {
                    ~(_ = o.indexOf(g)) && o.splice(_, 1) && f >= _ && f--
                },
                _listeners: o,
            }),
            c
        )
    })(),
    kr = function () {
        return !ps && ae.wake()
    },
    mt = {},
    ex = /^[\d.\-M][\d.\-,\s]/,
    ix = /["']/g,
    rx = function (t) {
        for (
            var e = {},
                i = t.substr(1, t.length - 3).split(':'),
                r = i[0],
                n = 1,
                a = i.length,
                o,
                h,
                l;
            n < a;
            n++
        )
            ((h = i[n]),
                (o = n !== a - 1 ? h.lastIndexOf(',') : h.length),
                (l = h.substr(0, o)),
                (e[r] = isNaN(l) ? l.replace(ix, '').trim() : +l),
                (r = h.substr(o + 1).trim()))
        return e
    },
    sx = function (t) {
        var e = t.indexOf('(') + 1,
            i = t.indexOf(')'),
            r = t.indexOf('(', e)
        return t.substring(e, ~r && r < i ? t.indexOf(')', i + 1) : i)
    },
    nx = function (t) {
        var e = (t + '').split('('),
            i = mt[e[0]]
        return i && e.length > 1 && i.config
            ? i.config.apply(
                  null,
                  ~t.indexOf('{') ? [rx(e[1])] : sx(t).split(',').map(ap),
              )
            : mt._CE && ex.test(t)
              ? mt._CE('', t)
              : i
    },
    Ep = function (t) {
        return function (e) {
            return 1 - t(1 - e)
        }
    },
    Ap = function s(t, e) {
        for (var i = t._first, r; i; )
            (i instanceof jt
                ? s(i, e)
                : i.vars.yoyoEase &&
                  (!i._yoyo || !i._repeat) &&
                  i._yoyo !== e &&
                  (i.timeline
                      ? s(i.timeline, e)
                      : ((r = i._ease),
                        (i._ease = i._yEase),
                        (i._yEase = r),
                        (i._yoyo = e))),
                (i = i._next))
    },
    Yi = function (t, e) {
        return (t && (It(t) ? t : mt[t] || nx(t))) || e
    },
    ir = function (t, e, i, r) {
        ;(i === void 0 &&
            (i = function (h) {
                return 1 - e(1 - h)
            }),
            r === void 0 &&
                (r = function (h) {
                    return h < 0.5 ? e(h * 2) / 2 : 1 - e((1 - h) * 2) / 2
                }))
        var n = { easeIn: e, easeOut: i, easeInOut: r },
            a
        return (
            Jt(t, function (o) {
                ;((mt[o] = le[o] = n), (mt[(a = o.toLowerCase())] = i))
                for (var h in n)
                    mt[
                        a +
                            (h === 'easeIn'
                                ? '.in'
                                : h === 'easeOut'
                                  ? '.out'
                                  : '.inOut')
                    ] = mt[o + '.' + h] = n[h]
            }),
            n
        )
    },
    Sp = function (t) {
        return function (e) {
            return e < 0.5 ? (1 - t(1 - e * 2)) / 2 : 0.5 + t((e - 0.5) * 2) / 2
        }
    },
    Io = function s(t, e, i) {
        var r = e >= 1 ? e : 1,
            n = (i || (t ? 0.3 : 0.45)) / (e < 1 ? e : 1),
            a = (n / Th) * (Math.asin(1 / r) || 0),
            o = function (u) {
                return u === 1
                    ? 1
                    : r * Math.pow(2, -10 * u) * Bv((u - a) * n) + 1
            },
            h =
                t === 'out'
                    ? o
                    : t === 'in'
                      ? function (l) {
                            return 1 - o(1 - l)
                        }
                      : Sp(o)
        return (
            (n = Th / n),
            (h.config = function (l, u) {
                return s(t, l, u)
            }),
            h
        )
    },
    Mo = function s(t, e) {
        e === void 0 && (e = 1.70158)
        var i = function (a) {
                return a ? --a * a * ((e + 1) * a + e) + 1 : 0
            },
            r =
                t === 'out'
                    ? i
                    : t === 'in'
                      ? function (n) {
                            return 1 - i(1 - n)
                        }
                      : Sp(i)
        return (
            (r.config = function (n) {
                return s(t, n)
            }),
            r
        )
    }
Jt('Linear,Quad,Cubic,Quart,Quint,Strong', function (s, t) {
    var e = t < 5 ? t + 1 : t
    ir(
        s + ',Power' + (e - 1),
        t
            ? function (i) {
                  return Math.pow(i, e)
              }
            : function (i) {
                  return i
              },
        function (i) {
            return 1 - Math.pow(1 - i, e)
        },
        function (i) {
            return i < 0.5
                ? Math.pow(i * 2, e) / 2
                : 1 - Math.pow((1 - i) * 2, e) / 2
        },
    )
})
mt.Linear.easeNone = mt.none = mt.Linear.easeIn
ir('Elastic', Io('in'), Io('out'), Io())
;(function (s, t) {
    var e = 1 / t,
        i = 2 * e,
        r = 2.5 * e,
        n = function (o) {
            return o < e
                ? s * o * o
                : o < i
                  ? s * Math.pow(o - 1.5 / t, 2) + 0.75
                  : o < r
                    ? s * (o -= 2.25 / t) * o + 0.9375
                    : s * Math.pow(o - 2.625 / t, 2) + 0.984375
        }
    ir(
        'Bounce',
        function (a) {
            return 1 - n(1 - a)
        },
        n,
    )
})(7.5625, 2.75)
ir('Expo', function (s) {
    return Math.pow(2, 10 * (s - 1)) * s + s * s * s * s * s * s * (1 - s)
})
ir('Circ', function (s) {
    return -(Yf(1 - s * s) - 1)
})
ir('Sine', function (s) {
    return s === 1 ? 1 : -Dv(s * Iv) + 1
})
ir('Back', Mo('in'), Mo('out'), Mo())
mt.SteppedEase =
    mt.steps =
    le.SteppedEase =
        {
            config: function (t, e) {
                t === void 0 && (t = 1)
                var i = 1 / t,
                    r = t + (e ? 0 : 1),
                    n = e ? 1 : 0,
                    a = 1 - vt
                return function (o) {
                    return (((r * Ts(0, a, o)) | 0) + n) * i
                }
            },
        }
Br.ease = mt['quad.out']
Jt(
    'onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt',
    function (s) {
        return (sl += s + ',' + s + 'Params,')
    },
)
var Cp = function (t, e) {
        ;((this.id = Mv++),
            (t._gsap = this),
            (this.target = t),
            (this.harness = e),
            (this.get = e ? e.get : sp),
            (this.set = e ? e.getSetter : ul))
    },
    ms = (function () {
        function s(e) {
            ;((this.vars = e),
                (this._delay = +e.delay || 0),
                (this._repeat = e.repeat === 1 / 0 ? -2 : e.repeat || 0) &&
                    ((this._rDelay = e.repeatDelay || 0),
                    (this._yoyo = !!e.yoyo || !!e.yoyoEase)),
                (this._ts = 1),
                Lr(this, +e.duration, 1, 1),
                (this.data = e.data),
                At && ((this._ctx = At), At.data.push(this)),
                ps || ae.wake())
        }
        var t = s.prototype
        return (
            (t.delay = function (i) {
                return i || i === 0
                    ? (this.parent &&
                          this.parent.smoothChildTiming &&
                          this.startTime(this._start + i - this._delay),
                      (this._delay = i),
                      this)
                    : this._delay
            }),
            (t.duration = function (i) {
                return arguments.length
                    ? this.totalDuration(
                          this._repeat > 0
                              ? i + (i + this._rDelay) * this._repeat
                              : i,
                      )
                    : this.totalDuration() && this._dur
            }),
            (t.totalDuration = function (i) {
                return arguments.length
                    ? ((this._dirty = 0),
                      Lr(
                          this,
                          this._repeat < 0
                              ? i
                              : (i - this._repeat * this._rDelay) /
                                    (this._repeat + 1),
                      ))
                    : this._tDur
            }),
            (t.totalTime = function (i, r) {
                if ((kr(), !arguments.length)) return this._tTime
                var n = this._dp
                if (n && n.smoothChildTiming && this._ts) {
                    for (
                        Wn(this, i), !n._dp || n.parent || lp(n, this);
                        n && n.parent;

                    )
                        (n.parent._time !==
                            n._start +
                                (n._ts >= 0
                                    ? n._tTime / n._ts
                                    : (n.totalDuration() - n._tTime) /
                                      -n._ts) && n.totalTime(n._tTime, !0),
                            (n = n.parent))
                    !this.parent &&
                        this._dp.autoRemoveChildren &&
                        ((this._ts > 0 && i < this._tDur) ||
                            (this._ts < 0 && i > 0) ||
                            (!this._tDur && !i)) &&
                        ke(this._dp, this, this._start - this._delay)
                }
                return (
                    (this._tTime !== i ||
                        (!this._dur && !r) ||
                        (this._initted && Math.abs(this._zTime) === vt) ||
                        (!i &&
                            !this._initted &&
                            (this.add || this._ptLookup))) &&
                        (this._ts || (this._pTime = i), np(this, i, r)),
                    this
                )
            }),
            (t.time = function (i, r) {
                return arguments.length
                    ? this.totalTime(
                          Math.min(this.totalDuration(), i + ed(this)) %
                              (this._dur + this._rDelay) || (i ? this._dur : 0),
                          r,
                      )
                    : this._time
            }),
            (t.totalProgress = function (i, r) {
                return arguments.length
                    ? this.totalTime(this.totalDuration() * i, r)
                    : this.totalDuration()
                      ? Math.min(1, this._tTime / this._tDur)
                      : this.rawTime() >= 0 && this._initted
                        ? 1
                        : 0
            }),
            (t.progress = function (i, r) {
                return arguments.length
                    ? this.totalTime(
                          this.duration() *
                              (this._yoyo && !(this.iteration() & 1)
                                  ? 1 - i
                                  : i) +
                              ed(this),
                          r,
                      )
                    : this.duration()
                      ? Math.min(1, this._time / this._dur)
                      : this.rawTime() > 0
                        ? 1
                        : 0
            }),
            (t.iteration = function (i, r) {
                var n = this.duration() + this._rDelay
                return arguments.length
                    ? this.totalTime(this._time + (i - 1) * n, r)
                    : this._repeat
                      ? Fr(this._tTime, n) + 1
                      : 1
            }),
            (t.timeScale = function (i, r) {
                if (!arguments.length) return this._rts === -vt ? 0 : this._rts
                if (this._rts === i) return this
                var n =
                    this.parent && this._ts
                        ? Rn(this.parent._time, this)
                        : this._tTime
                return (
                    (this._rts = +i || 0),
                    (this._ts = this._ps || i === -vt ? 0 : this._rts),
                    this.totalTime(
                        Ts(-Math.abs(this._delay), this.totalDuration(), n),
                        r !== !1,
                    ),
                    Xn(this),
                    Gv(this)
                )
            }),
            (t.paused = function (i) {
                return arguments.length
                    ? (this._ps !== i &&
                          ((this._ps = i),
                          i
                              ? ((this._pTime =
                                    this._tTime ||
                                    Math.max(-this._delay, this.rawTime())),
                                (this._ts = this._act = 0))
                              : (kr(),
                                (this._ts = this._rts),
                                this.totalTime(
                                    this.parent &&
                                        !this.parent.smoothChildTiming
                                        ? this.rawTime()
                                        : this._tTime || this._pTime,
                                    this.progress() === 1 &&
                                        Math.abs(this._zTime) !== vt &&
                                        (this._tTime -= vt),
                                ))),
                      this)
                    : this._ps
            }),
            (t.startTime = function (i) {
                if (arguments.length) {
                    this._start = i
                    var r = this.parent || this._dp
                    return (
                        r &&
                            (r._sort || !this.parent) &&
                            ke(r, this, i - this._delay),
                        this
                    )
                }
                return this._start
            }),
            (t.endTime = function (i) {
                return (
                    this._start +
                    (Qt(i) ? this.totalDuration() : this.duration()) /
                        Math.abs(this._ts || 1)
                )
            }),
            (t.rawTime = function (i) {
                var r = this.parent || this._dp
                return r
                    ? i &&
                      (!this._ts ||
                          (this._repeat &&
                              this._time &&
                              this.totalProgress() < 1))
                        ? this._tTime % (this._dur + this._rDelay)
                        : this._ts
                          ? Rn(r.rawTime(i), this)
                          : this._tTime
                    : this._tTime
            }),
            (t.revert = function (i) {
                i === void 0 && (i = Lv)
                var r = Xt
                return (
                    (Xt = i),
                    al(this) &&
                        (this.timeline && this.timeline.revert(i),
                        this.totalTime(-0.01, i.suppressEvents)),
                    this.data !== 'nested' && i.kill !== !1 && this.kill(),
                    (Xt = r),
                    this
                )
            }),
            (t.globalTime = function (i) {
                for (var r = this, n = arguments.length ? i : r.rawTime(); r; )
                    ((n = r._start + n / (Math.abs(r._ts) || 1)), (r = r._dp))
                return !this.parent && this._sat ? this._sat.globalTime(i) : n
            }),
            (t.repeat = function (i) {
                return arguments.length
                    ? ((this._repeat = i === 1 / 0 ? -2 : i), id(this))
                    : this._repeat === -2
                      ? 1 / 0
                      : this._repeat
            }),
            (t.repeatDelay = function (i) {
                if (arguments.length) {
                    var r = this._time
                    return (
                        (this._rDelay = i),
                        id(this),
                        r ? this.time(r) : this
                    )
                }
                return this._rDelay
            }),
            (t.yoyo = function (i) {
                return arguments.length ? ((this._yoyo = i), this) : this._yoyo
            }),
            (t.seek = function (i, r) {
                return this.totalTime(ce(this, i), Qt(r))
            }),
            (t.restart = function (i, r) {
                return (
                    this.play().totalTime(i ? -this._delay : 0, Qt(r)),
                    this._dur || (this._zTime = -vt),
                    this
                )
            }),
            (t.play = function (i, r) {
                return (
                    i != null && this.seek(i, r),
                    this.reversed(!1).paused(!1)
                )
            }),
            (t.reverse = function (i, r) {
                return (
                    i != null && this.seek(i || this.totalDuration(), r),
                    this.reversed(!0).paused(!1)
                )
            }),
            (t.pause = function (i, r) {
                return (i != null && this.seek(i, r), this.paused(!0))
            }),
            (t.resume = function () {
                return this.paused(!1)
            }),
            (t.reversed = function (i) {
                return arguments.length
                    ? (!!i !== this.reversed() &&
                          this.timeScale(-this._rts || (i ? -vt : 0)),
                      this)
                    : this._rts < 0
            }),
            (t.invalidate = function () {
                return (
                    (this._initted = this._act = 0),
                    (this._zTime = -vt),
                    this
                )
            }),
            (t.isActive = function () {
                var i = this.parent || this._dp,
                    r = this._start,
                    n
                return !!(
                    !i ||
                    (this._ts &&
                        this._initted &&
                        i.isActive() &&
                        (n = i.rawTime(!0)) >= r &&
                        n < this.endTime(!0) - vt)
                )
            }),
            (t.eventCallback = function (i, r, n) {
                var a = this.vars
                return arguments.length > 1
                    ? (r
                          ? ((a[i] = r),
                            n && (a[i + 'Params'] = n),
                            i === 'onUpdate' && (this._onUpdate = r))
                          : delete a[i],
                      this)
                    : a[i]
            }),
            (t.then = function (i) {
                var r = this
                return new Promise(function (n) {
                    var a = It(i) ? i : op,
                        o = function () {
                            var l = r.then
                            ;((r.then = null),
                                It(a) &&
                                    (a = a(r)) &&
                                    (a.then || a === r) &&
                                    (r.then = l),
                                n(a),
                                (r.then = l))
                        }
                    ;(r._initted && r.totalProgress() === 1 && r._ts >= 0) ||
                    (!r._tTime && r._ts < 0)
                        ? o()
                        : (r._prom = o)
                })
            }),
            (t.kill = function () {
                rs(this)
            }),
            s
        )
    })()
ue(ms.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: !1,
    parent: null,
    _initted: !1,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -vt,
    _prom: 0,
    _ps: !1,
    _rts: 1,
})
var jt = (function (s) {
    qf(t, s)
    function t(i, r) {
        var n
        return (
            i === void 0 && (i = {}),
            (n = s.call(this, i) || this),
            (n.labels = {}),
            (n.smoothChildTiming = !!i.smoothChildTiming),
            (n.autoRemoveChildren = !!i.autoRemoveChildren),
            (n._sort = Qt(i.sortChildren)),
            Ct && ke(i.parent || Ct, Ye(n), r),
            i.reversed && n.reverse(),
            i.paused && n.paused(!0),
            i.scrollTrigger && up(Ye(n), i.scrollTrigger),
            n
        )
    }
    var e = t.prototype
    return (
        (e.to = function (r, n, a) {
            return (os(0, arguments, this), this)
        }),
        (e.from = function (r, n, a) {
            return (os(1, arguments, this), this)
        }),
        (e.fromTo = function (r, n, a, o) {
            return (os(2, arguments, this), this)
        }),
        (e.set = function (r, n, a) {
            return (
                (n.duration = 0),
                (n.parent = this),
                as(n).repeatDelay || (n.repeat = 0),
                (n.immediateRender = !!n.immediateRender),
                new Ot(r, n, ce(this, a), 1),
                this
            )
        }),
        (e.call = function (r, n, a) {
            return ke(this, Ot.delayedCall(0, r, n), a)
        }),
        (e.staggerTo = function (r, n, a, o, h, l, u) {
            return (
                (a.duration = n),
                (a.stagger = a.stagger || o),
                (a.onComplete = l),
                (a.onCompleteParams = u),
                (a.parent = this),
                new Ot(r, a, ce(this, h)),
                this
            )
        }),
        (e.staggerFrom = function (r, n, a, o, h, l, u) {
            return (
                (a.runBackwards = 1),
                (as(a).immediateRender = Qt(a.immediateRender)),
                this.staggerTo(r, n, a, o, h, l, u)
            )
        }),
        (e.staggerFromTo = function (r, n, a, o, h, l, u, c) {
            return (
                (o.startAt = a),
                (as(o).immediateRender = Qt(o.immediateRender)),
                this.staggerTo(r, n, o, h, l, u, c)
            )
        }),
        (e.render = function (r, n, a) {
            var o = this._time,
                h = this._dirty ? this.totalDuration() : this._tDur,
                l = this._dur,
                u = r <= 0 ? 0 : Lt(r),
                c = this._zTime < 0 != r < 0 && (this._initted || !l),
                d,
                f,
                m,
                p,
                g,
                _,
                b,
                v,
                w,
                x,
                P,
                y
            if (
                (this !== Ct && u > h && r >= 0 && (u = h),
                u !== this._tTime || a || c)
            ) {
                if (
                    (o !== this._time &&
                        l &&
                        ((u += this._time - o), (r += this._time - o)),
                    (d = u),
                    (w = this._start),
                    (v = this._ts),
                    (_ = !v),
                    c &&
                        (l || (o = this._zTime),
                        (r || !n) && (this._zTime = r)),
                    this._repeat)
                ) {
                    if (
                        ((P = this._yoyo),
                        (g = l + this._rDelay),
                        this._repeat < -1 && r < 0)
                    )
                        return this.totalTime(g * 100 + r, n, a)
                    if (
                        ((d = Lt(u % g)),
                        u === h
                            ? ((p = this._repeat), (d = l))
                            : ((x = Lt(u / g)),
                              (p = ~~x),
                              p && p === x && ((d = l), p--),
                              d > l && (d = l)),
                        (x = Fr(this._tTime, g)),
                        !o &&
                            this._tTime &&
                            x !== p &&
                            this._tTime - x * g - this._dur <= 0 &&
                            (x = p),
                        P && p & 1 && ((d = l - d), (y = 1)),
                        p !== x && !this._lock)
                    ) {
                        var S = P && x & 1,
                            R = S === (P && p & 1)
                        if (
                            (p < x && (S = !S),
                            (o = S ? 0 : u % l ? l : u),
                            (this._lock = 1),
                            (this.render(
                                o || (y ? 0 : Lt(p * g)),
                                n,
                                !l,
                            )._lock = 0),
                            (this._tTime = u),
                            !n && this.parent && oe(this, 'onRepeat'),
                            this.vars.repeatRefresh &&
                                !y &&
                                (this.invalidate()._lock = 1),
                            (o && o !== this._time) ||
                                _ !== !this._ts ||
                                (this.vars.onRepeat &&
                                    !this.parent &&
                                    !this._act))
                        )
                            return this
                        if (
                            ((l = this._dur),
                            (h = this._tDur),
                            R &&
                                ((this._lock = 2),
                                (o = S ? l : -1e-4),
                                this.render(o, !0),
                                this.vars.repeatRefresh &&
                                    !y &&
                                    this.invalidate()),
                            (this._lock = 0),
                            !this._ts && !_)
                        )
                            return this
                        Ap(this, y)
                    }
                }
                if (
                    (this._hasPause &&
                        !this._forcing &&
                        this._lock < 2 &&
                        ((b = Xv(this, Lt(o), Lt(d))),
                        b && (u -= d - (d = b._start))),
                    (this._tTime = u),
                    (this._time = d),
                    (this._act = !v),
                    this._initted ||
                        ((this._onUpdate = this.vars.onUpdate),
                        (this._initted = 1),
                        (this._zTime = r),
                        (o = 0)),
                    !o &&
                        u &&
                        !n &&
                        !x &&
                        (oe(this, 'onStart'), this._tTime !== u))
                )
                    return this
                if (d >= o && r >= 0)
                    for (f = this._first; f; ) {
                        if (
                            ((m = f._next),
                            (f._act || d >= f._start) && f._ts && b !== f)
                        ) {
                            if (f.parent !== this) return this.render(r, n, a)
                            if (
                                (f.render(
                                    f._ts > 0
                                        ? (d - f._start) * f._ts
                                        : (f._dirty
                                              ? f.totalDuration()
                                              : f._tDur) +
                                              (d - f._start) * f._ts,
                                    n,
                                    a,
                                ),
                                d !== this._time || (!this._ts && !_))
                            ) {
                                ;((b = 0), m && (u += this._zTime = -vt))
                                break
                            }
                        }
                        f = m
                    }
                else {
                    f = this._last
                    for (var G = r < 0 ? r : d; f; ) {
                        if (
                            ((m = f._prev),
                            (f._act || G <= f._end) && f._ts && b !== f)
                        ) {
                            if (f.parent !== this) return this.render(r, n, a)
                            if (
                                (f.render(
                                    f._ts > 0
                                        ? (G - f._start) * f._ts
                                        : (f._dirty
                                              ? f.totalDuration()
                                              : f._tDur) +
                                              (G - f._start) * f._ts,
                                    n,
                                    a || (Xt && al(f)),
                                ),
                                d !== this._time || (!this._ts && !_))
                            ) {
                                ;((b = 0),
                                    m && (u += this._zTime = G ? -vt : vt))
                                break
                            }
                        }
                        f = m
                    }
                }
                if (
                    b &&
                    !n &&
                    (this.pause(),
                    (b.render(d >= o ? 0 : -vt)._zTime = d >= o ? 1 : -1),
                    this._ts)
                )
                    return ((this._start = w), Xn(this), this.render(r, n, a))
                ;(this._onUpdate && !n && oe(this, 'onUpdate', !0),
                    ((u === h && this._tTime >= this.totalDuration()) ||
                        (!u && o)) &&
                        (w === this._start ||
                            Math.abs(v) !== Math.abs(this._ts)) &&
                        (this._lock ||
                            ((r || !l) &&
                                ((u === h && this._ts > 0) ||
                                    (!u && this._ts < 0)) &&
                                Ei(this, 1),
                            !n &&
                                !(r < 0 && !o) &&
                                (u || o || !h) &&
                                (oe(
                                    this,
                                    u === h && r >= 0
                                        ? 'onComplete'
                                        : 'onReverseComplete',
                                    !0,
                                ),
                                this._prom &&
                                    !(u < h && this.timeScale() > 0) &&
                                    this._prom()))))
            }
            return this
        }),
        (e.add = function (r, n) {
            var a = this
            if ((ni(n) || (n = ce(this, n, r)), !(r instanceof ms))) {
                if ($t(r))
                    return (
                        r.forEach(function (o) {
                            return a.add(o, n)
                        }),
                        this
                    )
                if (Ht(r)) return this.addLabel(r, n)
                if (It(r)) r = Ot.delayedCall(0, r)
                else return this
            }
            return this !== r ? ke(this, r, n) : this
        }),
        (e.getChildren = function (r, n, a, o) {
            ;(r === void 0 && (r = !0),
                n === void 0 && (n = !0),
                a === void 0 && (a = !0),
                o === void 0 && (o = -me))
            for (var h = [], l = this._first; l; )
                (l._start >= o &&
                    (l instanceof Ot
                        ? n && h.push(l)
                        : (a && h.push(l),
                          r && h.push.apply(h, l.getChildren(!0, n, a)))),
                    (l = l._next))
            return h
        }),
        (e.getById = function (r) {
            for (var n = this.getChildren(1, 1, 1), a = n.length; a--; )
                if (n[a].vars.id === r) return n[a]
        }),
        (e.remove = function (r) {
            return Ht(r)
                ? this.removeLabel(r)
                : It(r)
                  ? this.killTweensOf(r)
                  : (r.parent === this && Vn(this, r),
                    r === this._recent && (this._recent = this._last),
                    qi(this))
        }),
        (e.totalTime = function (r, n) {
            return arguments.length
                ? ((this._forcing = 1),
                  !this._dp &&
                      this._ts &&
                      (this._start = Lt(
                          ae.time -
                              (this._ts > 0
                                  ? r / this._ts
                                  : (this.totalDuration() - r) / -this._ts),
                      )),
                  s.prototype.totalTime.call(this, r, n),
                  (this._forcing = 0),
                  this)
                : this._tTime
        }),
        (e.addLabel = function (r, n) {
            return ((this.labels[r] = ce(this, n)), this)
        }),
        (e.removeLabel = function (r) {
            return (delete this.labels[r], this)
        }),
        (e.addPause = function (r, n, a) {
            var o = Ot.delayedCall(0, n || ds, a)
            return (
                (o.data = 'isPause'),
                (this._hasPause = 1),
                ke(this, o, ce(this, r))
            )
        }),
        (e.removePause = function (r) {
            var n = this._first
            for (r = ce(this, r); n; )
                (n._start === r && n.data === 'isPause' && Ei(n), (n = n._next))
        }),
        (e.killTweensOf = function (r, n, a) {
            for (var o = this.getTweensOf(r, a), h = o.length; h--; )
                _i !== o[h] && o[h].kill(r, n)
            return this
        }),
        (e.getTweensOf = function (r, n) {
            for (var a = [], o = ge(r), h = this._first, l = ni(n), u; h; )
                (h instanceof Ot
                    ? kv(h._targets, o) &&
                      (l
                          ? (!_i || (h._initted && h._ts)) &&
                            h.globalTime(0) <= n &&
                            h.globalTime(h.totalDuration()) > n
                          : !n || h.isActive()) &&
                      a.push(h)
                    : (u = h.getTweensOf(o, n)).length && a.push.apply(a, u),
                    (h = h._next))
            return a
        }),
        (e.tweenTo = function (r, n) {
            n = n || {}
            var a = this,
                o = ce(a, r),
                h = n,
                l = h.startAt,
                u = h.onStart,
                c = h.onStartParams,
                d = h.immediateRender,
                f,
                m = Ot.to(
                    a,
                    ue(
                        {
                            ease: n.ease || 'none',
                            lazy: !1,
                            immediateRender: !1,
                            time: o,
                            overwrite: 'auto',
                            duration:
                                n.duration ||
                                Math.abs(
                                    (o -
                                        (l && 'time' in l ? l.time : a._time)) /
                                        a.timeScale(),
                                ) ||
                                vt,
                            onStart: function () {
                                if ((a.pause(), !f)) {
                                    var g =
                                        n.duration ||
                                        Math.abs(
                                            (o -
                                                (l && 'time' in l
                                                    ? l.time
                                                    : a._time)) /
                                                a.timeScale(),
                                        )
                                    ;(m._dur !== g &&
                                        Lr(m, g, 0, 1).render(m._time, !0, !0),
                                        (f = 1))
                                }
                                u && u.apply(m, c || [])
                            },
                        },
                        n,
                    ),
                )
            return d ? m.render(0) : m
        }),
        (e.tweenFromTo = function (r, n, a) {
            return this.tweenTo(n, ue({ startAt: { time: ce(this, r) } }, a))
        }),
        (e.recent = function () {
            return this._recent
        }),
        (e.nextLabel = function (r) {
            return (r === void 0 && (r = this._time), rd(this, ce(this, r)))
        }),
        (e.previousLabel = function (r) {
            return (r === void 0 && (r = this._time), rd(this, ce(this, r), 1))
        }),
        (e.currentLabel = function (r) {
            return arguments.length
                ? this.seek(r, !0)
                : this.previousLabel(this._time + vt)
        }),
        (e.shiftChildren = function (r, n, a) {
            a === void 0 && (a = 0)
            for (var o = this._first, h = this.labels, l; o; )
                (o._start >= a && ((o._start += r), (o._end += r)),
                    (o = o._next))
            if (n) for (l in h) h[l] >= a && (h[l] += r)
            return qi(this)
        }),
        (e.invalidate = function (r) {
            var n = this._first
            for (this._lock = 0; n; ) (n.invalidate(r), (n = n._next))
            return s.prototype.invalidate.call(this, r)
        }),
        (e.clear = function (r) {
            r === void 0 && (r = !0)
            for (var n = this._first, a; n; )
                ((a = n._next), this.remove(n), (n = a))
            return (
                this._dp && (this._time = this._tTime = this._pTime = 0),
                r && (this.labels = {}),
                qi(this)
            )
        }),
        (e.totalDuration = function (r) {
            var n = 0,
                a = this,
                o = a._last,
                h = me,
                l,
                u,
                c
            if (arguments.length)
                return a.timeScale(
                    (a._repeat < 0 ? a.duration() : a.totalDuration()) /
                        (a.reversed() ? -r : r),
                )
            if (a._dirty) {
                for (c = a.parent; o; )
                    ((l = o._prev),
                        o._dirty && o.totalDuration(),
                        (u = o._start),
                        u > h && a._sort && o._ts && !a._lock
                            ? ((a._lock = 1),
                              (ke(a, o, u - o._delay, 1)._lock = 0))
                            : (h = u),
                        u < 0 &&
                            o._ts &&
                            ((n -= u),
                            ((!c && !a._dp) || (c && c.smoothChildTiming)) &&
                                ((a._start += u / a._ts),
                                (a._time -= u),
                                (a._tTime -= u)),
                            a.shiftChildren(-u, !1, -1 / 0),
                            (h = 0)),
                        o._end > n && o._ts && (n = o._end),
                        (o = l))
                ;(Lr(a, a === Ct && a._time > n ? a._time : n, 1, 1),
                    (a._dirty = 0))
            }
            return a._tDur
        }),
        (t.updateRoot = function (r) {
            if (
                (Ct._ts && (np(Ct, Rn(r, Ct)), (rp = ae.frame)), ae.frame >= Jc)
            ) {
                Jc += he.autoSleep || 120
                var n = Ct._first
                if (
                    (!n || !n._ts) &&
                    he.autoSleep &&
                    ae._listeners.length < 2
                ) {
                    for (; n && !n._ts; ) n = n._next
                    n || ae.sleep()
                }
            }
        }),
        t
    )
})(ms)
ue(jt.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 })
var ax = function (t, e, i, r, n, a, o) {
        var h = new te(this._pt, t, e, 0, 1, Bp, null, n),
            l = 0,
            u = 0,
            c,
            d,
            f,
            m,
            p,
            g,
            _,
            b
        for (
            h.b = i,
                h.e = r,
                i += '',
                r += '',
                (_ = ~r.indexOf('random(')) && (r = fs(r)),
                a && ((b = [i, r]), a(b, t, e), (i = b[0]), (r = b[1])),
                d = i.match(Co) || [];
            (c = Co.exec(r));

        )
            ((m = c[0]),
                (p = r.substring(l, c.index)),
                f ? (f = (f + 1) % 5) : p.substr(-5) === 'rgba(' && (f = 1),
                m !== d[u++] &&
                    ((g = parseFloat(d[u - 1]) || 0),
                    (h._pt = {
                        _next: h._pt,
                        p: p || u === 1 ? p : ',',
                        s: g,
                        c:
                            m.charAt(1) === '='
                                ? Rr(g, m) - g
                                : parseFloat(m) - g,
                        m: f && f < 4 ? Math.round : 0,
                    }),
                    (l = Co.lastIndex)))
        return (
            (h.c = l < r.length ? r.substring(l, r.length) : ''),
            (h.fp = o),
            (Qf.test(r) || _) && (h.e = 0),
            (this._pt = h),
            h
        )
    },
    ol = function (t, e, i, r, n, a, o, h, l, u) {
        It(r) && (r = r(n || 0, t, a))
        var c = t[e],
            d =
                i !== 'get'
                    ? i
                    : It(c)
                      ? l
                          ? t[
                                e.indexOf('set') || !It(t['get' + e.substr(3)])
                                    ? e
                                    : 'get' + e.substr(3)
                            ](l)
                          : t[e]()
                      : c,
            f = It(c) ? (l ? cx : Mp) : ll,
            m
        if (
            (Ht(r) &&
                (~r.indexOf('random(') && (r = fs(r)),
                r.charAt(1) === '=' &&
                    ((m = Rr(d, r) + (Wt(d) || 0)), (m || m === 0) && (r = m))),
            !u || d !== r || Dh)
        )
            return !isNaN(d * r) && r !== ''
                ? ((m = new te(
                      this._pt,
                      t,
                      e,
                      +d || 0,
                      r - (d || 0),
                      typeof c == 'boolean' ? fx : Dp,
                      0,
                      f,
                  )),
                  l && (m.fp = l),
                  o && m.modifier(o, this, t),
                  (this._pt = m))
                : (!c && !(e in t) && il(e, r),
                  ax.call(this, t, e, d, r, f, h || he.stringFilter, l))
    },
    ox = function (t, e, i, r, n) {
        if (
            (It(t) && (t = hs(t, n, e, i, r)),
            !We(t) || (t.style && t.nodeType) || $t(t) || Kf(t))
        )
            return Ht(t) ? hs(t, n, e, i, r) : t
        var a = {},
            o
        for (o in t) a[o] = hs(t[o], n, e, i, r)
        return a
    },
    Pp = function (t, e, i, r, n, a) {
        var o, h, l, u
        if (
            ne[t] &&
            (o = new ne[t]()).init(
                n,
                o.rawVars ? e[t] : ox(e[t], r, n, a, i),
                i,
                r,
                a,
            ) !== !1 &&
            ((i._pt = h =
                new te(i._pt, n, t, 0, 1, o.render, o, 0, o.priority)),
            i !== wr)
        )
            for (
                l = i._ptLookup[i._targets.indexOf(n)], u = o._props.length;
                u--;

            )
                l[o._props[u]] = h
        return o
    },
    _i,
    Dh,
    hl = function s(t, e, i) {
        var r = t.vars,
            n = r.ease,
            a = r.startAt,
            o = r.immediateRender,
            h = r.lazy,
            l = r.onUpdate,
            u = r.runBackwards,
            c = r.yoyoEase,
            d = r.keyframes,
            f = r.autoRevert,
            m = t._dur,
            p = t._startAt,
            g = t._targets,
            _ = t.parent,
            b = _ && _.data === 'nested' ? _.vars.targets : g,
            v = t._overwrite === 'auto' && !Qh,
            w = t.timeline,
            x,
            P,
            y,
            S,
            R,
            G,
            N,
            I,
            O,
            L,
            V,
            T,
            A
        if (
            (w && (!d || !n) && (n = 'none'),
            (t._ease = Yi(n, Br.ease)),
            (t._yEase = c ? Ep(Yi(c === !0 ? n : c, Br.ease)) : 0),
            c &&
                t._yoyo &&
                !t._repeat &&
                ((c = t._yEase), (t._yEase = t._ease), (t._ease = c)),
            (t._from = !w && !!r.runBackwards),
            !w || (d && !r.stagger))
        ) {
            if (
                ((I = g[0] ? ji(g[0]).harness : 0),
                (T = I && r[I.prop]),
                (x = Pn(r, rl)),
                p &&
                    (p._zTime < 0 && p.progress(1),
                    e < 0 && u && o && !f
                        ? p.render(-1, !0)
                        : p.revert(u && m ? hn : Fv),
                    (p._lazy = 0)),
                a)
            ) {
                if (
                    (Ei(
                        (t._startAt = Ot.set(
                            g,
                            ue(
                                {
                                    data: 'isStart',
                                    overwrite: !1,
                                    parent: _,
                                    immediateRender: !0,
                                    lazy: !p && Qt(h),
                                    startAt: null,
                                    delay: 0,
                                    onUpdate:
                                        l &&
                                        function () {
                                            return oe(t, 'onUpdate')
                                        },
                                    stagger: 0,
                                },
                                a,
                            ),
                        )),
                    ),
                    (t._startAt._dp = 0),
                    (t._startAt._sat = t),
                    e < 0 && (Xt || (!o && !f)) && t._startAt.revert(hn),
                    o && m && e <= 0 && i <= 0)
                ) {
                    e && (t._zTime = e)
                    return
                }
            } else if (u && m && !p) {
                if (
                    (e && (o = !1),
                    (y = ue(
                        {
                            overwrite: !1,
                            data: 'isFromStart',
                            lazy: o && !p && Qt(h),
                            immediateRender: o,
                            stagger: 0,
                            parent: _,
                        },
                        x,
                    )),
                    T && (y[I.prop] = T),
                    Ei((t._startAt = Ot.set(g, y))),
                    (t._startAt._dp = 0),
                    (t._startAt._sat = t),
                    e < 0 &&
                        (Xt
                            ? t._startAt.revert(hn)
                            : t._startAt.render(-1, !0)),
                    (t._zTime = e),
                    !o)
                )
                    s(t._startAt, vt, vt)
                else if (!e) return
            }
            for (
                t._pt = t._ptCache = 0, h = (m && Qt(h)) || (h && !m), P = 0;
                P < g.length;
                P++
            ) {
                if (
                    ((R = g[P]),
                    (N = R._gsap || nl(g)[P]._gsap),
                    (t._ptLookup[P] = L = {}),
                    Sh[N.id] && bi.length && Cn(),
                    (V = b === g ? P : b.indexOf(R)),
                    I &&
                        (O = new I()).init(R, T || x, t, V, b) !== !1 &&
                        ((t._pt = S =
                            new te(
                                t._pt,
                                R,
                                O.name,
                                0,
                                1,
                                O.render,
                                O,
                                0,
                                O.priority,
                            )),
                        O._props.forEach(function (E) {
                            L[E] = S
                        }),
                        O.priority && (G = 1)),
                    !I || T)
                )
                    for (y in x)
                        ne[y] && (O = Pp(y, x, t, V, R, b))
                            ? O.priority && (G = 1)
                            : (L[y] = S =
                                  ol.call(
                                      t,
                                      R,
                                      y,
                                      'get',
                                      x[y],
                                      V,
                                      b,
                                      0,
                                      r.stringFilter,
                                  ))
                ;(t._op && t._op[P] && t.kill(R, t._op[P]),
                    v &&
                        t._pt &&
                        ((_i = t),
                        Ct.killTweensOf(R, L, t.globalTime(e)),
                        (A = !t.parent),
                        (_i = 0)),
                    t._pt && h && (Sh[N.id] = 1))
            }
            ;(G && Op(t), t._onInit && t._onInit(t))
        }
        ;((t._onUpdate = l),
            (t._initted = (!t._op || t._pt) && !A),
            d && e <= 0 && w.render(me, !0, !0))
    },
    hx = function (t, e, i, r, n, a, o, h) {
        var l = ((t._pt && t._ptCache) || (t._ptCache = {}))[e],
            u,
            c,
            d,
            f
        if (!l)
            for (
                l = t._ptCache[e] = [], d = t._ptLookup, f = t._targets.length;
                f--;

            ) {
                if (((u = d[f][e]), u && u.d && u.d._pt))
                    for (u = u.d._pt; u && u.p !== e && u.fp !== e; )
                        u = u._next
                if (!u)
                    return (
                        (Dh = 1),
                        (t.vars[e] = '+=0'),
                        hl(t, o),
                        (Dh = 0),
                        h ? cs(e + ' not eligible for reset') : 1
                    )
                l.push(u)
            }
        for (f = l.length; f--; )
            ((c = l[f]),
                (u = c._pt || c),
                (u.s = (r || r === 0) && !n ? r : u.s + (r || 0) + a * u.c),
                (u.c = i - u.s),
                c.e && (c.e = Dt(i) + Wt(c.e)),
                c.b && (c.b = u.s + Wt(c.b)))
    },
    lx = function (t, e) {
        var i = t[0] ? ji(t[0]).harness : 0,
            r = i && i.aliases,
            n,
            a,
            o,
            h
        if (!r) return e
        n = Or({}, e)
        for (a in r)
            if (a in n)
                for (h = r[a].split(','), o = h.length; o--; ) n[h[o]] = n[a]
        return n
    },
    ux = function (t, e, i, r) {
        var n = e.ease || r || 'power1.inOut',
            a,
            o
        if ($t(e))
            ((o = i[t] || (i[t] = [])),
                e.forEach(function (h, l) {
                    return o.push({ t: (l / (e.length - 1)) * 100, v: h, e: n })
                }))
        else
            for (a in e)
                ((o = i[a] || (i[a] = [])),
                    a === 'ease' || o.push({ t: parseFloat(t), v: e[a], e: n }))
    },
    hs = function (t, e, i, r, n) {
        return It(t)
            ? t.call(e, i, r, n)
            : Ht(t) && ~t.indexOf('random(')
              ? fs(t)
              : t
    },
    Rp = sl + 'repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert',
    Ip = {}
Jt(Rp + ',id,stagger,delay,duration,paused,scrollTrigger', function (s) {
    return (Ip[s] = 1)
})
var Ot = (function (s) {
    qf(t, s)
    function t(i, r, n, a) {
        var o
        ;(typeof r == 'number' && ((n.duration = r), (r = n), (n = null)),
            (o = s.call(this, a ? r : as(r)) || this))
        var h = o.vars,
            l = h.duration,
            u = h.delay,
            c = h.immediateRender,
            d = h.stagger,
            f = h.overwrite,
            m = h.keyframes,
            p = h.defaults,
            g = h.scrollTrigger,
            _ = h.yoyoEase,
            b = r.parent || Ct,
            v = ($t(i) || Kf(i) ? ni(i[0]) : 'length' in r) ? [i] : ge(i),
            w,
            x,
            P,
            y,
            S,
            R,
            G,
            N
        if (
            ((o._targets = v.length
                ? nl(v)
                : cs(
                      'GSAP target ' + i + ' not found. https://gsap.com',
                      !he.nullTargetWarn,
                  ) || []),
            (o._ptLookup = []),
            (o._overwrite = f),
            m || d || Zs(l) || Zs(u))
        ) {
            if (
                ((r = o.vars),
                (w = o.timeline =
                    new jt({
                        data: 'nested',
                        defaults: p || {},
                        targets: b && b.data === 'nested' ? b.vars.targets : v,
                    })),
                w.kill(),
                (w.parent = w._dp = Ye(o)),
                (w._start = 0),
                d || Zs(l) || Zs(u))
            ) {
                if (((y = v.length), (G = d && pp(d)), We(d)))
                    for (S in d)
                        ~Rp.indexOf(S) && (N || (N = {}), (N[S] = d[S]))
                for (x = 0; x < y; x++)
                    ((P = Pn(r, Ip)),
                        (P.stagger = 0),
                        _ && (P.yoyoEase = _),
                        N && Or(P, N),
                        (R = v[x]),
                        (P.duration = +hs(l, Ye(o), x, R, v)),
                        (P.delay = (+hs(u, Ye(o), x, R, v) || 0) - o._delay),
                        !d &&
                            y === 1 &&
                            P.delay &&
                            ((o._delay = u = P.delay),
                            (o._start += u),
                            (P.delay = 0)),
                        w.to(R, P, G ? G(x, R, v) : 0),
                        (w._ease = mt.none))
                w.duration() ? (l = u = 0) : (o.timeline = 0)
            } else if (m) {
                ;(as(ue(w.vars.defaults, { ease: 'none' })),
                    (w._ease = Yi(m.ease || r.ease || 'none')))
                var I = 0,
                    O,
                    L,
                    V
                if ($t(m))
                    (m.forEach(function (T) {
                        return w.to(v, T, '>')
                    }),
                        w.duration())
                else {
                    P = {}
                    for (S in m)
                        S === 'ease' ||
                            S === 'easeEach' ||
                            ux(S, m[S], P, m.easeEach)
                    for (S in P)
                        for (
                            O = P[S].sort(function (T, A) {
                                return T.t - A.t
                            }),
                                I = 0,
                                x = 0;
                            x < O.length;
                            x++
                        )
                            ((L = O[x]),
                                (V = {
                                    ease: L.e,
                                    duration:
                                        ((L.t - (x ? O[x - 1].t : 0)) / 100) *
                                        l,
                                }),
                                (V[S] = L.v),
                                w.to(v, V, I),
                                (I += V.duration))
                    w.duration() < l && w.to({}, { duration: l - w.duration() })
                }
            }
            l || o.duration((l = w.duration()))
        } else o.timeline = 0
        return (
            f === !0 && !Qh && ((_i = Ye(o)), Ct.killTweensOf(v), (_i = 0)),
            ke(b, Ye(o), n),
            r.reversed && o.reverse(),
            r.paused && o.paused(!0),
            (c ||
                (!l &&
                    !m &&
                    o._start === Lt(b._time) &&
                    Qt(c) &&
                    Hv(Ye(o)) &&
                    b.data !== 'nested')) &&
                ((o._tTime = -vt), o.render(Math.max(0, -u) || 0)),
            g && up(Ye(o), g),
            o
        )
    }
    var e = t.prototype
    return (
        (e.render = function (r, n, a) {
            var o = this._time,
                h = this._tDur,
                l = this._dur,
                u = r < 0,
                c = r > h - vt && !u ? h : r < vt ? 0 : r,
                d,
                f,
                m,
                p,
                g,
                _,
                b,
                v,
                w
            if (!l) Vv(this, r, n, a)
            else if (
                c !== this._tTime ||
                !r ||
                a ||
                (!this._initted && this._tTime) ||
                (this._startAt && this._zTime < 0 !== u) ||
                this._lazy
            ) {
                if (((d = c), (v = this.timeline), this._repeat)) {
                    if (((p = l + this._rDelay), this._repeat < -1 && u))
                        return this.totalTime(p * 100 + r, n, a)
                    if (
                        ((d = Lt(c % p)),
                        c === h
                            ? ((m = this._repeat), (d = l))
                            : ((g = Lt(c / p)),
                              (m = ~~g),
                              m && m === g ? ((d = l), m--) : d > l && (d = l)),
                        (_ = this._yoyo && m & 1),
                        _ && ((w = this._yEase), (d = l - d)),
                        (g = Fr(this._tTime, p)),
                        d === o && !a && this._initted && m === g)
                    )
                        return ((this._tTime = c), this)
                    m !== g &&
                        (v && this._yEase && Ap(v, _),
                        this.vars.repeatRefresh &&
                            !_ &&
                            !this._lock &&
                            d !== p &&
                            this._initted &&
                            ((this._lock = a = 1),
                            (this.render(Lt(p * m), !0).invalidate()._lock =
                                0)))
                }
                if (!this._initted) {
                    if (cp(this, u ? r : d, a, n, c))
                        return ((this._tTime = 0), this)
                    if (
                        o !== this._time &&
                        !(a && this.vars.repeatRefresh && m !== g)
                    )
                        return this
                    if (l !== this._dur) return this.render(r, n, a)
                }
                if (
                    ((this._tTime = c),
                    (this._time = d),
                    !this._act &&
                        this._ts &&
                        ((this._act = 1), (this._lazy = 0)),
                    (this.ratio = b = (w || this._ease)(d / l)),
                    this._from && (this.ratio = b = 1 - b),
                    !o &&
                        c &&
                        !n &&
                        !g &&
                        (oe(this, 'onStart'), this._tTime !== c))
                )
                    return this
                for (f = this._pt; f; ) (f.r(b, f.d), (f = f._next))
                ;((v &&
                    v.render(
                        r < 0 ? r : v._dur * v._ease(d / this._dur),
                        n,
                        a,
                    )) ||
                    (this._startAt && (this._zTime = r)),
                    this._onUpdate &&
                        !n &&
                        (u && Ch(this, r, n, a), oe(this, 'onUpdate')),
                    this._repeat &&
                        m !== g &&
                        this.vars.onRepeat &&
                        !n &&
                        this.parent &&
                        oe(this, 'onRepeat'),
                    (c === this._tDur || !c) &&
                        this._tTime === c &&
                        (u && !this._onUpdate && Ch(this, r, !0, !0),
                        (r || !l) &&
                            ((c === this._tDur && this._ts > 0) ||
                                (!c && this._ts < 0)) &&
                            Ei(this, 1),
                        !n &&
                            !(u && !o) &&
                            (c || o || _) &&
                            (oe(
                                this,
                                c === h ? 'onComplete' : 'onReverseComplete',
                                !0,
                            ),
                            this._prom &&
                                !(c < h && this.timeScale() > 0) &&
                                this._prom())))
            }
            return this
        }),
        (e.targets = function () {
            return this._targets
        }),
        (e.invalidate = function (r) {
            return (
                (!r || !this.vars.runBackwards) && (this._startAt = 0),
                (this._pt =
                    this._op =
                    this._onUpdate =
                    this._lazy =
                    this.ratio =
                        0),
                (this._ptLookup = []),
                this.timeline && this.timeline.invalidate(r),
                s.prototype.invalidate.call(this, r)
            )
        }),
        (e.resetTo = function (r, n, a, o, h) {
            ;(ps || ae.wake(), this._ts || this.play())
            var l = Math.min(
                    this._dur,
                    (this._dp._time - this._start) * this._ts,
                ),
                u
            return (
                this._initted || hl(this, l),
                (u = this._ease(l / this._dur)),
                hx(this, r, n, a, o, u, l, h)
                    ? this.resetTo(r, n, a, o, 1)
                    : (Wn(this, 0),
                      this.parent ||
                          hp(
                              this._dp,
                              this,
                              '_first',
                              '_last',
                              this._dp._sort ? '_start' : 0,
                          ),
                      this.render(0))
            )
        }),
        (e.kill = function (r, n) {
            if ((n === void 0 && (n = 'all'), !r && (!n || n === 'all')))
                return (
                    (this._lazy = this._pt = 0),
                    this.parent
                        ? rs(this)
                        : this.scrollTrigger && this.scrollTrigger.kill(!!Xt),
                    this
                )
            if (this.timeline) {
                var a = this.timeline.totalDuration()
                return (
                    this.timeline.killTweensOf(
                        r,
                        n,
                        _i && _i.vars.overwrite !== !0,
                    )._first || rs(this),
                    this.parent &&
                        a !== this.timeline.totalDuration() &&
                        Lr(this, (this._dur * this.timeline._tDur) / a, 0, 1),
                    this
                )
            }
            var o = this._targets,
                h = r ? ge(r) : o,
                l = this._ptLookup,
                u = this._pt,
                c,
                d,
                f,
                m,
                p,
                g,
                _
            if ((!n || n === 'all') && Uv(o, h))
                return (n === 'all' && (this._pt = 0), rs(this))
            for (
                c = this._op = this._op || [],
                    n !== 'all' &&
                        (Ht(n) &&
                            ((p = {}),
                            Jt(n, function (b) {
                                return (p[b] = 1)
                            }),
                            (n = p)),
                        (n = lx(o, n))),
                    _ = o.length;
                _--;

            )
                if (~h.indexOf(o[_])) {
                    ;((d = l[_]),
                        n === 'all'
                            ? ((c[_] = n), (m = d), (f = {}))
                            : ((f = c[_] = c[_] || {}), (m = n)))
                    for (p in m)
                        ((g = d && d[p]),
                            g &&
                                ((!('kill' in g.d) || g.d.kill(p) === !0) &&
                                    Vn(this, g, '_pt'),
                                delete d[p]),
                            f !== 'all' && (f[p] = 1))
                }
            return (this._initted && !this._pt && u && rs(this), this)
        }),
        (t.to = function (r, n) {
            return new t(r, n, arguments[2])
        }),
        (t.from = function (r, n) {
            return os(1, arguments)
        }),
        (t.delayedCall = function (r, n, a, o) {
            return new t(n, 0, {
                immediateRender: !1,
                lazy: !1,
                overwrite: !1,
                delay: r,
                onComplete: n,
                onReverseComplete: n,
                onCompleteParams: a,
                onReverseCompleteParams: a,
                callbackScope: o,
            })
        }),
        (t.fromTo = function (r, n, a) {
            return os(2, arguments)
        }),
        (t.set = function (r, n) {
            return (
                (n.duration = 0),
                n.repeatDelay || (n.repeat = 0),
                new t(r, n)
            )
        }),
        (t.killTweensOf = function (r, n, a) {
            return Ct.killTweensOf(r, n, a)
        }),
        t
    )
})(ms)
ue(Ot.prototype, { _targets: [], _lazy: 0, _startAt: 0, _op: 0, _onInit: 0 })
Jt('staggerTo,staggerFrom,staggerFromTo', function (s) {
    Ot[s] = function () {
        var t = new jt(),
            e = Rh.call(arguments, 0)
        return (e.splice(s === 'staggerFromTo' ? 5 : 4, 0, 0), t[s].apply(t, e))
    }
})
var ll = function (t, e, i) {
        return (t[e] = i)
    },
    Mp = function (t, e, i) {
        return t[e](i)
    },
    cx = function (t, e, i, r) {
        return t[e](r.fp, i)
    },
    dx = function (t, e, i) {
        return t.setAttribute(e, i)
    },
    ul = function (t, e) {
        return It(t[e]) ? Mp : Jh(t[e]) && t.setAttribute ? dx : ll
    },
    Dp = function (t, e) {
        return e.set(e.t, e.p, Math.round((e.s + e.c * t) * 1e6) / 1e6, e)
    },
    fx = function (t, e) {
        return e.set(e.t, e.p, !!(e.s + e.c * t), e)
    },
    Bp = function (t, e) {
        var i = e._pt,
            r = ''
        if (!t && e.b) r = e.b
        else if (t === 1 && e.e) r = e.e
        else {
            for (; i; )
                ((r =
                    i.p +
                    (i.m
                        ? i.m(i.s + i.c * t)
                        : Math.round((i.s + i.c * t) * 1e4) / 1e4) +
                    r),
                    (i = i._next))
            r += e.c
        }
        e.set(e.t, e.p, r, e)
    },
    cl = function (t, e) {
        for (var i = e._pt; i; ) (i.r(t, i.d), (i = i._next))
    },
    px = function (t, e, i, r) {
        for (var n = this._pt, a; n; )
            ((a = n._next), n.p === r && n.modifier(t, e, i), (n = a))
    },
    mx = function (t) {
        for (var e = this._pt, i, r; e; )
            ((r = e._next),
                (e.p === t && !e.op) || e.op === t
                    ? Vn(this, e, '_pt')
                    : e.dep || (i = 1),
                (e = r))
        return !i
    },
    gx = function (t, e, i, r) {
        r.mSet(t, e, r.m.call(r.tween, i, r.mt), r)
    },
    Op = function (t) {
        for (var e = t._pt, i, r, n, a; e; ) {
            for (i = e._next, r = n; r && r.pr > e.pr; ) r = r._next
            ;((e._prev = r ? r._prev : a) ? (e._prev._next = e) : (n = e),
                (e._next = r) ? (r._prev = e) : (a = e),
                (e = i))
        }
        t._pt = n
    },
    te = (function () {
        function s(e, i, r, n, a, o, h, l, u) {
            ;((this.t = i),
                (this.s = n),
                (this.c = a),
                (this.p = r),
                (this.r = o || Dp),
                (this.d = h || this),
                (this.set = l || ll),
                (this.pr = u || 0),
                (this._next = e),
                e && (e._prev = this))
        }
        var t = s.prototype
        return (
            (t.modifier = function (i, r, n) {
                ;((this.mSet = this.mSet || this.set),
                    (this.set = gx),
                    (this.m = i),
                    (this.mt = n),
                    (this.tween = r))
            }),
            s
        )
    })()
Jt(
    sl +
        'parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger',
    function (s) {
        return (rl[s] = 1)
    },
)
le.TweenMax = le.TweenLite = Ot
le.TimelineLite = le.TimelineMax = jt
Ct = new jt({
    sortChildren: !1,
    defaults: Br,
    autoRemoveChildren: !0,
    id: 'root',
    smoothChildTiming: !0,
})
he.stringFilter = Tp
var Ki = [],
    un = {},
    _x = [],
    nd = 0,
    yx = 0,
    Do = function (t) {
        return (un[t] || _x).map(function (e) {
            return e()
        })
    },
    Bh = function () {
        var t = Date.now(),
            e = []
        t - nd > 2 &&
            (Do('matchMediaInit'),
            Ki.forEach(function (i) {
                var r = i.queries,
                    n = i.conditions,
                    a,
                    o,
                    h,
                    l
                for (o in r)
                    ((a = Oe.matchMedia(r[o]).matches),
                        a && (h = 1),
                        a !== n[o] && ((n[o] = a), (l = 1)))
                l && (i.revert(), h && e.push(i))
            }),
            Do('matchMediaRevert'),
            e.forEach(function (i) {
                return i.onMatch(i, function (r) {
                    return i.add(null, r)
                })
            }),
            (nd = t),
            Do('matchMedia'))
    },
    Fp = (function () {
        function s(e, i) {
            ;((this.selector = i && Ih(i)),
                (this.data = []),
                (this._r = []),
                (this.isReverted = !1),
                (this.id = yx++),
                e && this.add(e))
        }
        var t = s.prototype
        return (
            (t.add = function (i, r, n) {
                It(i) && ((n = r), (r = i), (i = It))
                var a = this,
                    o = function () {
                        var l = At,
                            u = a.selector,
                            c
                        return (
                            l && l !== a && l.data.push(a),
                            n && (a.selector = Ih(n)),
                            (At = a),
                            (c = r.apply(a, arguments)),
                            It(c) && a._r.push(c),
                            (At = l),
                            (a.selector = u),
                            (a.isReverted = !1),
                            c
                        )
                    }
                return (
                    (a.last = o),
                    i === It
                        ? o(a, function (h) {
                              return a.add(null, h)
                          })
                        : i
                          ? (a[i] = o)
                          : o
                )
            }),
            (t.ignore = function (i) {
                var r = At
                ;((At = null), i(this), (At = r))
            }),
            (t.getTweens = function () {
                var i = []
                return (
                    this.data.forEach(function (r) {
                        return r instanceof s
                            ? i.push.apply(i, r.getTweens())
                            : r instanceof Ot &&
                                  !(r.parent && r.parent.data === 'nested') &&
                                  i.push(r)
                    }),
                    i
                )
            }),
            (t.clear = function () {
                this._r.length = this.data.length = 0
            }),
            (t.kill = function (i, r) {
                var n = this
                if (
                    (i
                        ? (function () {
                              for (
                                  var o = n.getTweens(), h = n.data.length, l;
                                  h--;

                              )
                                  ((l = n.data[h]),
                                      l.data === 'isFlip' &&
                                          (l.revert(),
                                          l
                                              .getChildren(!0, !0, !1)
                                              .forEach(function (u) {
                                                  return o.splice(
                                                      o.indexOf(u),
                                                      1,
                                                  )
                                              })))
                              for (
                                  o
                                      .map(function (u) {
                                          return {
                                              g:
                                                  u._dur ||
                                                  u._delay ||
                                                  (u._sat &&
                                                      !u._sat.vars
                                                          .immediateRender)
                                                      ? u.globalTime(0)
                                                      : -1 / 0,
                                              t: u,
                                          }
                                      })
                                      .sort(function (u, c) {
                                          return c.g - u.g || -1 / 0
                                      })
                                      .forEach(function (u) {
                                          return u.t.revert(i)
                                      }),
                                      h = n.data.length;
                                  h--;

                              )
                                  ((l = n.data[h]),
                                      l instanceof jt
                                          ? l.data !== 'nested' &&
                                            (l.scrollTrigger &&
                                                l.scrollTrigger.revert(),
                                            l.kill())
                                          : !(l instanceof Ot) &&
                                            l.revert &&
                                            l.revert(i))
                              ;(n._r.forEach(function (u) {
                                  return u(i, n)
                              }),
                                  (n.isReverted = !0))
                          })()
                        : this.data.forEach(function (o) {
                              return o.kill && o.kill()
                          }),
                    this.clear(),
                    r)
                )
                    for (var a = Ki.length; a--; )
                        Ki[a].id === this.id && Ki.splice(a, 1)
            }),
            (t.revert = function (i) {
                this.kill(i || {})
            }),
            s
        )
    })(),
    vx = (function () {
        function s(e) {
            ;((this.contexts = []), (this.scope = e), At && At.data.push(this))
        }
        var t = s.prototype
        return (
            (t.add = function (i, r, n) {
                We(i) || (i = { matches: i })
                var a = new Fp(0, n || this.scope),
                    o = (a.conditions = {}),
                    h,
                    l,
                    u
                ;(At && !a.selector && (a.selector = At.selector),
                    this.contexts.push(a),
                    (r = a.add('onMatch', r)),
                    (a.queries = i))
                for (l in i)
                    l === 'all'
                        ? (u = 1)
                        : ((h = Oe.matchMedia(i[l])),
                          h &&
                              (Ki.indexOf(a) < 0 && Ki.push(a),
                              (o[l] = h.matches) && (u = 1),
                              h.addListener
                                  ? h.addListener(Bh)
                                  : h.addEventListener('change', Bh)))
                return (
                    u &&
                        r(a, function (c) {
                            return a.add(null, c)
                        }),
                    this
                )
            }),
            (t.revert = function (i) {
                this.kill(i || {})
            }),
            (t.kill = function (i) {
                this.contexts.forEach(function (r) {
                    return r.kill(i, !0)
                })
            }),
            s
        )
    })(),
    In = {
        registerPlugin: function () {
            for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++)
                e[i] = arguments[i]
            e.forEach(function (r) {
                return xp(r)
            })
        },
        timeline: function (t) {
            return new jt(t)
        },
        getTweensOf: function (t, e) {
            return Ct.getTweensOf(t, e)
        },
        getProperty: function (t, e, i, r) {
            Ht(t) && (t = ge(t)[0])
            var n = ji(t || {}).get,
                a = i ? op : ap
            return (
                i === 'native' && (i = ''),
                t &&
                    (e
                        ? a(((ne[e] && ne[e].get) || n)(t, e, i, r))
                        : function (o, h, l) {
                              return a(((ne[o] && ne[o].get) || n)(t, o, h, l))
                          })
            )
        },
        quickSetter: function (t, e, i) {
            if (((t = ge(t)), t.length > 1)) {
                var r = t.map(function (u) {
                        return ie.quickSetter(u, e, i)
                    }),
                    n = r.length
                return function (u) {
                    for (var c = n; c--; ) r[c](u)
                }
            }
            t = t[0] || {}
            var a = ne[e],
                o = ji(t),
                h = (o.harness && (o.harness.aliases || {})[e]) || e,
                l = a
                    ? function (u) {
                          var c = new a()
                          ;((wr._pt = 0),
                              c.init(t, i ? u + i : u, wr, 0, [t]),
                              c.render(1, c),
                              wr._pt && cl(1, wr))
                      }
                    : o.set(t, h)
            return a
                ? l
                : function (u) {
                      return l(t, h, i ? u + i : u, o, 1)
                  }
        },
        quickTo: function (t, e, i) {
            var r,
                n = ie.to(
                    t,
                    ue(
                        ((r = {}),
                        (r[e] = '+=0.1'),
                        (r.paused = !0),
                        (r.stagger = 0),
                        r),
                        i || {},
                    ),
                ),
                a = function (h, l, u) {
                    return n.resetTo(e, h, l, u)
                }
            return ((a.tween = n), a)
        },
        isTweening: function (t) {
            return Ct.getTweensOf(t, !0).length > 0
        },
        defaults: function (t) {
            return (
                t && t.ease && (t.ease = Yi(t.ease, Br.ease)),
                td(Br, t || {})
            )
        },
        config: function (t) {
            return td(he, t || {})
        },
        registerEffect: function (t) {
            var e = t.name,
                i = t.effect,
                r = t.plugins,
                n = t.defaults,
                a = t.extendTimeline
            ;((r || '').split(',').forEach(function (o) {
                return (
                    o &&
                    !ne[o] &&
                    !le[o] &&
                    cs(e + ' effect requires ' + o + ' plugin.')
                )
            }),
                (Po[e] = function (o, h, l) {
                    return i(ge(o), ue(h || {}, n), l)
                }),
                a &&
                    (jt.prototype[e] = function (o, h, l) {
                        return this.add(
                            Po[e](o, We(h) ? h : (l = h) && {}, this),
                            l,
                        )
                    }))
        },
        registerEase: function (t, e) {
            mt[t] = Yi(e)
        },
        parseEase: function (t, e) {
            return arguments.length ? Yi(t, e) : mt
        },
        getById: function (t) {
            return Ct.getById(t)
        },
        exportRoot: function (t, e) {
            t === void 0 && (t = {})
            var i = new jt(t),
                r,
                n
            for (
                i.smoothChildTiming = Qt(t.smoothChildTiming),
                    Ct.remove(i),
                    i._dp = 0,
                    i._time = i._tTime = Ct._time,
                    r = Ct._first;
                r;

            )
                ((n = r._next),
                    (e ||
                        !(
                            !r._dur &&
                            r instanceof Ot &&
                            r.vars.onComplete === r._targets[0]
                        )) &&
                        ke(i, r, r._start - r._delay),
                    (r = n))
            return (ke(Ct, i, 0), i)
        },
        context: function (t, e) {
            return t ? new Fp(t, e) : At
        },
        matchMedia: function (t) {
            return new vx(t)
        },
        matchMediaRefresh: function () {
            return (
                Ki.forEach(function (t) {
                    var e = t.conditions,
                        i,
                        r
                    for (r in e) e[r] && ((e[r] = !1), (i = 1))
                    i && t.revert()
                }) || Bh()
            )
        },
        addEventListener: function (t, e) {
            var i = un[t] || (un[t] = [])
            ~i.indexOf(e) || i.push(e)
        },
        removeEventListener: function (t, e) {
            var i = un[t],
                r = i && i.indexOf(e)
            r >= 0 && i.splice(r, 1)
        },
        utils: {
            wrap: Zv,
            wrapYoyo: Qv,
            distribute: pp,
            random: gp,
            snap: mp,
            normalize: Kv,
            getUnit: Wt,
            clamp: $v,
            splitColor: bp,
            toArray: ge,
            selector: Ih,
            mapRange: yp,
            pipe: qv,
            unitize: Yv,
            interpolate: Jv,
            shuffle: fp,
        },
        install: ep,
        effects: Po,
        ticker: ae,
        updateRoot: jt.updateRoot,
        plugins: ne,
        globalTimeline: Ct,
        core: {
            PropTween: te,
            globals: ip,
            Tween: Ot,
            Timeline: jt,
            Animation: ms,
            getCache: ji,
            _removeLinkedListItem: Vn,
            reverting: function () {
                return Xt
            },
            context: function (t) {
                return (t && At && (At.data.push(t), (t._ctx = At)), At)
            },
            suppressOverwrites: function (t) {
                return (Qh = t)
            },
        },
    }
Jt('to,from,fromTo,delayedCall,set,killTweensOf', function (s) {
    return (In[s] = Ot[s])
})
ae.add(jt.updateRoot)
wr = In.to({}, { duration: 0 })
var xx = function (t, e) {
        for (var i = t._pt; i && i.p !== e && i.op !== e && i.fp !== e; )
            i = i._next
        return i
    },
    bx = function (t, e) {
        var i = t._targets,
            r,
            n,
            a
        for (r in e)
            for (n = i.length; n--; )
                ((a = t._ptLookup[n][r]),
                    a &&
                        (a = a.d) &&
                        (a._pt && (a = xx(a, r)),
                        a && a.modifier && a.modifier(e[r], t, i[n], r)))
    },
    Bo = function (t, e) {
        return {
            name: t,
            headless: 1,
            rawVars: 1,
            init: function (r, n, a) {
                a._onInit = function (o) {
                    var h, l
                    if (
                        (Ht(n) &&
                            ((h = {}),
                            Jt(n, function (u) {
                                return (h[u] = 1)
                            }),
                            (n = h)),
                        e)
                    ) {
                        h = {}
                        for (l in n) h[l] = e(n[l])
                        n = h
                    }
                    bx(o, n)
                }
            },
        }
    },
    ie =
        In.registerPlugin(
            {
                name: 'attr',
                init: function (t, e, i, r, n) {
                    var a, o, h
                    this.tween = i
                    for (a in e)
                        ((h = t.getAttribute(a) || ''),
                            (o = this.add(
                                t,
                                'setAttribute',
                                (h || 0) + '',
                                e[a],
                                r,
                                n,
                                0,
                                0,
                                a,
                            )),
                            (o.op = a),
                            (o.b = h),
                            this._props.push(a))
                },
                render: function (t, e) {
                    for (var i = e._pt; i; )
                        (Xt ? i.set(i.t, i.p, i.b, i) : i.r(t, i.d),
                            (i = i._next))
                },
            },
            {
                name: 'endArray',
                headless: 1,
                init: function (t, e) {
                    for (var i = e.length; i--; )
                        this.add(t, i, t[i] || 0, e[i], 0, 0, 0, 0, 0, 1)
                },
            },
            Bo('roundProps', Mh),
            Bo('modifiers'),
            Bo('snap', mp),
        ) || In
Ot.version = jt.version = ie.version = '3.13.0'
tp = 1
tl() && kr()
mt.Power0
mt.Power1
mt.Power2
mt.Power3
mt.Power4
mt.Linear
mt.Quad
mt.Cubic
mt.Quart
mt.Quint
mt.Strong
mt.Elastic
mt.Back
mt.SteppedEase
mt.Bounce
mt.Sine
mt.Expo
mt.Circ
/*!
 * CSSPlugin 3.13.0
 * https://gsap.com
 *
 * Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
 */ var ad,
    yi,
    Ir,
    dl,
    Xi,
    od,
    fl,
    wx = function () {
        return typeof window < 'u'
    },
    ai = {},
    Hi = 180 / Math.PI,
    Mr = Math.PI / 180,
    cr = Math.atan2,
    hd = 1e8,
    pl = /([A-Z])/g,
    Tx = /(left|right|width|margin|padding|x)/i,
    Ex = /[\s,\(]\S/,
    Ge = {
        autoAlpha: 'opacity,visibility',
        scale: 'scaleX,scaleY',
        alpha: 'opacity',
    },
    Oh = function (t, e) {
        return e.set(e.t, e.p, Math.round((e.s + e.c * t) * 1e4) / 1e4 + e.u, e)
    },
    Ax = function (t, e) {
        return e.set(
            e.t,
            e.p,
            t === 1 ? e.e : Math.round((e.s + e.c * t) * 1e4) / 1e4 + e.u,
            e,
        )
    },
    Sx = function (t, e) {
        return e.set(
            e.t,
            e.p,
            t ? Math.round((e.s + e.c * t) * 1e4) / 1e4 + e.u : e.b,
            e,
        )
    },
    Cx = function (t, e) {
        var i = e.s + e.c * t
        e.set(e.t, e.p, ~~(i + (i < 0 ? -0.5 : 0.5)) + e.u, e)
    },
    Lp = function (t, e) {
        return e.set(e.t, e.p, t ? e.e : e.b, e)
    },
    kp = function (t, e) {
        return e.set(e.t, e.p, t !== 1 ? e.b : e.e, e)
    },
    Px = function (t, e, i) {
        return (t.style[e] = i)
    },
    Rx = function (t, e, i) {
        return t.style.setProperty(e, i)
    },
    Ix = function (t, e, i) {
        return (t._gsap[e] = i)
    },
    Mx = function (t, e, i) {
        return (t._gsap.scaleX = t._gsap.scaleY = i)
    },
    Dx = function (t, e, i, r, n) {
        var a = t._gsap
        ;((a.scaleX = a.scaleY = i), a.renderTransform(n, a))
    },
    Bx = function (t, e, i, r, n) {
        var a = t._gsap
        ;((a[e] = i), a.renderTransform(n, a))
    },
    Pt = 'transform',
    ee = Pt + 'Origin',
    Ox = function s(t, e) {
        var i = this,
            r = this.target,
            n = r.style,
            a = r._gsap
        if (t in ai && n) {
            if (((this.tfm = this.tfm || {}), t !== 'transform'))
                ((t = Ge[t] || t),
                    ~t.indexOf(',')
                        ? t.split(',').forEach(function (o) {
                              return (i.tfm[o] = Ke(r, o))
                          })
                        : (this.tfm[t] = a.x ? a[t] : Ke(r, t)),
                    t === ee && (this.tfm.zOrigin = a.zOrigin))
            else
                return Ge.transform.split(',').forEach(function (o) {
                    return s.call(i, o, e)
                })
            if (this.props.indexOf(Pt) >= 0) return
            ;(a.svg &&
                ((this.svgo = r.getAttribute('data-svg-origin')),
                this.props.push(ee, e, '')),
                (t = Pt))
        }
        ;(n || e) && this.props.push(t, e, n[t])
    },
    Np = function (t) {
        t.translate &&
            (t.removeProperty('translate'),
            t.removeProperty('scale'),
            t.removeProperty('rotate'))
    },
    Fx = function () {
        var t = this.props,
            e = this.target,
            i = e.style,
            r = e._gsap,
            n,
            a
        for (n = 0; n < t.length; n += 3)
            t[n + 1]
                ? t[n + 1] === 2
                    ? e[t[n]](t[n + 2])
                    : (e[t[n]] = t[n + 2])
                : t[n + 2]
                  ? (i[t[n]] = t[n + 2])
                  : i.removeProperty(
                        t[n].substr(0, 2) === '--'
                            ? t[n]
                            : t[n].replace(pl, '-$1').toLowerCase(),
                    )
        if (this.tfm) {
            for (a in this.tfm) r[a] = this.tfm[a]
            ;(r.svg &&
                (r.renderTransform(),
                e.setAttribute('data-svg-origin', this.svgo || '')),
                (n = fl()),
                (!n || !n.isStart) &&
                    !i[Pt] &&
                    (Np(i),
                    r.zOrigin &&
                        i[ee] &&
                        ((i[ee] += ' ' + r.zOrigin + 'px'),
                        (r.zOrigin = 0),
                        r.renderTransform()),
                    (r.uncache = 1)))
        }
    },
    Up = function (t, e) {
        var i = { target: t, props: [], revert: Fx, save: Ox }
        return (
            t._gsap || ie.core.getCache(t),
            e &&
                t.style &&
                t.nodeType &&
                e.split(',').forEach(function (r) {
                    return i.save(r)
                }),
            i
        )
    },
    Gp,
    Fh = function (t, e) {
        var i = yi.createElementNS
            ? yi.createElementNS(
                  (e || 'http://www.w3.org/1999/xhtml').replace(
                      /^https/,
                      'http',
                  ),
                  t,
              )
            : yi.createElement(t)
        return i && i.style ? i : yi.createElement(t)
    },
    _e = function s(t, e, i) {
        var r = getComputedStyle(t)
        return (
            r[e] ||
            r.getPropertyValue(e.replace(pl, '-$1').toLowerCase()) ||
            r.getPropertyValue(e) ||
            (!i && s(t, Nr(e) || e, 1)) ||
            ''
        )
    },
    ld = 'O,Moz,ms,Ms,Webkit'.split(','),
    Nr = function (t, e, i) {
        var r = e || Xi,
            n = r.style,
            a = 5
        if (t in n && !i) return t
        for (
            t = t.charAt(0).toUpperCase() + t.substr(1);
            a-- && !(ld[a] + t in n);

        );
        return a < 0 ? null : (a === 3 ? 'ms' : a >= 0 ? ld[a] : '') + t
    },
    Lh = function () {
        wx() &&
            window.document &&
            ((ad = window),
            (yi = ad.document),
            (Ir = yi.documentElement),
            (Xi = Fh('div') || { style: {} }),
            Fh('div'),
            (Pt = Nr(Pt)),
            (ee = Pt + 'Origin'),
            (Xi.style.cssText =
                'border-width:0;line-height:0;position:absolute;padding:0'),
            (Gp = !!Nr('perspective')),
            (fl = ie.core.reverting),
            (dl = 1))
    },
    ud = function (t) {
        var e = t.ownerSVGElement,
            i = Fh(
                'svg',
                (e && e.getAttribute('xmlns')) || 'http://www.w3.org/2000/svg',
            ),
            r = t.cloneNode(!0),
            n
        ;((r.style.display = 'block'), i.appendChild(r), Ir.appendChild(i))
        try {
            n = r.getBBox()
        } catch {}
        return (i.removeChild(r), Ir.removeChild(i), n)
    },
    cd = function (t, e) {
        for (var i = e.length; i--; )
            if (t.hasAttribute(e[i])) return t.getAttribute(e[i])
    },
    Hp = function (t) {
        var e, i
        try {
            e = t.getBBox()
        } catch {
            ;((e = ud(t)), (i = 1))
        }
        return (
            (e && (e.width || e.height)) || i || (e = ud(t)),
            e && !e.width && !e.x && !e.y
                ? {
                      x: +cd(t, ['x', 'cx', 'x1']) || 0,
                      y: +cd(t, ['y', 'cy', 'y1']) || 0,
                      width: 0,
                      height: 0,
                  }
                : e
        )
    },
    zp = function (t) {
        return !!(t.getCTM && (!t.parentNode || t.ownerSVGElement) && Hp(t))
    },
    Ji = function (t, e) {
        if (e) {
            var i = t.style,
                r
            ;(e in ai && e !== ee && (e = Pt),
                i.removeProperty
                    ? ((r = e.substr(0, 2)),
                      (r === 'ms' || e.substr(0, 6) === 'webkit') &&
                          (e = '-' + e),
                      i.removeProperty(
                          r === '--' ? e : e.replace(pl, '-$1').toLowerCase(),
                      ))
                    : i.removeAttribute(e))
        }
    },
    vi = function (t, e, i, r, n, a) {
        var o = new te(t._pt, e, i, 0, 1, a ? kp : Lp)
        return ((t._pt = o), (o.b = r), (o.e = n), t._props.push(i), o)
    },
    dd = { deg: 1, rad: 1, turn: 1 },
    Lx = { grid: 1, flex: 1 },
    Ai = function s(t, e, i, r) {
        var n = parseFloat(i) || 0,
            a = (i + '').trim().substr((n + '').length) || 'px',
            o = Xi.style,
            h = Tx.test(e),
            l = t.tagName.toLowerCase() === 'svg',
            u = (l ? 'client' : 'offset') + (h ? 'Width' : 'Height'),
            c = 100,
            d = r === 'px',
            f = r === '%',
            m,
            p,
            g,
            _
        if (r === a || !n || dd[r] || dd[a]) return n
        if (
            (a !== 'px' && !d && (n = s(t, e, i, 'px')),
            (_ = t.getCTM && zp(t)),
            (f || a === '%') && (ai[e] || ~e.indexOf('adius')))
        )
            return (
                (m = _ ? t.getBBox()[h ? 'width' : 'height'] : t[u]),
                Dt(f ? (n / m) * c : (n / 100) * m)
            )
        if (
            ((o[h ? 'width' : 'height'] = c + (d ? a : r)),
            (p =
                (r !== 'rem' && ~e.indexOf('adius')) ||
                (r === 'em' && t.appendChild && !l)
                    ? t
                    : t.parentNode),
            _ && (p = (t.ownerSVGElement || {}).parentNode),
            (!p || p === yi || !p.appendChild) && (p = yi.body),
            (g = p._gsap),
            g && f && g.width && h && g.time === ae.time && !g.uncache)
        )
            return Dt((n / g.width) * c)
        if (f && (e === 'height' || e === 'width')) {
            var b = t.style[e]
            ;((t.style[e] = c + r), (m = t[u]), b ? (t.style[e] = b) : Ji(t, e))
        } else
            ((f || a === '%') &&
                !Lx[_e(p, 'display')] &&
                (o.position = _e(t, 'position')),
                p === t && (o.position = 'static'),
                p.appendChild(Xi),
                (m = Xi[u]),
                p.removeChild(Xi),
                (o.position = 'absolute'))
        return (
            h && f && ((g = ji(p)), (g.time = ae.time), (g.width = p[u])),
            Dt(d ? (m * n) / c : m && n ? (c / m) * n : 0)
        )
    },
    Ke = function (t, e, i, r) {
        var n
        return (
            dl || Lh(),
            e in Ge &&
                e !== 'transform' &&
                ((e = Ge[e]), ~e.indexOf(',') && (e = e.split(',')[0])),
            ai[e] && e !== 'transform'
                ? ((n = _s(t, r)),
                  (n =
                      e !== 'transformOrigin'
                          ? n[e]
                          : n.svg
                            ? n.origin
                            : Dn(_e(t, ee)) + ' ' + n.zOrigin + 'px'))
                : ((n = t.style[e]),
                  (!n || n === 'auto' || r || ~(n + '').indexOf('calc(')) &&
                      (n =
                          (Mn[e] && Mn[e](t, e, i)) ||
                          _e(t, e) ||
                          sp(t, e) ||
                          (e === 'opacity' ? 1 : 0))),
            i && !~(n + '').trim().indexOf(' ') ? Ai(t, e, n, i) + i : n
        )
    },
    kx = function (t, e, i, r) {
        if (!i || i === 'none') {
            var n = Nr(e, t, 1),
                a = n && _e(t, n, 1)
            a && a !== i
                ? ((e = n), (i = a))
                : e === 'borderColor' && (i = _e(t, 'borderTopColor'))
        }
        var o = new te(this._pt, t.style, e, 0, 1, Bp),
            h = 0,
            l = 0,
            u,
            c,
            d,
            f,
            m,
            p,
            g,
            _,
            b,
            v,
            w,
            x
        if (
            ((o.b = i),
            (o.e = r),
            (i += ''),
            (r += ''),
            r.substring(0, 6) === 'var(--' &&
                (r = _e(t, r.substring(4, r.indexOf(')')))),
            r === 'auto' &&
                ((p = t.style[e]),
                (t.style[e] = r),
                (r = _e(t, e) || r),
                p ? (t.style[e] = p) : Ji(t, e)),
            (u = [i, r]),
            Tp(u),
            (i = u[0]),
            (r = u[1]),
            (d = i.match(br) || []),
            (x = r.match(br) || []),
            x.length)
        ) {
            for (; (c = br.exec(r)); )
                ((g = c[0]),
                    (b = r.substring(h, c.index)),
                    m
                        ? (m = (m + 1) % 5)
                        : (b.substr(-5) === 'rgba(' ||
                              b.substr(-5) === 'hsla(') &&
                          (m = 1),
                    g !== (p = d[l++] || '') &&
                        ((f = parseFloat(p) || 0),
                        (w = p.substr((f + '').length)),
                        g.charAt(1) === '=' && (g = Rr(f, g) + w),
                        (_ = parseFloat(g)),
                        (v = g.substr((_ + '').length)),
                        (h = br.lastIndex - v.length),
                        v ||
                            ((v = v || he.units[e] || w),
                            h === r.length && ((r += v), (o.e += v))),
                        w !== v && (f = Ai(t, e, p, v) || 0),
                        (o._pt = {
                            _next: o._pt,
                            p: b || l === 1 ? b : ',',
                            s: f,
                            c: _ - f,
                            m: (m && m < 4) || e === 'zIndex' ? Math.round : 0,
                        })))
            o.c = h < r.length ? r.substring(h, r.length) : ''
        } else o.r = e === 'display' && r === 'none' ? kp : Lp
        return (Qf.test(r) && (o.e = 0), (this._pt = o), o)
    },
    fd = {
        top: '0%',
        bottom: '100%',
        left: '0%',
        right: '100%',
        center: '50%',
    },
    Nx = function (t) {
        var e = t.split(' '),
            i = e[0],
            r = e[1] || '50%'
        return (
            (i === 'top' || i === 'bottom' || r === 'left' || r === 'right') &&
                ((t = i), (i = r), (r = t)),
            (e[0] = fd[i] || i),
            (e[1] = fd[r] || r),
            e.join(' ')
        )
    },
    Ux = function (t, e) {
        if (e.tween && e.tween._time === e.tween._dur) {
            var i = e.t,
                r = i.style,
                n = e.u,
                a = i._gsap,
                o,
                h,
                l
            if (n === 'all' || n === !0) ((r.cssText = ''), (h = 1))
            else
                for (n = n.split(','), l = n.length; --l > -1; )
                    ((o = n[l]),
                        ai[o] &&
                            ((h = 1), (o = o === 'transformOrigin' ? ee : Pt)),
                        Ji(i, o))
            h &&
                (Ji(i, Pt),
                a &&
                    (a.svg && i.removeAttribute('transform'),
                    (r.scale = r.rotate = r.translate = 'none'),
                    _s(i, 1),
                    (a.uncache = 1),
                    Np(r)))
        }
    },
    Mn = {
        clearProps: function (t, e, i, r, n) {
            if (n.data !== 'isFromStart') {
                var a = (t._pt = new te(t._pt, e, i, 0, 0, Ux))
                return (
                    (a.u = r),
                    (a.pr = -10),
                    (a.tween = n),
                    t._props.push(i),
                    1
                )
            }
        },
    },
    gs = [1, 0, 0, 1, 0, 0],
    Vp = {},
    Xp = function (t) {
        return t === 'matrix(1, 0, 0, 1, 0, 0)' || t === 'none' || !t
    },
    pd = function (t) {
        var e = _e(t, Pt)
        return Xp(e) ? gs : e.substr(7).match(Zf).map(Dt)
    },
    ml = function (t, e) {
        var i = t._gsap || ji(t),
            r = t.style,
            n = pd(t),
            a,
            o,
            h,
            l
        return i.svg && t.getAttribute('transform')
            ? ((h = t.transform.baseVal.consolidate().matrix),
              (n = [h.a, h.b, h.c, h.d, h.e, h.f]),
              n.join(',') === '1,0,0,1,0,0' ? gs : n)
            : (n === gs &&
                  !t.offsetParent &&
                  t !== Ir &&
                  !i.svg &&
                  ((h = r.display),
                  (r.display = 'block'),
                  (a = t.parentNode),
                  (!a ||
                      (!t.offsetParent && !t.getBoundingClientRect().width)) &&
                      ((l = 1), (o = t.nextElementSibling), Ir.appendChild(t)),
                  (n = pd(t)),
                  h ? (r.display = h) : Ji(t, 'display'),
                  l &&
                      (o
                          ? a.insertBefore(t, o)
                          : a
                            ? a.appendChild(t)
                            : Ir.removeChild(t))),
              e && n.length > 6 ? [n[0], n[1], n[4], n[5], n[12], n[13]] : n)
    },
    kh = function (t, e, i, r, n, a) {
        var o = t._gsap,
            h = n || ml(t, !0),
            l = o.xOrigin || 0,
            u = o.yOrigin || 0,
            c = o.xOffset || 0,
            d = o.yOffset || 0,
            f = h[0],
            m = h[1],
            p = h[2],
            g = h[3],
            _ = h[4],
            b = h[5],
            v = e.split(' '),
            w = parseFloat(v[0]) || 0,
            x = parseFloat(v[1]) || 0,
            P,
            y,
            S,
            R
        ;(i
            ? h !== gs &&
              (y = f * g - m * p) &&
              ((S = w * (g / y) + x * (-p / y) + (p * b - g * _) / y),
              (R = w * (-m / y) + x * (f / y) - (f * b - m * _) / y),
              (w = S),
              (x = R))
            : ((P = Hp(t)),
              (w = P.x + (~v[0].indexOf('%') ? (w / 100) * P.width : w)),
              (x =
                  P.y +
                  (~(v[1] || v[0]).indexOf('%') ? (x / 100) * P.height : x))),
            r || (r !== !1 && o.smooth)
                ? ((_ = w - l),
                  (b = x - u),
                  (o.xOffset = c + (_ * f + b * p) - _),
                  (o.yOffset = d + (_ * m + b * g) - b))
                : (o.xOffset = o.yOffset = 0),
            (o.xOrigin = w),
            (o.yOrigin = x),
            (o.smooth = !!r),
            (o.origin = e),
            (o.originIsAbsolute = !!i),
            (t.style[ee] = '0px 0px'),
            a &&
                (vi(a, o, 'xOrigin', l, w),
                vi(a, o, 'yOrigin', u, x),
                vi(a, o, 'xOffset', c, o.xOffset),
                vi(a, o, 'yOffset', d, o.yOffset)),
            t.setAttribute('data-svg-origin', w + ' ' + x))
    },
    _s = function (t, e) {
        var i = t._gsap || new Cp(t)
        if ('x' in i && !e && !i.uncache) return i
        var r = t.style,
            n = i.scaleX < 0,
            a = 'px',
            o = 'deg',
            h = getComputedStyle(t),
            l = _e(t, ee) || '0',
            u,
            c,
            d,
            f,
            m,
            p,
            g,
            _,
            b,
            v,
            w,
            x,
            P,
            y,
            S,
            R,
            G,
            N,
            I,
            O,
            L,
            V,
            T,
            A,
            E,
            B,
            C,
            M,
            D,
            F,
            H,
            z
        return (
            (u = c = d = p = g = _ = b = v = w = 0),
            (f = m = 1),
            (i.svg = !!(t.getCTM && zp(t))),
            h.translate &&
                ((h.translate !== 'none' ||
                    h.scale !== 'none' ||
                    h.rotate !== 'none') &&
                    (r[Pt] =
                        (h.translate !== 'none'
                            ? 'translate3d(' +
                              (h.translate + ' 0 0')
                                  .split(' ')
                                  .slice(0, 3)
                                  .join(', ') +
                              ') '
                            : '') +
                        (h.rotate !== 'none'
                            ? 'rotate(' + h.rotate + ') '
                            : '') +
                        (h.scale !== 'none'
                            ? 'scale(' + h.scale.split(' ').join(',') + ') '
                            : '') +
                        (h[Pt] !== 'none' ? h[Pt] : '')),
                (r.scale = r.rotate = r.translate = 'none')),
            (y = ml(t, i.svg)),
            i.svg &&
                (i.uncache
                    ? ((E = t.getBBox()),
                      (l = i.xOrigin - E.x + 'px ' + (i.yOrigin - E.y) + 'px'),
                      (A = ''))
                    : (A = !e && t.getAttribute('data-svg-origin')),
                kh(t, A || l, !!A || i.originIsAbsolute, i.smooth !== !1, y)),
            (x = i.xOrigin || 0),
            (P = i.yOrigin || 0),
            y !== gs &&
                ((N = y[0]),
                (I = y[1]),
                (O = y[2]),
                (L = y[3]),
                (u = V = y[4]),
                (c = T = y[5]),
                y.length === 6
                    ? ((f = Math.sqrt(N * N + I * I)),
                      (m = Math.sqrt(L * L + O * O)),
                      (p = N || I ? cr(I, N) * Hi : 0),
                      (b = O || L ? cr(O, L) * Hi + p : 0),
                      b && (m *= Math.abs(Math.cos(b * Mr))),
                      i.svg &&
                          ((u -= x - (x * N + P * O)),
                          (c -= P - (x * I + P * L))))
                    : ((z = y[6]),
                      (F = y[7]),
                      (C = y[8]),
                      (M = y[9]),
                      (D = y[10]),
                      (H = y[11]),
                      (u = y[12]),
                      (c = y[13]),
                      (d = y[14]),
                      (S = cr(z, D)),
                      (g = S * Hi),
                      S &&
                          ((R = Math.cos(-S)),
                          (G = Math.sin(-S)),
                          (A = V * R + C * G),
                          (E = T * R + M * G),
                          (B = z * R + D * G),
                          (C = V * -G + C * R),
                          (M = T * -G + M * R),
                          (D = z * -G + D * R),
                          (H = F * -G + H * R),
                          (V = A),
                          (T = E),
                          (z = B)),
                      (S = cr(-O, D)),
                      (_ = S * Hi),
                      S &&
                          ((R = Math.cos(-S)),
                          (G = Math.sin(-S)),
                          (A = N * R - C * G),
                          (E = I * R - M * G),
                          (B = O * R - D * G),
                          (H = L * G + H * R),
                          (N = A),
                          (I = E),
                          (O = B)),
                      (S = cr(I, N)),
                      (p = S * Hi),
                      S &&
                          ((R = Math.cos(S)),
                          (G = Math.sin(S)),
                          (A = N * R + I * G),
                          (E = V * R + T * G),
                          (I = I * R - N * G),
                          (T = T * R - V * G),
                          (N = A),
                          (V = E)),
                      g &&
                          Math.abs(g) + Math.abs(p) > 359.9 &&
                          ((g = p = 0), (_ = 180 - _)),
                      (f = Dt(Math.sqrt(N * N + I * I + O * O))),
                      (m = Dt(Math.sqrt(T * T + z * z))),
                      (S = cr(V, T)),
                      (b = Math.abs(S) > 2e-4 ? S * Hi : 0),
                      (w = H ? 1 / (H < 0 ? -H : H) : 0)),
                i.svg &&
                    ((A = t.getAttribute('transform')),
                    (i.forceCSS =
                        t.setAttribute('transform', '') || !Xp(_e(t, Pt))),
                    A && t.setAttribute('transform', A))),
            Math.abs(b) > 90 &&
                Math.abs(b) < 270 &&
                (n
                    ? ((f *= -1),
                      (b += p <= 0 ? 180 : -180),
                      (p += p <= 0 ? 180 : -180))
                    : ((m *= -1), (b += b <= 0 ? 180 : -180))),
            (e = e || i.uncache),
            (i.x =
                u -
                ((i.xPercent =
                    u &&
                    ((!e && i.xPercent) ||
                        (Math.round(t.offsetWidth / 2) === Math.round(-u)
                            ? -50
                            : 0)))
                    ? (t.offsetWidth * i.xPercent) / 100
                    : 0) +
                a),
            (i.y =
                c -
                ((i.yPercent =
                    c &&
                    ((!e && i.yPercent) ||
                        (Math.round(t.offsetHeight / 2) === Math.round(-c)
                            ? -50
                            : 0)))
                    ? (t.offsetHeight * i.yPercent) / 100
                    : 0) +
                a),
            (i.z = d + a),
            (i.scaleX = Dt(f)),
            (i.scaleY = Dt(m)),
            (i.rotation = Dt(p) + o),
            (i.rotationX = Dt(g) + o),
            (i.rotationY = Dt(_) + o),
            (i.skewX = b + o),
            (i.skewY = v + o),
            (i.transformPerspective = w + a),
            (i.zOrigin =
                parseFloat(l.split(' ')[2]) || (!e && i.zOrigin) || 0) &&
                (r[ee] = Dn(l)),
            (i.xOffset = i.yOffset = 0),
            (i.force3D = he.force3D),
            (i.renderTransform = i.svg ? Hx : Gp ? Wp : Gx),
            (i.uncache = 0),
            i
        )
    },
    Dn = function (t) {
        return (t = t.split(' '))[0] + ' ' + t[1]
    },
    Oo = function (t, e, i) {
        var r = Wt(e)
        return Dt(parseFloat(e) + parseFloat(Ai(t, 'x', i + 'px', r))) + r
    },
    Gx = function (t, e) {
        ;((e.z = '0px'),
            (e.rotationY = e.rotationX = '0deg'),
            (e.force3D = 0),
            Wp(t, e))
    },
    Di = '0deg',
    qr = '0px',
    Bi = ') ',
    Wp = function (t, e) {
        var i = e || this,
            r = i.xPercent,
            n = i.yPercent,
            a = i.x,
            o = i.y,
            h = i.z,
            l = i.rotation,
            u = i.rotationY,
            c = i.rotationX,
            d = i.skewX,
            f = i.skewY,
            m = i.scaleX,
            p = i.scaleY,
            g = i.transformPerspective,
            _ = i.force3D,
            b = i.target,
            v = i.zOrigin,
            w = '',
            x = (_ === 'auto' && t && t !== 1) || _ === !0
        if (v && (c !== Di || u !== Di)) {
            var P = parseFloat(u) * Mr,
                y = Math.sin(P),
                S = Math.cos(P),
                R
            ;((P = parseFloat(c) * Mr),
                (R = Math.cos(P)),
                (a = Oo(b, a, y * R * -v)),
                (o = Oo(b, o, -Math.sin(P) * -v)),
                (h = Oo(b, h, S * R * -v + v)))
        }
        ;(g !== qr && (w += 'perspective(' + g + Bi),
            (r || n) && (w += 'translate(' + r + '%, ' + n + '%) '),
            (x || a !== qr || o !== qr || h !== qr) &&
                (w +=
                    h !== qr || x
                        ? 'translate3d(' + a + ', ' + o + ', ' + h + ') '
                        : 'translate(' + a + ', ' + o + Bi),
            l !== Di && (w += 'rotate(' + l + Bi),
            u !== Di && (w += 'rotateY(' + u + Bi),
            c !== Di && (w += 'rotateX(' + c + Bi),
            (d !== Di || f !== Di) && (w += 'skew(' + d + ', ' + f + Bi),
            (m !== 1 || p !== 1) && (w += 'scale(' + m + ', ' + p + Bi),
            (b.style[Pt] = w || 'translate(0, 0)'))
    },
    Hx = function (t, e) {
        var i = e || this,
            r = i.xPercent,
            n = i.yPercent,
            a = i.x,
            o = i.y,
            h = i.rotation,
            l = i.skewX,
            u = i.skewY,
            c = i.scaleX,
            d = i.scaleY,
            f = i.target,
            m = i.xOrigin,
            p = i.yOrigin,
            g = i.xOffset,
            _ = i.yOffset,
            b = i.forceCSS,
            v = parseFloat(a),
            w = parseFloat(o),
            x,
            P,
            y,
            S,
            R
        ;((h = parseFloat(h)),
            (l = parseFloat(l)),
            (u = parseFloat(u)),
            u && ((u = parseFloat(u)), (l += u), (h += u)),
            h || l
                ? ((h *= Mr),
                  (l *= Mr),
                  (x = Math.cos(h) * c),
                  (P = Math.sin(h) * c),
                  (y = Math.sin(h - l) * -d),
                  (S = Math.cos(h - l) * d),
                  l &&
                      ((u *= Mr),
                      (R = Math.tan(l - u)),
                      (R = Math.sqrt(1 + R * R)),
                      (y *= R),
                      (S *= R),
                      u &&
                          ((R = Math.tan(u)),
                          (R = Math.sqrt(1 + R * R)),
                          (x *= R),
                          (P *= R))),
                  (x = Dt(x)),
                  (P = Dt(P)),
                  (y = Dt(y)),
                  (S = Dt(S)))
                : ((x = c), (S = d), (P = y = 0)),
            ((v && !~(a + '').indexOf('px')) ||
                (w && !~(o + '').indexOf('px'))) &&
                ((v = Ai(f, 'x', a, 'px')), (w = Ai(f, 'y', o, 'px'))),
            (m || p || g || _) &&
                ((v = Dt(v + m - (m * x + p * y) + g)),
                (w = Dt(w + p - (m * P + p * S) + _))),
            (r || n) &&
                ((R = f.getBBox()),
                (v = Dt(v + (r / 100) * R.width)),
                (w = Dt(w + (n / 100) * R.height))),
            (R =
                'matrix(' +
                x +
                ',' +
                P +
                ',' +
                y +
                ',' +
                S +
                ',' +
                v +
                ',' +
                w +
                ')'),
            f.setAttribute('transform', R),
            b && (f.style[Pt] = R))
    },
    zx = function (t, e, i, r, n) {
        var a = 360,
            o = Ht(n),
            h = parseFloat(n) * (o && ~n.indexOf('rad') ? Hi : 1),
            l = h - r,
            u = r + l + 'deg',
            c,
            d
        return (
            o &&
                ((c = n.split('_')[1]),
                c === 'short' &&
                    ((l %= a), l !== l % (a / 2) && (l += l < 0 ? a : -a)),
                c === 'cw' && l < 0
                    ? (l = ((l + a * hd) % a) - ~~(l / a) * a)
                    : c === 'ccw' &&
                      l > 0 &&
                      (l = ((l - a * hd) % a) - ~~(l / a) * a)),
            (t._pt = d = new te(t._pt, e, i, r, l, Ax)),
            (d.e = u),
            (d.u = 'deg'),
            t._props.push(i),
            d
        )
    },
    md = function (t, e) {
        for (var i in e) t[i] = e[i]
        return t
    },
    Vx = function (t, e, i) {
        var r = md({}, i._gsap),
            n = 'perspective,force3D,transformOrigin,svgOrigin',
            a = i.style,
            o,
            h,
            l,
            u,
            c,
            d,
            f,
            m
        r.svg
            ? ((l = i.getAttribute('transform')),
              i.setAttribute('transform', ''),
              (a[Pt] = e),
              (o = _s(i, 1)),
              Ji(i, Pt),
              i.setAttribute('transform', l))
            : ((l = getComputedStyle(i)[Pt]),
              (a[Pt] = e),
              (o = _s(i, 1)),
              (a[Pt] = l))
        for (h in ai)
            ((l = r[h]),
                (u = o[h]),
                l !== u &&
                    n.indexOf(h) < 0 &&
                    ((f = Wt(l)),
                    (m = Wt(u)),
                    (c = f !== m ? Ai(i, h, l, m) : parseFloat(l)),
                    (d = parseFloat(u)),
                    (t._pt = new te(t._pt, o, h, c, d - c, Oh)),
                    (t._pt.u = m || 0),
                    t._props.push(h)))
        md(o, r)
    }
Jt('padding,margin,Width,Radius', function (s, t) {
    var e = 'Top',
        i = 'Right',
        r = 'Bottom',
        n = 'Left',
        a = (t < 3 ? [e, i, r, n] : [e + n, e + i, r + i, r + n]).map(
            function (o) {
                return t < 2 ? s + o : 'border' + o + s
            },
        )
    Mn[t > 1 ? 'border' + s : s] = function (o, h, l, u, c) {
        var d, f
        if (arguments.length < 4)
            return (
                (d = a.map(function (m) {
                    return Ke(o, m, l)
                })),
                (f = d.join(' ')),
                f.split(d[0]).length === 5 ? d[0] : f
            )
        ;((d = (u + '').split(' ')),
            (f = {}),
            a.forEach(function (m, p) {
                return (f[m] = d[p] = d[p] || d[((p - 1) / 2) | 0])
            }),
            o.init(h, f, c))
    }
})
var $p = {
    name: 'css',
    register: Lh,
    targetTest: function (t) {
        return t.style && t.nodeType
    },
    init: function (t, e, i, r, n) {
        var a = this._props,
            o = t.style,
            h = i.vars.startAt,
            l,
            u,
            c,
            d,
            f,
            m,
            p,
            g,
            _,
            b,
            v,
            w,
            x,
            P,
            y,
            S
        ;(dl || Lh(),
            (this.styles = this.styles || Up(t)),
            (S = this.styles.props),
            (this.tween = i))
        for (p in e)
            if (
                p !== 'autoRound' &&
                ((u = e[p]), !(ne[p] && Pp(p, e, i, r, t, n)))
            ) {
                if (
                    ((f = typeof u),
                    (m = Mn[p]),
                    f === 'function' &&
                        ((u = u.call(i, r, t, n)), (f = typeof u)),
                    f === 'string' && ~u.indexOf('random(') && (u = fs(u)),
                    m)
                )
                    m(this, t, p, u, i) && (y = 1)
                else if (p.substr(0, 2) === '--')
                    ((l = (
                        getComputedStyle(t).getPropertyValue(p) + ''
                    ).trim()),
                        (u += ''),
                        (wi.lastIndex = 0),
                        wi.test(l) || ((g = Wt(l)), (_ = Wt(u))),
                        _ ? g !== _ && (l = Ai(t, p, l, _) + _) : g && (u += g),
                        this.add(o, 'setProperty', l, u, r, n, 0, 0, p),
                        a.push(p),
                        S.push(p, 0, o[p]))
                else if (f !== 'undefined') {
                    if (
                        (h && p in h
                            ? ((l =
                                  typeof h[p] == 'function'
                                      ? h[p].call(i, r, t, n)
                                      : h[p]),
                              Ht(l) && ~l.indexOf('random(') && (l = fs(l)),
                              Wt(l + '') ||
                                  l === 'auto' ||
                                  (l += he.units[p] || Wt(Ke(t, p)) || ''),
                              (l + '').charAt(1) === '=' && (l = Ke(t, p)))
                            : (l = Ke(t, p)),
                        (d = parseFloat(l)),
                        (b =
                            f === 'string' &&
                            u.charAt(1) === '=' &&
                            u.substr(0, 2)),
                        b && (u = u.substr(2)),
                        (c = parseFloat(u)),
                        p in Ge &&
                            (p === 'autoAlpha' &&
                                (d === 1 &&
                                    Ke(t, 'visibility') === 'hidden' &&
                                    c &&
                                    (d = 0),
                                S.push('visibility', 0, o.visibility),
                                vi(
                                    this,
                                    o,
                                    'visibility',
                                    d ? 'inherit' : 'hidden',
                                    c ? 'inherit' : 'hidden',
                                    !c,
                                )),
                            p !== 'scale' &&
                                p !== 'transform' &&
                                ((p = Ge[p]),
                                ~p.indexOf(',') && (p = p.split(',')[0]))),
                        (v = p in ai),
                        v)
                    ) {
                        if (
                            (this.styles.save(p),
                            f === 'string' &&
                                u.substring(0, 6) === 'var(--' &&
                                ((u = _e(t, u.substring(4, u.indexOf(')')))),
                                (c = parseFloat(u))),
                            w ||
                                ((x = t._gsap),
                                (x.renderTransform && !e.parseTransform) ||
                                    _s(t, e.parseTransform),
                                (P = e.smoothOrigin !== !1 && x.smooth),
                                (w = this._pt =
                                    new te(
                                        this._pt,
                                        o,
                                        Pt,
                                        0,
                                        1,
                                        x.renderTransform,
                                        x,
                                        0,
                                        -1,
                                    )),
                                (w.dep = 1)),
                            p === 'scale')
                        )
                            ((this._pt = new te(
                                this._pt,
                                x,
                                'scaleY',
                                x.scaleY,
                                (b ? Rr(x.scaleY, b + c) : c) - x.scaleY || 0,
                                Oh,
                            )),
                                (this._pt.u = 0),
                                a.push('scaleY', p),
                                (p += 'X'))
                        else if (p === 'transformOrigin') {
                            ;(S.push(ee, 0, o[ee]),
                                (u = Nx(u)),
                                x.svg
                                    ? kh(t, u, 0, P, 0, this)
                                    : ((_ = parseFloat(u.split(' ')[2]) || 0),
                                      _ !== x.zOrigin &&
                                          vi(this, x, 'zOrigin', x.zOrigin, _),
                                      vi(this, o, p, Dn(l), Dn(u))))
                            continue
                        } else if (p === 'svgOrigin') {
                            kh(t, u, 1, P, 0, this)
                            continue
                        } else if (p in Vp) {
                            zx(this, x, p, d, b ? Rr(d, b + u) : u)
                            continue
                        } else if (p === 'smoothOrigin') {
                            vi(this, x, 'smooth', x.smooth, u)
                            continue
                        } else if (p === 'force3D') {
                            x[p] = u
                            continue
                        } else if (p === 'transform') {
                            Vx(this, u, t)
                            continue
                        }
                    } else p in o || (p = Nr(p) || p)
                    if (
                        v ||
                        ((c || c === 0) &&
                            (d || d === 0) &&
                            !Ex.test(u) &&
                            p in o)
                    )
                        ((g = (l + '').substr((d + '').length)),
                            c || (c = 0),
                            (_ = Wt(u) || (p in he.units ? he.units[p] : g)),
                            g !== _ && (d = Ai(t, p, l, _)),
                            (this._pt = new te(
                                this._pt,
                                v ? x : o,
                                p,
                                d,
                                (b ? Rr(d, b + c) : c) - d,
                                !v &&
                                (_ === 'px' || p === 'zIndex') &&
                                e.autoRound !== !1
                                    ? Cx
                                    : Oh,
                            )),
                            (this._pt.u = _ || 0),
                            g !== _ &&
                                _ !== '%' &&
                                ((this._pt.b = l), (this._pt.r = Sx)))
                    else if (p in o) kx.call(this, t, p, l, b ? b + u : u)
                    else if (p in t)
                        this.add(t, p, l || t[p], b ? b + u : u, r, n)
                    else if (p !== 'parseTransform') {
                        il(p, u)
                        continue
                    }
                    ;(v ||
                        (p in o
                            ? S.push(p, 0, o[p])
                            : typeof t[p] == 'function'
                              ? S.push(p, 2, t[p]())
                              : S.push(p, 1, l || t[p])),
                        a.push(p))
                }
            }
        y && Op(this)
    },
    render: function (t, e) {
        if (e.tween._time || !fl())
            for (var i = e._pt; i; ) (i.r(t, i.d), (i = i._next))
        else e.styles.revert()
    },
    get: Ke,
    aliases: Ge,
    getSetter: function (t, e, i) {
        var r = Ge[e]
        return (
            r && r.indexOf(',') < 0 && (e = r),
            e in ai && e !== ee && (t._gsap.x || Ke(t, 'x'))
                ? i && od === i
                    ? e === 'scale'
                        ? Mx
                        : Ix
                    : (od = i || {}) && (e === 'scale' ? Dx : Bx)
                : t.style && !Jh(t.style[e])
                  ? Px
                  : ~e.indexOf('-')
                    ? Rx
                    : ul(t, e)
        )
    },
    core: { _removeProperty: Ji, _getMatrix: ml },
}
ie.utils.checkPrefix = Nr
ie.core.getStyleSaver = Up
;(function (s, t, e, i) {
    var r = Jt(s + ',' + t + ',' + e, function (n) {
        ai[n] = 1
    })
    ;(Jt(t, function (n) {
        ;((he.units[n] = 'deg'), (Vp[n] = 1))
    }),
        (Ge[r[13]] = s + ',' + t),
        Jt(i, function (n) {
            var a = n.split(':')
            Ge[a[1]] = r[a[0]]
        }))
})(
    'x,y,z,scale,scaleX,scaleY,xPercent,yPercent',
    'rotation,rotationX,rotationY,skewX,skewY',
    'transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective',
    '0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY',
)
Jt(
    'x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective',
    function (s) {
        he.units[s] = 'px'
    },
)
ie.registerPlugin($p)
var $n = ie.registerPlugin($p) || ie
$n.core.Tween
class Xx extends ws {
    constructor(t) {
        ;(super(t),
            (this.overlayVisibility = !0),
            (this.setScene1 = this.setScene1.bind(this)),
            (this.setScene2 = this.setScene2.bind(this)),
            (this.setScene3 = this.setScene3.bind(this)),
            (this.switchOverlayVisibility =
                this.switchOverlayVisibility.bind(this)),
            (this.overlayContainer = this.addChild(new Kt())),
            (this.background = this.overlayContainer.addChild(
                new Le('./assets/images/ui_background.jpg'),
            )),
            (this.button1 = this.overlayContainer.addChild(
                new Ks('bt_b', this.setScene1, 'CARDS'),
            )),
            (this.button2 = this.overlayContainer.addChild(
                new Ks('bt_p', this.setScene2, 'DIALOG'),
            )),
            (this.button3 = this.overlayContainer.addChild(
                new Ks('bt_y', this.setScene3, 'FIRE'),
            )),
            (this.buttonBack = this.addChild(
                new Ks('arrow_left', this.switchOverlayVisibility),
            )))
    }
    setOverlayVisibility(t) {
        if (t == this.overlayVisibility) return
        this.overlayVisibility = t
        const e = t ? 1 : 0
        $n.to(this.overlayContainer, { alpha: e, duration: 0.25 })
    }
    switchOverlayVisibility() {
        ;(this.setOverlayVisibility(!this.overlayVisibility),
            this.overlayVisibility
                ? this.gameController.currentScene?.onHide?.()
                : this.gameController.currentScene?.onShow?.())
    }
    setScene1() {
        ;(this.gameController.showScene(this.gameController.scenes[0]),
            this.setOverlayVisibility(!1))
    }
    setScene2() {
        ;(this.gameController.showScene(this.gameController.scenes[1]),
            this.setOverlayVisibility(!1))
    }
    setScene3() {
        ;(this.gameController.showScene(this.gameController.scenes[2]),
            this.setOverlayVisibility(!1))
    }
    resize() {
        const {
                width: t,
                height: e,
                orientation: i,
            } = this.gameController.layoutManager,
            r = this.background.width / this.background.height,
            n = t / e
        if (
            (r < n
                ? ((this.background.width = t),
                  (this.background.scale.y = this.background.scale.x))
                : ((this.background.height = e),
                  (this.background.scale.x = this.background.scale.y)),
            i == us.LANDSCAPE)
        ) {
            const a = t * 0.25
            ;((this.button1.width = a),
                (this.button1.scale.y = this.button1.scale.x),
                this.button1.position.set(0, -0.25 * e),
                (this.button2.width = a),
                (this.button2.scale.y = this.button2.scale.x),
                this.button2.position.set(0, 0),
                (this.button3.width = a),
                (this.button3.scale.y = this.button3.scale.x),
                this.button3.position.set(0, 0.25 * e),
                (this.buttonBack.width = t * 0.05),
                (this.buttonBack.scale.y = this.buttonBack.scale.x),
                this.buttonBack.position.set(
                    t / 2 - this.buttonBack.width,
                    -e / 2 + this.buttonBack.height,
                ))
        } else if (i == us.PORTRAIT) {
            const a = e * 0.1
            ;((this.button1.height = a),
                (this.button1.scale.x = this.button1.scale.y),
                this.button1.position.set(0, -0.2 * e),
                (this.button2.height = a),
                (this.button2.scale.x = this.button2.scale.y),
                this.button2.position.set(0, 0),
                (this.button3.height = a),
                (this.button3.scale.x = this.button3.scale.y),
                this.button3.position.set(0, 0.2 * e),
                (this.buttonBack.height = e * 0.05),
                (this.buttonBack.scale.x = this.buttonBack.scale.y),
                this.buttonBack.position.set(
                    t / 2 - this.buttonBack.width,
                    -e / 2 + this.buttonBack.height,
                ))
        }
    }
}
function gd(s, t) {
    return (
        (s = Math.ceil(s)),
        (t = Math.floor(t)),
        Math.floor(Math.random() * (t - s + 1)) + s
    )
}
const Wx = ['spades', 'hearts', 'diamonds', 'clubs'],
    $x = [
        '02',
        '03',
        '04',
        '05',
        '06',
        '07',
        '08',
        '09',
        '10',
        'jack',
        'queen',
        'king',
        'ace',
    ]
class jx extends ws {
    constructor(t) {
        ;(super(t),
            (this.background = this.addChild(
                new Le('./assets/images/cards_background.jpg'),
            )),
            (this.deckStartContainer = this.addChild(new Le())),
            (this.maskCardStart = this.deckStartContainer.addChild(
                new Le('card_empty'),
            )),
            (this.deckFinishContainer = this.addChild(new Le())),
            (this.maskCardFinish = this.deckFinishContainer.addChild(
                new Le('card_empty'),
            )),
            (this.maskCardFinish.visible = !1))
        const e = 144
        for (let i = 0; i < e; i++) {
            const r = Wx[gd(0, 3)],
                n = $x[gd(0, 12)],
                a = this.deckStartContainer.addChild(new Le(r + '_' + n)),
                o = this.getPositionInDeck(this.deckStartContainer)
            ;(a.position.set(o.x, o.y), (a.visible = !1))
        }
        this.deckStartContainer.children[
            this.deckStartContainer.children.length - 1
        ].visible = !0
    }
    getPositionInDeck(t) {
        return { x: 0, y: -(t.children.length - 1) * 0.4 }
    }
    onShow() {
        this.tween ? this.tween.play() : this.startAnimation()
    }
    onHide() {
        this.tween?.pause()
    }
    animateCard() {
        const t = this.deckStartContainer.children,
            e = this.deckStartContainer.removeChildAt(t.length - 1),
            i = this.deckFinishContainer.toLocal(e, this.deckStartContainer)
        ;(this.deckFinishContainer.addChild(e), e.position.set(i.x, i.y))
        const r = this.getPositionInDeck(this.deckFinishContainer)
        return $n.to(e.position, {
            x: r.x,
            y: r.y,
            duration: 2,
            delay: 0.2,
            ease: 'power2.out',
            onStart: () => {
                const n = this.deckStartContainer.children[t.length - 1]
                this.deckStartContainer.children.length > 1
                    ? (n.visible = !0)
                    : (n.visible = !1)
            },
            onComplete: () => {
                this.deckStartContainer.children.length > 1 &&
                    (this.tween = this.animateCard())
                const n = this.deckFinishContainer.children,
                    a = this.deckFinishContainer.children[n.length - 3]
                ;((a.visible = !1), (this.maskCardFinish.visible = !0))
            },
        })
    }
    startAnimation() {
        this.animateCard()
    }
    resize() {
        const {
            width: t,
            height: e,
            orientation: i,
        } = this.gameController.layoutManager
        ;((this.background.width = t), (this.background.height = e))
        const n = 120 / this.maskCardFinish.width
        ;(this.deckFinishContainer.scale.set(n),
            this.deckStartContainer.scale.set(n),
            i == us.LANDSCAPE
                ? ((this.background.width = t),
                  (this.background.scale.y = this.background.scale.x),
                  this.deckStartContainer.position.set(-t * 0.25, 0),
                  this.deckFinishContainer.position.set(t * 0.25, 0))
                : ((this.background.height = e),
                  (this.background.scale.x = this.background.scale.y),
                  this.deckStartContainer.position.set(0, -e * 0.25),
                  this.deckFinishContainer.position.set(0, e * 0.25)))
    }
}
const qx = ['sad', 'intrigued', 'satisfied', 'neutral', 'laughing']
class Yx extends ws {
    constructor(t) {
        ;(super(t),
            (this.dialogLineIndex = 0),
            (this.avatars = {}),
            (this.emojies = []),
            (this.avatarPositions = {
                y: 0,
                x: { left: { start: 0, end: 0 }, right: { start: 0, end: 0 } },
            }),
            (this.background = this.addChild(
                new Le('./assets/images/cc_background.jpg'),
            )),
            (this.dialog = this.addChild(
                new Z0(j.from('dialog'), 20, 20, 20, 20),
            )),
            (this.textElement = document.createElement('div')),
            this.textElement.classList.add('text-element'),
            document
                .getElementById('game-container')
                .appendChild(this.textElement),
            (this.addDialogueLine = this.addDialogueLine.bind(this)))
    }
    onShow() {
        ;((this.textElement.style.visibility = 'visible'),
            this.currentDialogueTween
                ? this.currentDialogueTween.play()
                : this.addDialogueLine())
    }
    onHide() {
        ;((this.textElement.style.visibility = 'hidden'),
            this.currentDialogueTween?.pause())
    }
    async init() {
        const t =
            'https://private-624120-softgamesassignment.apiary-mock.com/v2/magicwords'
        try {
            const e = await fetch(t)
            if (!e.ok) throw new Error(`Response status: ${e.status}`)
            const i = await e.json()
            return (
                (this.dialogueData = this.sanitize(i.dialogue)),
                Promise.all([
                    this.preloadEmojis(i.emojies, i.avatars),
                    this.createAvatars(i.avatars),
                ])
            )
        } catch (e) {
            console.error(e)
        }
    }
    sanitize(t) {
        return t.filter(e => e.name != 'Neighbour')
    }
    replaceTextWithImage(t) {
        return (
            qx.forEach(e => {
                const i = this.emojies.find(r => r.name == e)
                t = t.replace(
                    `{${e}}`,
                    `<img src="${i?.url}" style="width: 50px; height: 50px" crossorigin="anonymous">`,
                )
            }),
            t
        )
    }
    addDialogueLine() {
        if (this.dialogLineIndex == this.dialogueData.length - 1) return
        const t = this.dialogueData[this.dialogLineIndex]
        ;(this.dialogLineIndex++, (this.currentDialogueData = t))
        const e = this.avatars[t.name],
            i = this.currentAvatar || e
        this.currentAvatar = e
        const r = this.avatarPositions.x[i?.position].start,
            n = this.avatarPositions.x[this.currentAvatar?.position].end,
            a = this.avatarPositions.x[this.currentAvatar.position].start
        ;(this.currentAvatar.sprite.position.set(a, this.avatarPositions.y),
            (this.currentDialogueTween = $n
                .timeline()
                .to(i.sprite.position, { x: r, duration: 1 }, 0)
                .to(i.sprite, { alpha: 0, duration: 1 }, 0)
                .to(
                    this.textElement,
                    {
                        opacity: 0,
                        duration: 1,
                        onComplete: () => {
                            this.textElement.innerHTML =
                                this.replaceTextWithImage(t.text)
                        },
                    },
                    0,
                )
                .to(
                    this.currentAvatar.sprite.position,
                    { x: n, duration: 1 },
                    1,
                )
                .to(this.currentAvatar.sprite, { alpha: 1, duration: 1 }, 1)
                .to(
                    this.textElement,
                    {
                        opacity: 1,
                        duration: 0.5,
                        onComplete: () => {
                            setTimeout(this.addDialogueLine, 3e3)
                        },
                    },
                    1,
                )))
    }
    async createAvatars(t) {
        const e = t.map(async r => {
                const n = await xr.load(r.url),
                    a = new Le(n)
                a.alpha = 0
                const o = r.name
                this.avatars[o] = {
                    sprite: this.addChild(a),
                    position: r.position,
                }
            }),
            i = await Promise.all(e)
        return (this.resize(), i)
    }
    async preloadEmojis(t, e) {
        return (
            (this.emojies = t),
            new Promise((i, r) => {
                const n = t.map(l => l.url).concat(e.map(l => l.url))
                let a = 0
                const o = n.length
                let h = []
                n.forEach(l => {
                    var u = new Image()
                    ;(h.push(u),
                        (u.onload = function () {
                            ;(a++, a == o && ((h = []), i()))
                        }),
                        (u.src = l))
                })
            })
        )
    }
    resize() {
        const {
                width: t,
                height: e,
                orientation: i,
            } = this.gameController.layoutManager,
            r = Object.keys(this.avatars),
            n = this.background.width / this.background.height,
            a = t / e
        if (
            (n < a
                ? ((this.background.width = t),
                  (this.background.scale.y = this.background.scale.x))
                : ((this.background.height = e),
                  (this.background.scale.x = this.background.scale.y)),
            i == us.LANDSCAPE)
        ) {
            ;((this.background.height = e),
                (this.background.scale.x = this.background.scale.y),
                (this.dialog.width = t * 0.98),
                (this.dialog.scale.y = this.dialog.scale.x),
                this.dialog.position.set(
                    0 - this.dialog.width / 2,
                    e / 2 - this.dialog.height * 0.15 - this.dialog.height / 2,
                ))
            for (const o in this.avatars) {
                const h = this.avatars[o].sprite
                ;((h.height = 0.4 * e), (h.scale.x = h.scale.y))
            }
            r.length &&
                ((this.avatarPositions.x.left.start =
                    -t / 2 - this.avatars[r[0]].sprite.width * 0.5),
                (this.avatarPositions.x.left.end =
                    -t / 2 + this.avatars[r[0]].sprite.width * 0.45),
                (this.avatarPositions.x.right.start =
                    t / 2 + this.avatars[r[0]].sprite.width * 0.5),
                (this.avatarPositions.x.right.end =
                    t / 2 - this.avatars[r[0]].sprite.width * 0.45),
                (this.avatarPositions.y =
                    this.dialog.position.y -
                    this.avatars[r[0]].sprite.height * 0.4))
        } else {
            ;((this.background.height = e),
                (this.background.scale.x = this.background.scale.y),
                (this.dialog.width = t * 0.98),
                (this.dialog.scale.y = this.dialog.scale.x),
                this.dialog.position.set(
                    0 - this.dialog.width / 2,
                    e / 2 - this.dialog.height * 0.4,
                ))
            for (const o in this.avatars) {
                const h = this.avatars[o].sprite
                ;((h.width = 0.4 * t), (h.scale.y = h.scale.x))
            }
            r.length &&
                ((this.avatarPositions.x.left.start =
                    -t / 2 - this.avatars[r[0]].sprite.width * 0.5),
                (this.avatarPositions.x.left.end =
                    -t / 2 + this.avatars[r[0]].sprite.width * 0.4),
                (this.avatarPositions.x.right.start =
                    t / 2 + this.avatars[r[0]].sprite.width * 0.5),
                (this.avatarPositions.x.right.end =
                    t / 2 - this.avatars[r[0]].sprite.width * 0.4),
                (this.avatarPositions.y =
                    this.dialog.position.y -
                    this.avatars[r[0]].sprite.height * 0.4))
        }
        if (this.currentDialogueData) {
            this.currentDialogueTween?.progress(1)
            const o = this.currentAvatar.position
            this.currentAvatar.sprite.position.set(
                this.avatarPositions.x[o].end,
                this.avatarPositions.y,
            )
        }
    }
}
/*!
 * @pixi/particle-emitter - v5.0.8
 * Compiled Mon, 28 Nov 2022 04:01:38 UTC
 *
 * @pixi/particle-emitter is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */ class He {
    constructor(t, e, i) {
        ;((this.value = t),
            (this.time = e),
            (this.next = null),
            (this.isStepped = !1),
            i
                ? (this.ease = typeof i == 'function' ? i : Yp(i))
                : (this.ease = null))
    }
    static createList(t) {
        if ('list' in t) {
            const i = t.list
            let r
            const { value: n, time: a } = i[0],
                o = (r = new He(typeof n == 'string' ? Qs(n) : n, a, t.ease))
            if (i.length > 2 || (i.length === 2 && i[1].value !== n))
                for (let h = 1; h < i.length; ++h) {
                    const { value: l, time: u } = i[h]
                    ;((r.next = new He(typeof l == 'string' ? Qs(l) : l, u)),
                        (r = r.next))
                }
            return ((o.isStepped = !!t.isStepped), o)
        }
        const e = new He(typeof t.start == 'string' ? Qs(t.start) : t.start, 0)
        return (
            t.end !== t.start &&
                (e.next = new He(
                    typeof t.end == 'string' ? Qs(t.end) : t.end,
                    1,
                )),
            e
        )
    }
}
let ys = j.from
const Ne = Math.PI / 180
function ei(s, t) {
    if (!s) return
    const e = Math.sin(s),
        i = Math.cos(s),
        r = t.x * i - t.y * e,
        n = t.x * e + t.y * i
    ;((t.x = r), (t.y = n))
}
function jn(s, t, e) {
    return (s << 16) | (t << 8) | e
}
function jp(s) {
    return Math.sqrt(s.x * s.x + s.y * s.y)
}
function Kx(s) {
    const t = 1 / jp(s)
    ;((s.x *= t), (s.y *= t))
}
function qp(s, t) {
    ;((s.x *= t), (s.y *= t))
}
function Qs(s, t) {
    ;(t || (t = {}),
        s.charAt(0) === '#'
            ? (s = s.substr(1))
            : s.indexOf('0x') === 0 && (s = s.substr(2)))
    let e
    return (
        s.length === 8 && ((e = s.substr(0, 2)), (s = s.substr(2))),
        (t.r = parseInt(s.substr(0, 2), 16)),
        (t.g = parseInt(s.substr(2, 2), 16)),
        (t.b = parseInt(s.substr(4, 2), 16)),
        e && (t.a = parseInt(e, 16)),
        t
    )
}
function Yp(s) {
    const t = s.length,
        e = 1 / t
    return function (i) {
        const r = (t * i) | 0,
            n = (i - r * e) * t,
            a = s[r] || s[t - 1]
        return a.s + n * (2 * (1 - n) * (a.cp - a.s) + n * (a.e - a.s))
    }
}
function Zx(s) {
    return s
        ? ((s = s.toUpperCase().replace(/ /g, '_')), ot[s] || ot.NORMAL)
        : ot.NORMAL
}
class Fo extends Gr {
    constructor(t) {
        ;(super(),
            (this.prevChild = this.nextChild = null),
            (this.emitter = t),
            (this.config = {}),
            (this.anchor.x = this.anchor.y = 0.5),
            (this.maxLife = 0),
            (this.age = 0),
            (this.agePercent = 0),
            (this.oneOverLife = 0),
            (this.next = null),
            (this.prev = null),
            (this.init = this.init),
            (this.kill = this.kill))
    }
    init(t) {
        ;((this.maxLife = t),
            (this.age = this.agePercent = 0),
            (this.rotation = 0),
            (this.position.x = this.position.y = 0),
            (this.scale.x = this.scale.y = 1),
            (this.tint = 16777215),
            (this.alpha = 1),
            (this.oneOverLife = 1 / this.maxLife),
            (this.visible = !0))
    }
    kill() {
        this.emitter.recycle(this)
    }
    destroy() {
        ;(this.parent && this.parent.removeChild(this),
            (this.emitter = this.next = this.prev = null),
            super.destroy())
    }
}
var bt
;(function (s) {
    ;((s[(s.Spawn = 0)] = 'Spawn'),
        (s[(s.Normal = 2)] = 'Normal'),
        (s[(s.Late = 5)] = 'Late'))
})(bt || (bt = {}))
const Lo = Yt.shared,
    Oi = Symbol('Position particle per emitter position')
class _t {
    constructor(t, e) {
        ;((this.initBehaviors = []),
            (this.updateBehaviors = []),
            (this.recycleBehaviors = []),
            (this.minLifetime = 0),
            (this.maxLifetime = 0),
            (this.customEase = null),
            (this._frequency = 1),
            (this.spawnChance = 1),
            (this.maxParticles = 1e3),
            (this.emitterLifetime = -1),
            (this.spawnPos = new ut()),
            (this.particlesPerWave = 1),
            (this.rotation = 0),
            (this.ownerPos = new ut()),
            (this._prevEmitterPos = new ut()),
            (this._prevPosIsValid = !1),
            (this._posChanged = !1),
            (this._parent = null),
            (this.addAtBack = !1),
            (this.particleCount = 0),
            (this._emit = !1),
            (this._spawnTimer = 0),
            (this._emitterLife = -1),
            (this._activeParticlesFirst = null),
            (this._activeParticlesLast = null),
            (this._poolFirst = null),
            (this._origConfig = null),
            (this._autoUpdate = !1),
            (this._destroyWhenComplete = !1),
            (this._completeCallback = null),
            (this.parent = t),
            e && this.init(e),
            (this.recycle = this.recycle),
            (this.update = this.update),
            (this.rotate = this.rotate),
            (this.updateSpawnPos = this.updateSpawnPos),
            (this.updateOwnerPos = this.updateOwnerPos))
    }
    static registerBehavior(t) {
        _t.knownBehaviors[t.type] = t
    }
    get frequency() {
        return this._frequency
    }
    set frequency(t) {
        typeof t == 'number' && t > 0
            ? (this._frequency = t)
            : (this._frequency = 1)
    }
    get parent() {
        return this._parent
    }
    set parent(t) {
        ;(this.cleanup(), (this._parent = t))
    }
    init(t) {
        if (!t) return
        ;(this.cleanup(),
            (this._origConfig = t),
            (this.minLifetime = t.lifetime.min),
            (this.maxLifetime = t.lifetime.max),
            t.ease
                ? (this.customEase =
                      typeof t.ease == 'function' ? t.ease : Yp(t.ease))
                : (this.customEase = null),
            (this.particlesPerWave = 1),
            t.particlesPerWave &&
                t.particlesPerWave > 1 &&
                (this.particlesPerWave = t.particlesPerWave),
            (this.frequency = t.frequency),
            (this.spawnChance =
                typeof t.spawnChance == 'number' && t.spawnChance > 0
                    ? t.spawnChance
                    : 1),
            (this.emitterLifetime = t.emitterLifetime || -1),
            (this.maxParticles = t.maxParticles > 0 ? t.maxParticles : 1e3),
            (this.addAtBack = !!t.addAtBack),
            (this.rotation = 0),
            this.ownerPos.set(0),
            t.pos ? this.spawnPos.copyFrom(t.pos) : this.spawnPos.set(0),
            this._prevEmitterPos.copyFrom(this.spawnPos),
            (this._prevPosIsValid = !1),
            (this._spawnTimer = 0),
            (this.emit = t.emit === void 0 ? !0 : !!t.emit),
            (this.autoUpdate = !!t.autoUpdate))
        const e = t.behaviors
            .map(i => {
                const r = _t.knownBehaviors[i.type]
                return r
                    ? new r(i.config)
                    : (console.error(`Unknown behavior: ${i.type}`), null)
            })
            .filter(i => !!i)
        ;(e.push(Oi),
            e.sort((i, r) =>
                i === Oi
                    ? r.order === bt.Spawn
                        ? 1
                        : -1
                    : r === Oi
                      ? i.order === bt.Spawn
                          ? -1
                          : 1
                      : i.order - r.order,
            ),
            (this.initBehaviors = e.slice()),
            (this.updateBehaviors = e.filter(
                i => i !== Oi && i.updateParticle,
            )),
            (this.recycleBehaviors = e.filter(
                i => i !== Oi && i.recycleParticle,
            )))
    }
    getBehavior(t) {
        return (
            (_t.knownBehaviors[t] &&
                this.initBehaviors.find(
                    e => e instanceof _t.knownBehaviors[t],
                )) ||
            null
        )
    }
    fillPool(t) {
        for (; t > 0; --t) {
            const e = new Fo(this)
            ;((e.next = this._poolFirst), (this._poolFirst = e))
        }
    }
    recycle(t, e = !1) {
        for (let i = 0; i < this.recycleBehaviors.length; ++i)
            this.recycleBehaviors[i].recycleParticle(t, !e)
        ;(t.next && (t.next.prev = t.prev),
            t.prev && (t.prev.next = t.next),
            t === this._activeParticlesLast &&
                (this._activeParticlesLast = t.prev),
            t === this._activeParticlesFirst &&
                (this._activeParticlesFirst = t.next),
            (t.prev = null),
            (t.next = this._poolFirst),
            (this._poolFirst = t),
            t.parent && t.parent.removeChild(t),
            --this.particleCount)
    }
    rotate(t) {
        if (this.rotation === t) return
        const e = t - this.rotation
        ;((this.rotation = t), ei(e, this.spawnPos), (this._posChanged = !0))
    }
    updateSpawnPos(t, e) {
        ;((this._posChanged = !0), (this.spawnPos.x = t), (this.spawnPos.y = e))
    }
    updateOwnerPos(t, e) {
        ;((this._posChanged = !0), (this.ownerPos.x = t), (this.ownerPos.y = e))
    }
    resetPositionTracking() {
        this._prevPosIsValid = !1
    }
    get emit() {
        return this._emit
    }
    set emit(t) {
        ;((this._emit = !!t), (this._emitterLife = this.emitterLifetime))
    }
    get autoUpdate() {
        return this._autoUpdate
    }
    set autoUpdate(t) {
        ;(this._autoUpdate && !t
            ? Lo.remove(this.update, this)
            : !this._autoUpdate && t && Lo.add(this.update, this),
            (this._autoUpdate = !!t))
    }
    playOnceAndDestroy(t) {
        ;((this.autoUpdate = !0),
            (this.emit = !0),
            (this._destroyWhenComplete = !0),
            (this._completeCallback = t))
    }
    playOnce(t) {
        ;((this.emit = !0), (this._completeCallback = t))
    }
    update(t) {
        if ((this._autoUpdate && (t = Lo.elapsedMS * 0.001), !this._parent))
            return
        for (let a = this._activeParticlesFirst, o; a; a = o)
            if (((o = a.next), (a.age += t), a.age > a.maxLife || a.age < 0))
                this.recycle(a)
            else {
                let h = a.age * a.oneOverLife
                ;(this.customEase &&
                    (this.customEase.length === 4
                        ? (h = this.customEase(h, 0, 1, 1))
                        : (h = this.customEase(h))),
                    (a.agePercent = h))
                for (let l = 0; l < this.updateBehaviors.length; ++l)
                    if (this.updateBehaviors[l].updateParticle(a, t)) {
                        this.recycle(a)
                        break
                    }
            }
        let e, i
        this._prevPosIsValid &&
            ((e = this._prevEmitterPos.x), (i = this._prevEmitterPos.y))
        const r = this.ownerPos.x + this.spawnPos.x,
            n = this.ownerPos.y + this.spawnPos.y
        if (this._emit)
            for (this._spawnTimer -= t < 0 ? 0 : t; this._spawnTimer <= 0; ) {
                if (
                    this._emitterLife >= 0 &&
                    ((this._emitterLife -= this._frequency),
                    this._emitterLife <= 0)
                ) {
                    ;((this._spawnTimer = 0),
                        (this._emitterLife = 0),
                        (this.emit = !1))
                    break
                }
                if (this.particleCount >= this.maxParticles) {
                    this._spawnTimer += this._frequency
                    continue
                }
                let a, o
                if (this._prevPosIsValid && this._posChanged) {
                    const u = 1 + this._spawnTimer / t
                    ;((a = (r - e) * u + e), (o = (n - i) * u + i))
                } else ((a = r), (o = n))
                let h = null,
                    l = null
                for (
                    let u = Math.min(
                            this.particlesPerWave,
                            this.maxParticles - this.particleCount,
                        ),
                        c = 0;
                    c < u;
                    ++c
                ) {
                    if (
                        this.spawnChance < 1 &&
                        Math.random() >= this.spawnChance
                    )
                        continue
                    let d
                    if (
                        (this.minLifetime === this.maxLifetime
                            ? (d = this.minLifetime)
                            : (d =
                                  Math.random() *
                                      (this.maxLifetime - this.minLifetime) +
                                  this.minLifetime),
                        -this._spawnTimer >= d)
                    )
                        continue
                    let f
                    ;(this._poolFirst
                        ? ((f = this._poolFirst),
                          (this._poolFirst = this._poolFirst.next),
                          (f.next = null))
                        : (f = new Fo(this)),
                        f.init(d),
                        this.addAtBack
                            ? this._parent.addChildAt(f, 0)
                            : this._parent.addChild(f),
                        h ? ((l.next = f), (f.prev = l), (l = f)) : (l = h = f),
                        ++this.particleCount)
                }
                if (h) {
                    this._activeParticlesLast
                        ? ((this._activeParticlesLast.next = h),
                          (h.prev = this._activeParticlesLast),
                          (this._activeParticlesLast = l))
                        : ((this._activeParticlesFirst = h),
                          (this._activeParticlesLast = l))
                    for (let u = 0; u < this.initBehaviors.length; ++u) {
                        const c = this.initBehaviors[u]
                        if (c === Oi)
                            for (let d = h, f; d; d = f) {
                                ;((f = d.next),
                                    this.rotation !== 0 &&
                                        (ei(this.rotation, d.position),
                                        (d.rotation += this.rotation)),
                                    (d.position.x += a),
                                    (d.position.y += o),
                                    (d.age += -this._spawnTimer))
                                let m = d.age * d.oneOverLife
                                ;(this.customEase &&
                                    (this.customEase.length === 4
                                        ? (m = this.customEase(m, 0, 1, 1))
                                        : (m = this.customEase(m))),
                                    (d.agePercent = m))
                            }
                        else c.initParticles(h)
                    }
                    for (let u = h, c; u; u = c) {
                        c = u.next
                        for (let d = 0; d < this.updateBehaviors.length; ++d)
                            if (
                                this.updateBehaviors[d].updateParticle(
                                    u,
                                    -this._spawnTimer,
                                )
                            ) {
                                this.recycle(u)
                                break
                            }
                    }
                }
                this._spawnTimer += this._frequency
            }
        if (
            (this._posChanged &&
                ((this._prevEmitterPos.x = r),
                (this._prevEmitterPos.y = n),
                (this._prevPosIsValid = !0),
                (this._posChanged = !1)),
            !this._emit && !this._activeParticlesFirst)
        ) {
            if (this._completeCallback) {
                const a = this._completeCallback
                ;((this._completeCallback = null), a())
            }
            this._destroyWhenComplete && this.destroy()
        }
    }
    emitNow() {
        const t = this.ownerPos.x + this.spawnPos.x,
            e = this.ownerPos.y + this.spawnPos.y
        let i = null,
            r = null
        for (
            let n = Math.min(
                    this.particlesPerWave,
                    this.maxParticles - this.particleCount,
                ),
                a = 0;
            a < n;
            ++a
        ) {
            if (this.spawnChance < 1 && Math.random() >= this.spawnChance)
                continue
            let o
            this._poolFirst
                ? ((o = this._poolFirst),
                  (this._poolFirst = this._poolFirst.next),
                  (o.next = null))
                : (o = new Fo(this))
            let h
            ;(this.minLifetime === this.maxLifetime
                ? (h = this.minLifetime)
                : (h =
                      Math.random() * (this.maxLifetime - this.minLifetime) +
                      this.minLifetime),
                o.init(h),
                this.addAtBack
                    ? this._parent.addChildAt(o, 0)
                    : this._parent.addChild(o),
                i ? ((r.next = o), (o.prev = r), (r = o)) : (r = i = o),
                ++this.particleCount)
        }
        if (i) {
            this._activeParticlesLast
                ? ((this._activeParticlesLast.next = i),
                  (i.prev = this._activeParticlesLast),
                  (this._activeParticlesLast = r))
                : ((this._activeParticlesFirst = i),
                  (this._activeParticlesLast = r))
            for (let n = 0; n < this.initBehaviors.length; ++n) {
                const a = this.initBehaviors[n]
                if (a === Oi)
                    for (let o = i, h; o; o = h)
                        ((h = o.next),
                            this.rotation !== 0 &&
                                (ei(this.rotation, o.position),
                                (o.rotation += this.rotation)),
                            (o.position.x += t),
                            (o.position.y += e))
                else a.initParticles(i)
            }
        }
    }
    cleanup() {
        let t, e
        for (t = this._activeParticlesFirst; t; t = e)
            ((e = t.next), this.recycle(t, !0))
        ;((this._activeParticlesFirst = this._activeParticlesLast = null),
            (this.particleCount = 0))
    }
    get destroyed() {
        return !(this._parent && this.initBehaviors.length)
    }
    destroy() {
        ;((this.autoUpdate = !1), this.cleanup())
        let t
        for (let e = this._poolFirst; e; e = t) ((t = e.next), e.destroy())
        ;((this._poolFirst =
            this._parent =
            this.spawnPos =
            this.ownerPos =
            this.customEase =
            this._completeCallback =
                null),
            (this.initBehaviors.length =
                this.updateBehaviors.length =
                this.recycleBehaviors.length =
                    0))
    }
}
_t.knownBehaviors = {}
class gl {
    constructor(t) {
        ;((this.x = t.x), (this.y = t.y), (this.w = t.w), (this.h = t.h))
    }
    getRandPos(t) {
        ;((t.x = Math.random() * this.w + this.x),
            (t.y = Math.random() * this.h + this.y))
    }
}
gl.type = 'rect'
gl.editorConfig = null
class qn {
    constructor(t) {
        ;((this.x = t.x || 0),
            (this.y = t.y || 0),
            (this.radius = t.radius),
            (this.innerRadius = t.innerRadius || 0),
            (this.rotation = !!t.affectRotation))
    }
    getRandPos(t) {
        ;(this.innerRadius !== this.radius
            ? (t.x =
                  Math.random() * (this.radius - this.innerRadius) +
                  this.innerRadius)
            : (t.x = this.radius),
            (t.y = 0))
        const e = Math.random() * Math.PI * 2
        ;(this.rotation && (t.rotation += e),
            ei(e, t.position),
            (t.position.x += this.x),
            (t.position.y += this.y))
    }
}
qn.type = 'torus'
qn.editorConfig = null
class _l {
    constructor(t) {
        ;((this.segments = []),
            (this.countingLengths = []),
            (this.totalLength = 0),
            this.init(t))
    }
    init(t) {
        if (!t || !t.length)
            this.segments.push({ p1: { x: 0, y: 0 }, p2: { x: 0, y: 0 }, l: 0 })
        else if (Array.isArray(t[0]))
            for (let e = 0; e < t.length; ++e) {
                const i = t[e]
                let r = i[0]
                for (let n = 1; n < i.length; ++n) {
                    const a = i[n]
                    ;(this.segments.push({ p1: r, p2: a, l: 0 }), (r = a))
                }
            }
        else {
            let e = t[0]
            for (let i = 1; i < t.length; ++i) {
                const r = t[i]
                ;(this.segments.push({ p1: e, p2: r, l: 0 }), (e = r))
            }
        }
        for (let e = 0; e < this.segments.length; ++e) {
            const { p1: i, p2: r } = this.segments[e],
                n = Math.sqrt(
                    (r.x - i.x) * (r.x - i.x) + (r.y - i.y) * (r.y - i.y),
                )
            ;((this.segments[e].l = n),
                (this.totalLength += n),
                this.countingLengths.push(this.totalLength))
        }
    }
    getRandPos(t) {
        const e = Math.random() * this.totalLength
        let i, r
        if (this.segments.length === 1) ((i = this.segments[0]), (r = e))
        else
            for (let o = 0; o < this.countingLengths.length; ++o)
                if (e < this.countingLengths[o]) {
                    ;((i = this.segments[o]),
                        (r = o === 0 ? e : e - this.countingLengths[o - 1]))
                    break
                }
        r /= i.l || 1
        const { p1: n, p2: a } = i
        ;((t.x = n.x + r * (a.x - n.x)), (t.y = n.y + r * (a.y - n.y)))
    }
}
_l.type = 'polygonalChain'
_l.editorConfig = null
class yl {
    constructor(t) {
        var e
        ;((this.order = bt.Late),
            (this.minStart = t.minStart),
            (this.maxStart = t.maxStart),
            (this.accel = t.accel),
            (this.rotate = !!t.rotate),
            (this.maxSpeed = (e = t.maxSpeed) !== null && e !== void 0 ? e : 0))
    }
    initParticles(t) {
        let e = t
        for (; e; ) {
            const i =
                Math.random() * (this.maxStart - this.minStart) + this.minStart
            ;(e.config.velocity
                ? e.config.velocity.set(i, 0)
                : (e.config.velocity = new ut(i, 0)),
                ei(e.rotation, e.config.velocity),
                (e = e.next))
        }
    }
    updateParticle(t, e) {
        const i = t.config.velocity,
            r = i.x,
            n = i.y
        if (
            ((i.x += this.accel.x * e),
            (i.y += this.accel.y * e),
            this.maxSpeed)
        ) {
            const a = jp(i)
            a > this.maxSpeed && qp(i, this.maxSpeed / a)
        }
        ;((t.x += ((r + i.x) / 2) * e),
            (t.y += ((n + i.y) / 2) * e),
            this.rotate && (t.rotation = Math.atan2(i.y, i.x)))
    }
}
yl.type = 'moveAcceleration'
yl.editorConfig = null
function Qx(s) {
    return (
        this.ease && (s = this.ease(s)),
        (this.first.next.value - this.first.value) * s + this.first.value
    )
}
function Jx(s) {
    this.ease && (s = this.ease(s))
    const t = this.first.value,
        e = this.first.next.value,
        i = (e.r - t.r) * s + t.r,
        r = (e.g - t.g) * s + t.g,
        n = (e.b - t.b) * s + t.b
    return jn(i, r, n)
}
function tb(s) {
    this.ease && (s = this.ease(s))
    let t = this.first,
        e = t.next
    for (; s > e.time; ) ((t = e), (e = e.next))
    return (
        (s = (s - t.time) / (e.time - t.time)),
        (e.value - t.value) * s + t.value
    )
}
function eb(s) {
    this.ease && (s = this.ease(s))
    let t = this.first,
        e = t.next
    for (; s > e.time; ) ((t = e), (e = e.next))
    s = (s - t.time) / (e.time - t.time)
    const i = t.value,
        r = e.value,
        n = (r.r - i.r) * s + i.r,
        a = (r.g - i.g) * s + i.g,
        o = (r.b - i.b) * s + i.b
    return jn(n, a, o)
}
function ib(s) {
    this.ease && (s = this.ease(s))
    let t = this.first
    for (; t.next && s > t.next.time; ) t = t.next
    return t.value
}
function rb(s) {
    this.ease && (s = this.ease(s))
    let t = this.first
    for (; t.next && s > t.next.time; ) t = t.next
    const e = t.value
    return jn(e.r, e.g, e.b)
}
class Es {
    constructor(t = !1) {
        ;((this.first = null),
            (this.isColor = !!t),
            (this.interpolate = null),
            (this.ease = null))
    }
    reset(t) {
        ;((this.first = t),
            t.next && t.next.time >= 1
                ? (this.interpolate = this.isColor ? Jx : Qx)
                : t.isStepped
                  ? (this.interpolate = this.isColor ? rb : ib)
                  : (this.interpolate = this.isColor ? eb : tb),
            (this.ease = this.first.ease))
    }
}
class vl {
    constructor(t) {
        ;((this.order = bt.Normal),
            (this.list = new Es(!1)),
            this.list.reset(He.createList(t.alpha)))
    }
    initParticles(t) {
        let e = t
        for (; e; ) ((e.alpha = this.list.first.value), (e = e.next))
    }
    updateParticle(t) {
        t.alpha = this.list.interpolate(t.agePercent)
    }
}
vl.type = 'alpha'
vl.editorConfig = null
class xl {
    constructor(t) {
        ;((this.order = bt.Normal), (this.value = t.alpha))
    }
    initParticles(t) {
        let e = t
        for (; e; ) ((e.alpha = this.value), (e = e.next))
    }
}
xl.type = 'alphaStatic'
xl.editorConfig = null
function Kp(s) {
    const t = []
    for (let e = 0; e < s.length; ++e) {
        let i = s[e]
        if (typeof i == 'string') t.push(ys(i))
        else if (i instanceof j) t.push(i)
        else {
            let r = i.count || 1
            for (
                typeof i.texture == 'string'
                    ? (i = ys(i.texture))
                    : (i = i.texture);
                r > 0;
                --r
            )
                t.push(i)
        }
    }
    return t
}
class bl {
    constructor(t) {
        ;((this.order = bt.Normal), (this.anims = []))
        for (let e = 0; e < t.anims.length; ++e) {
            const i = t.anims[e],
                r = Kp(i.textures),
                n = i.framerate < 0 ? -1 : i.framerate > 0 ? i.framerate : 60,
                a = {
                    textures: r,
                    duration: n > 0 ? r.length / n : 0,
                    framerate: n,
                    loop: n > 0 ? !!i.loop : !1,
                }
            this.anims.push(a)
        }
    }
    initParticles(t) {
        let e = t
        for (; e; ) {
            const i = Math.floor(Math.random() * this.anims.length),
                r = (e.config.anim = this.anims[i])
            ;((e.texture = r.textures[0]),
                (e.config.animElapsed = 0),
                r.framerate === -1
                    ? ((e.config.animDuration = e.maxLife),
                      (e.config.animFramerate = r.textures.length / e.maxLife))
                    : ((e.config.animDuration = r.duration),
                      (e.config.animFramerate = r.framerate)),
                (e = e.next))
        }
    }
    updateParticle(t, e) {
        const i = t.config,
            r = i.anim
        ;((i.animElapsed += e),
            i.animElapsed >= i.animDuration &&
                (i.anim.loop
                    ? (i.animElapsed = i.animElapsed % i.animDuration)
                    : (i.animElapsed = i.animDuration - 1e-6)))
        const n = (i.animElapsed * i.animFramerate + 1e-7) | 0
        t.texture =
            r.textures[n] || r.textures[r.textures.length - 1] || j.EMPTY
    }
}
bl.type = 'animatedRandom'
bl.editorConfig = null
class wl {
    constructor(t) {
        this.order = bt.Normal
        const e = t.anim,
            i = Kp(e.textures),
            r = e.framerate < 0 ? -1 : e.framerate > 0 ? e.framerate : 60
        this.anim = {
            textures: i,
            duration: r > 0 ? i.length / r : 0,
            framerate: r,
            loop: r > 0 ? !!e.loop : !1,
        }
    }
    initParticles(t) {
        let e = t
        const i = this.anim
        for (; e; )
            ((e.texture = i.textures[0]),
                (e.config.animElapsed = 0),
                i.framerate === -1
                    ? ((e.config.animDuration = e.maxLife),
                      (e.config.animFramerate = i.textures.length / e.maxLife))
                    : ((e.config.animDuration = i.duration),
                      (e.config.animFramerate = i.framerate)),
                (e = e.next))
    }
    updateParticle(t, e) {
        const i = this.anim,
            r = t.config
        ;((r.animElapsed += e),
            r.animElapsed >= r.animDuration &&
                (i.loop
                    ? (r.animElapsed = r.animElapsed % r.animDuration)
                    : (r.animElapsed = r.animDuration - 1e-6)))
        const n = (r.animElapsed * r.animFramerate + 1e-7) | 0
        t.texture =
            i.textures[n] || i.textures[i.textures.length - 1] || j.EMPTY
    }
}
wl.type = 'animatedSingle'
wl.editorConfig = null
class Tl {
    constructor(t) {
        ;((this.order = bt.Normal), (this.value = t.blendMode))
    }
    initParticles(t) {
        let e = t
        for (; e; ) ((e.blendMode = Zx(this.value)), (e = e.next))
    }
}
Tl.type = 'blendMode'
Tl.editorConfig = null
class El {
    constructor(t) {
        ;((this.order = bt.Spawn),
            (this.spacing = t.spacing * Ne),
            (this.start = t.start * Ne),
            (this.distance = t.distance))
    }
    initParticles(t) {
        let e = 0,
            i = t
        for (; i; ) {
            let r
            ;(this.spacing
                ? (r = this.start + this.spacing * e)
                : (r = Math.random() * Math.PI * 2),
                (i.rotation = r),
                this.distance &&
                    ((i.position.x = this.distance), ei(r, i.position)),
                (i = i.next),
                ++e)
        }
    }
}
El.type = 'spawnBurst'
El.editorConfig = null
class Al {
    constructor(t) {
        ;((this.order = bt.Normal),
            (this.list = new Es(!0)),
            this.list.reset(He.createList(t.color)))
    }
    initParticles(t) {
        let e = t
        const i = this.list.first.value,
            r = jn(i.r, i.g, i.b)
        for (; e; ) ((e.tint = r), (e = e.next))
    }
    updateParticle(t) {
        t.tint = this.list.interpolate(t.agePercent)
    }
}
Al.type = 'color'
Al.editorConfig = null
class Sl {
    constructor(t) {
        this.order = bt.Normal
        let e = t.color
        ;(e.charAt(0) === '#'
            ? (e = e.substr(1))
            : e.indexOf('0x') === 0 && (e = e.substr(2)),
            (this.value = parseInt(e, 16)))
    }
    initParticles(t) {
        let e = t
        for (; e; ) ((e.tint = this.value), (e = e.next))
    }
}
Sl.type = 'colorStatic'
Sl.editorConfig = null
class Cl {
    constructor(t) {
        ;((this.order = bt.Normal),
            (this.index = 0),
            (this.textures = t.textures.map(e =>
                typeof e == 'string' ? ys(e) : e,
            )))
    }
    initParticles(t) {
        let e = t
        for (; e; )
            ((e.texture = this.textures[this.index]),
                ++this.index >= this.textures.length && (this.index = 0),
                (e = e.next))
    }
}
Cl.type = 'textureOrdered'
Cl.editorConfig = null
const dr = new ut(),
    Zp = [
        'E',
        'LN2',
        'LN10',
        'LOG2E',
        'LOG10E',
        'PI',
        'SQRT1_2',
        'SQRT2',
        'abs',
        'acos',
        'acosh',
        'asin',
        'asinh',
        'atan',
        'atanh',
        'atan2',
        'cbrt',
        'ceil',
        'cos',
        'cosh',
        'exp',
        'expm1',
        'floor',
        'fround',
        'hypot',
        'log',
        'log1p',
        'log10',
        'log2',
        'max',
        'min',
        'pow',
        'random',
        'round',
        'sign',
        'sin',
        'sinh',
        'sqrt',
        'tan',
        'tanh',
    ],
    sb = new RegExp(
        ['[01234567890\\.\\*\\-\\+\\/\\(\\)x ,]'].concat(Zp).join('|'),
        'g',
    )
function nb(s) {
    const t = s.match(sb)
    for (let e = t.length - 1; e >= 0; --e)
        Zp.indexOf(t[e]) >= 0 && (t[e] = `Math.${t[e]}`)
    return ((s = t.join('')), new Function('x', `return ${s};`))
}
class Pl {
    constructor(t) {
        var e
        if (((this.order = bt.Late), t.path))
            if (typeof t.path == 'function') this.path = t.path
            else
                try {
                    this.path = nb(t.path)
                } catch {
                    this.path = null
                }
        else this.path = i => i
        ;((this.list = new Es(!1)),
            this.list.reset(He.createList(t.speed)),
            (this.minMult = (e = t.minMult) !== null && e !== void 0 ? e : 1))
    }
    initParticles(t) {
        let e = t
        for (; e; ) {
            ;((e.config.initRotation = e.rotation),
                e.config.initPosition
                    ? e.config.initPosition.copyFrom(e.position)
                    : (e.config.initPosition = new ut(e.x, e.y)),
                (e.config.movement = 0))
            const i = Math.random() * (1 - this.minMult) + this.minMult
            ;((e.config.speedMult = i), (e = e.next))
        }
    }
    updateParticle(t, e) {
        const i = this.list.interpolate(t.agePercent) * t.config.speedMult
        ;((t.config.movement += i * e),
            (dr.x = t.config.movement),
            (dr.y = this.path(dr.x)),
            ei(t.config.initRotation, dr),
            (t.position.x = t.config.initPosition.x + dr.x),
            (t.position.y = t.config.initPosition.y + dr.y))
    }
}
Pl.type = 'movePath'
Pl.editorConfig = null
class Rl {
    constructor() {
        this.order = bt.Spawn
    }
    initParticles(t) {}
}
Rl.type = 'spawnPoint'
Rl.editorConfig = null
class Il {
    constructor(t) {
        ;((this.order = bt.Normal),
            (this.textures = t.textures.map(e =>
                typeof e == 'string' ? ys(e) : e,
            )))
    }
    initParticles(t) {
        let e = t
        for (; e; ) {
            const i = Math.floor(Math.random() * this.textures.length)
            ;((e.texture = this.textures[i]), (e = e.next))
        }
    }
}
Il.type = 'textureRandom'
Il.editorConfig = null
class Ml {
    constructor(t) {
        ;((this.order = bt.Normal),
            (this.minStart = t.minStart * Ne),
            (this.maxStart = t.maxStart * Ne),
            (this.minSpeed = t.minSpeed * Ne),
            (this.maxSpeed = t.maxSpeed * Ne),
            (this.accel = t.accel * Ne))
    }
    initParticles(t) {
        let e = t
        for (; e; )
            (this.minStart === this.maxStart
                ? (e.rotation += this.maxStart)
                : (e.rotation +=
                      Math.random() * (this.maxStart - this.minStart) +
                      this.minStart),
                (e.config.rotSpeed =
                    Math.random() * (this.maxSpeed - this.minSpeed) +
                    this.minSpeed),
                (e = e.next))
    }
    updateParticle(t, e) {
        if (this.accel) {
            const i = t.config.rotSpeed
            ;((t.config.rotSpeed += this.accel * e),
                (t.rotation += ((t.config.rotSpeed + i) / 2) * e))
        } else t.rotation += t.config.rotSpeed * e
    }
}
Ml.type = 'rotation'
Ml.editorConfig = null
class Dl {
    constructor(t) {
        ;((this.order = bt.Normal),
            (this.min = t.min * Ne),
            (this.max = t.max * Ne))
    }
    initParticles(t) {
        let e = t
        for (; e; )
            (this.min === this.max
                ? (e.rotation += this.max)
                : (e.rotation +=
                      Math.random() * (this.max - this.min) + this.min),
                (e = e.next))
    }
}
Dl.type = 'rotationStatic'
Dl.editorConfig = null
class Bl {
    constructor(t) {
        ;((this.order = bt.Late + 1), (this.rotation = (t.rotation || 0) * Ne))
    }
    initParticles(t) {
        let e = t
        for (; e; ) ((e.rotation = this.rotation), (e = e.next))
    }
}
Bl.type = 'noRotation'
Bl.editorConfig = null
class Ol {
    constructor(t) {
        var e
        ;((this.order = bt.Normal),
            (this.list = new Es(!1)),
            this.list.reset(He.createList(t.scale)),
            (this.minMult = (e = t.minMult) !== null && e !== void 0 ? e : 1))
    }
    initParticles(t) {
        let e = t
        for (; e; ) {
            const i = Math.random() * (1 - this.minMult) + this.minMult
            ;((e.config.scaleMult = i),
                (e.scale.x = e.scale.y = this.list.first.value * i),
                (e = e.next))
        }
    }
    updateParticle(t) {
        t.scale.x = t.scale.y =
            this.list.interpolate(t.agePercent) * t.config.scaleMult
    }
}
Ol.type = 'scale'
Ol.editorConfig = null
class Fl {
    constructor(t) {
        ;((this.order = bt.Normal), (this.min = t.min), (this.max = t.max))
    }
    initParticles(t) {
        let e = t
        for (; e; ) {
            const i = Math.random() * (this.max - this.min) + this.min
            ;((e.scale.x = e.scale.y = i), (e = e.next))
        }
    }
}
Fl.type = 'scaleStatic'
Fl.editorConfig = null
class Ce {
    constructor(t) {
        this.order = bt.Spawn
        const e = Ce.shapes[t.type]
        if (!e) throw new Error(`No shape found with type '${t.type}'`)
        this.shape = new e(t.data)
    }
    static registerShape(t, e) {
        Ce.shapes[e || t.type] = t
    }
    initParticles(t) {
        let e = t
        for (; e; ) (this.shape.getRandPos(e), (e = e.next))
    }
}
Ce.type = 'spawnShape'
Ce.editorConfig = null
Ce.shapes = {}
Ce.registerShape(_l)
Ce.registerShape(gl)
Ce.registerShape(qn)
Ce.registerShape(qn, 'circle')
class Ll {
    constructor(t) {
        ;((this.order = bt.Normal),
            (this.texture =
                typeof t.texture == 'string' ? ys(t.texture) : t.texture))
    }
    initParticles(t) {
        let e = t
        for (; e; ) ((e.texture = this.texture), (e = e.next))
    }
}
Ll.type = 'textureSingle'
Ll.editorConfig = null
class kl {
    constructor(t) {
        var e
        ;((this.order = bt.Late),
            (this.list = new Es(!1)),
            this.list.reset(He.createList(t.speed)),
            (this.minMult = (e = t.minMult) !== null && e !== void 0 ? e : 1))
    }
    initParticles(t) {
        let e = t
        for (; e; ) {
            const i = Math.random() * (1 - this.minMult) + this.minMult
            ;((e.config.speedMult = i),
                e.config.velocity
                    ? e.config.velocity.set(this.list.first.value * i, 0)
                    : (e.config.velocity = new ut(
                          this.list.first.value * i,
                          0,
                      )),
                ei(e.rotation, e.config.velocity),
                (e = e.next))
        }
    }
    updateParticle(t, e) {
        const i = this.list.interpolate(t.agePercent) * t.config.speedMult,
            r = t.config.velocity
        ;(Kx(r), qp(r, i), (t.x += r.x * e), (t.y += r.y * e))
    }
}
kl.type = 'moveSpeed'
kl.editorConfig = null
class Nl {
    constructor(t) {
        ;((this.order = bt.Late), (this.min = t.min), (this.max = t.max))
    }
    initParticles(t) {
        let e = t
        for (; e; ) {
            const i = Math.random() * (this.max - this.min) + this.min
            ;(e.config.velocity
                ? e.config.velocity.set(i, 0)
                : (e.config.velocity = new ut(i, 0)),
                ei(e.rotation, e.config.velocity),
                (e = e.next))
        }
    }
    updateParticle(t, e) {
        const i = t.config.velocity
        ;((t.x += i.x * e), (t.y += i.y * e))
    }
}
Nl.type = 'moveSpeedStatic'
Nl.editorConfig = null
function ab(s, t) {
    var e, i, r, n, a, o, h, l, u, c, d, f, m, p, g, _, b, v, w, x, P
    if ('behaviors' in s) return s
    const y = {
        lifetime: s.lifetime,
        ease: s.ease,
        particlesPerWave: s.particlesPerWave,
        frequency: s.frequency,
        spawnChance: s.spawnChance,
        emitterLifetime: s.emitterLifetime,
        maxParticles: s.maxParticles,
        addAtBack: s.addAtBack,
        pos: s.pos,
        emit: s.emit,
        autoUpdate: s.autoUpdate,
        behaviors: [],
    }
    if (s.alpha)
        if ('start' in s.alpha)
            if (s.alpha.start === s.alpha.end)
                s.alpha.start !== 1 &&
                    y.behaviors.push({
                        type: 'alphaStatic',
                        config: { alpha: s.alpha.start },
                    })
            else {
                const S = {
                    list: [
                        { time: 0, value: s.alpha.start },
                        { time: 1, value: s.alpha.end },
                    ],
                }
                y.behaviors.push({ type: 'alpha', config: { alpha: S } })
            }
        else
            s.alpha.list.length === 1
                ? s.alpha.list[0].value !== 1 &&
                  y.behaviors.push({
                      type: 'alphaStatic',
                      config: { alpha: s.alpha.list[0].value },
                  })
                : y.behaviors.push({
                      type: 'alpha',
                      config: { alpha: s.alpha },
                  })
    if (s.acceleration && (s.acceleration.x || s.acceleration.y)) {
        let S, R
        ;('start' in s.speed
            ? ((S =
                  s.speed.start *
                  ((e = s.speed.minimumSpeedMultiplier) !== null && e !== void 0
                      ? e
                      : 1)),
              (R = s.speed.start))
            : ((S =
                  s.speed.list[0].value *
                  ((i = s.minimumSpeedMultiplier) !== null && i !== void 0
                      ? i
                      : 1)),
              (R = s.speed.list[0].value)),
            y.behaviors.push({
                type: 'moveAcceleration',
                config: {
                    accel: s.acceleration,
                    minStart: S,
                    maxStart: R,
                    rotate: !s.noRotation,
                    maxSpeed: s.maxSpeed,
                },
            }))
    } else if (!((r = s.extraData) === null || r === void 0) && r.path) {
        let S, R
        ;('start' in s.speed
            ? ((R =
                  (n = s.speed.minimumSpeedMultiplier) !== null && n !== void 0
                      ? n
                      : 1),
              s.speed.start === s.speed.end
                  ? (S = { list: [{ time: 0, value: s.speed.start }] })
                  : (S = {
                        list: [
                            { time: 0, value: s.speed.start },
                            { time: 1, value: s.speed.end },
                        ],
                    }))
            : ((S = s.speed),
              (R =
                  (a = s.minimumSpeedMultiplier) !== null && a !== void 0
                      ? a
                      : 1)),
            y.behaviors.push({
                type: 'movePath',
                config: { path: s.extraData.path, speed: S, minMult: R },
            }))
    } else if (s.speed)
        if ('start' in s.speed)
            if (s.speed.start === s.speed.end)
                y.behaviors.push({
                    type: 'moveSpeedStatic',
                    config: {
                        min:
                            s.speed.start *
                            ((o = s.speed.minimumSpeedMultiplier) !== null &&
                            o !== void 0
                                ? o
                                : 1),
                        max: s.speed.start,
                    },
                })
            else {
                const S = {
                    list: [
                        { time: 0, value: s.speed.start },
                        { time: 1, value: s.speed.end },
                    ],
                }
                y.behaviors.push({
                    type: 'moveSpeed',
                    config: {
                        speed: S,
                        minMult: s.speed.minimumSpeedMultiplier,
                    },
                })
            }
        else
            s.speed.list.length === 1
                ? y.behaviors.push({
                      type: 'moveSpeedStatic',
                      config: {
                          min:
                              s.speed.list[0].value *
                              ((h = s.minimumSpeedMultiplier) !== null &&
                              h !== void 0
                                  ? h
                                  : 1),
                          max: s.speed.list[0].value,
                      },
                  })
                : y.behaviors.push({
                      type: 'moveSpeed',
                      config: {
                          speed: s.speed,
                          minMult:
                              (l = s.minimumSpeedMultiplier) !== null &&
                              l !== void 0
                                  ? l
                                  : 1,
                      },
                  })
    if (s.scale)
        if ('start' in s.scale) {
            const S =
                (u = s.scale.minimumScaleMultiplier) !== null && u !== void 0
                    ? u
                    : 1
            if (s.scale.start === s.scale.end)
                y.behaviors.push({
                    type: 'scaleStatic',
                    config: { min: s.scale.start * S, max: s.scale.start },
                })
            else {
                const R = {
                    list: [
                        { time: 0, value: s.scale.start },
                        { time: 1, value: s.scale.end },
                    ],
                }
                y.behaviors.push({
                    type: 'scale',
                    config: { scale: R, minMult: S },
                })
            }
        } else if (s.scale.list.length === 1) {
            const S =
                    (c = s.minimumScaleMultiplier) !== null && c !== void 0
                        ? c
                        : 1,
                R = s.scale.list[0].value
            y.behaviors.push({
                type: 'scaleStatic',
                config: { min: R * S, max: R },
            })
        } else
            y.behaviors.push({
                type: 'scale',
                config: {
                    scale: s.scale,
                    minMult:
                        (d = s.minimumScaleMultiplier) !== null && d !== void 0
                            ? d
                            : 1,
                },
            })
    if (s.color)
        if ('start' in s.color)
            if (s.color.start === s.color.end)
                s.color.start !== 'ffffff' &&
                    y.behaviors.push({
                        type: 'colorStatic',
                        config: { color: s.color.start },
                    })
            else {
                const S = {
                    list: [
                        { time: 0, value: s.color.start },
                        { time: 1, value: s.color.end },
                    ],
                }
                y.behaviors.push({ type: 'color', config: { color: S } })
            }
        else
            s.color.list.length === 1
                ? s.color.list[0].value !== 'ffffff' &&
                  y.behaviors.push({
                      type: 'colorStatic',
                      config: { color: s.color.list[0].value },
                  })
                : y.behaviors.push({
                      type: 'color',
                      config: { color: s.color },
                  })
    if (
        (s.rotationAcceleration ||
        (!((f = s.rotationSpeed) === null || f === void 0) && f.min) ||
        (!((m = s.rotationSpeed) === null || m === void 0) && m.max)
            ? y.behaviors.push({
                  type: 'rotation',
                  config: {
                      accel: s.rotationAcceleration || 0,
                      minSpeed:
                          ((p = s.rotationSpeed) === null || p === void 0
                              ? void 0
                              : p.min) || 0,
                      maxSpeed:
                          ((g = s.rotationSpeed) === null || g === void 0
                              ? void 0
                              : g.max) || 0,
                      minStart:
                          ((_ = s.startRotation) === null || _ === void 0
                              ? void 0
                              : _.min) || 0,
                      maxStart:
                          ((b = s.startRotation) === null || b === void 0
                              ? void 0
                              : b.max) || 0,
                  },
              })
            : ((!((v = s.startRotation) === null || v === void 0) && v.min) ||
                  (!((w = s.startRotation) === null || w === void 0) &&
                      w.max)) &&
              y.behaviors.push({
                  type: 'rotationStatic',
                  config: {
                      min:
                          ((x = s.startRotation) === null || x === void 0
                              ? void 0
                              : x.min) || 0,
                      max:
                          ((P = s.startRotation) === null || P === void 0
                              ? void 0
                              : P.max) || 0,
                  },
              }),
        s.noRotation && y.behaviors.push({ type: 'noRotation', config: {} }),
        s.blendMode &&
            s.blendMode !== 'normal' &&
            y.behaviors.push({
                type: 'blendMode',
                config: { blendMode: s.blendMode },
            }),
        Array.isArray(t) && typeof t[0] != 'string' && 'framerate' in t[0])
    ) {
        for (let S = 0; S < t.length; ++S)
            t[S].framerate === 'matchLife' && (t[S].framerate = -1)
        y.behaviors.push({ type: 'animatedRandom', config: { anims: t } })
    } else
        typeof t != 'string' && 'framerate' in t
            ? (t.framerate === 'matchLife' && (t.framerate = -1),
              y.behaviors.push({ type: 'animatedSingle', config: { anim: t } }))
            : s.orderedArt && Array.isArray(t)
              ? y.behaviors.push({
                    type: 'textureOrdered',
                    config: { textures: t },
                })
              : Array.isArray(t)
                ? y.behaviors.push({
                      type: 'textureRandom',
                      config: { textures: t },
                  })
                : y.behaviors.push({
                      type: 'textureSingle',
                      config: { texture: t },
                  })
    if (s.spawnType === 'burst')
        y.behaviors.push({
            type: 'spawnBurst',
            config: {
                start: s.angleStart || 0,
                spacing: s.particleSpacing,
                distance: 0,
            },
        })
    else if (s.spawnType === 'point')
        y.behaviors.push({ type: 'spawnPoint', config: {} })
    else {
        let S
        ;(s.spawnType === 'ring'
            ? (S = {
                  type: 'torus',
                  data: {
                      x: s.spawnCircle.x,
                      y: s.spawnCircle.y,
                      radius: s.spawnCircle.r,
                      innerRadius: s.spawnCircle.minR,
                      affectRotation: !0,
                  },
              })
            : s.spawnType === 'circle'
              ? (S = {
                    type: 'torus',
                    data: {
                        x: s.spawnCircle.x,
                        y: s.spawnCircle.y,
                        radius: s.spawnCircle.r,
                        innerRadius: 0,
                        affectRotation: !1,
                    },
                })
              : s.spawnType === 'rect'
                ? (S = { type: 'rect', data: s.spawnRect })
                : s.spawnType === 'polygonalChain' &&
                  (S = { type: 'polygonalChain', data: s.spawnPolygon }),
            S && y.behaviors.push({ type: 'spawnShape', config: S }))
    }
    return y
}
_t.registerBehavior(yl)
_t.registerBehavior(vl)
_t.registerBehavior(xl)
_t.registerBehavior(bl)
_t.registerBehavior(wl)
_t.registerBehavior(Tl)
_t.registerBehavior(El)
_t.registerBehavior(Al)
_t.registerBehavior(Sl)
_t.registerBehavior(Cl)
_t.registerBehavior(Pl)
_t.registerBehavior(Rl)
_t.registerBehavior(Il)
_t.registerBehavior(Ml)
_t.registerBehavior(Dl)
_t.registerBehavior(Bl)
_t.registerBehavior(Ol)
_t.registerBehavior(Fl)
_t.registerBehavior(Ce)
_t.registerBehavior(Ll)
_t.registerBehavior(kl)
_t.registerBehavior(Nl)
const ob = {
    alpha: { start: 1, end: 0.6 },
    scale: { start: 0.7, end: 0.1, minimumScaleMultiplier: 1 },
    color: { start: '#ffd900', end: '#ff8e24' },
    speed: { start: 100, end: 50, minimumSpeedMultiplier: 1 },
    acceleration: { x: 0, y: 0 },
    maxSpeed: 0,
    startRotation: { min: 270, max: 270 },
    noRotation: !0,
    rotationSpeed: { min: 0, max: 0 },
    lifetime: { min: 0.5, max: 1 },
    blendMode: 'screen',
    frequency: 0.1,
    emitterLifetime: -1,
    maxParticles: 10,
    pos: { x: 0, y: 0 },
    addAtBack: !1,
    spawnType: 'rect',
    spawnRect: { x: -10, y: -5, w: 20, h: 10 },
}
class hb extends ws {
    constructor(t) {
        super(t)
        let e = new Kh()
        ;(e.beginFill(9013641),
            e.drawRect(0, 0, 200, 100),
            (this.background = this.addChild(e)),
            (this.particleContainer = this.addChild(new Kt())))
        const i = j.from('smoke_particle')
        ;((this.emitter = new _t(this.particleContainer, ab(ob, [i]))),
            (this.emitter.emit = !0))
    }
    resize() {
        const t = this.gameController.layoutManager,
            { width: e, height: i, orientation: r } = t
        ;(this.particleContainer.position.set(0, 0),
            (this.background.width = e),
            (this.background.height = i),
            this.background.position.set(-e / 2, -i / 2))
    }
    update(t) {
        this.emitter.update(t * 0.001)
    }
}
const lb = {
    extension: $.LoadParser,
    test: s => s.startsWith('https://api.dicebear.com/9.x/personas'),
    async load(s) {
        return new Promise((t, e) => {
            const i = new Image()
            ;((i.onload = () => t(j.from(i))),
                (i.onerror = e),
                (i.crossOrigin = 'anonymous'),
                (i.src = s))
        })
    },
}
Q.add(lb)
class Vi {
    constructor(t) {
        ;((this.size = { w: 800, h: 800 }),
            (this.scenes = []),
            (this.app = new Ef({
                width: this.size.w,
                height: this.size.h,
                backgroundColor: 0,
                view: t || document.body,
                antialias: !0,
            })),
            (this.domElement = t.parentElement),
            this.app.ticker.add(this.update, this),
            (this.preloader = new Pv(this.start.bind(this))),
            this.preloader.preload(),
            (this.layoutManager = new Rv(this)),
            this.layoutManager.fitLayout())
        let e
        ;(window.addEventListener('resize', () => {
            ;(e && clearTimeout(e),
                (e = setTimeout(this.resize.bind(this), 100)))
        }),
            (this.fullScrene = this.fullScrene.bind(this)))
    }
    static get Instance() {
        const t = document.getElementById('scene')
        return (
            (Vi.instance = Vi.instance || (Vi.instance = new Vi(t))),
            Vi.instance
        )
    }
    showScene(t) {
        if (
            (this.currentScene &&
                (this.app.stage.removeChild(this.currentScene),
                this.currentScene.onHide?.()),
            this.app.stage.addChildAt(t, 0),
            t.position.set(
                this.app.renderer.width / 2,
                this.app.renderer.height / 2,
            ),
            t instanceof ws)
        )
            return (
                t.resize(),
                (this.currentScene = t),
                this.currentScene.onShow?.(),
                this.currentScene
            )
    }
    fullScrene() {
        ;(this.domElement.requestFullscreen(),
            this.ui.off('pointerdown', this.fullScrene))
    }
    resize() {
        this.layoutManager.fitLayout()
        const t = {
            x: this.app.renderer.width / 2,
            y: this.app.renderer.height / 2,
        }
        ;(this.currentScene &&
            (this.currentScene.position.set(t.x, t.y),
            this.currentScene.resize()),
            this.ui.position.set(t.x, t.y),
            this.ui.resize())
    }
    async start() {
        ;((this.scenes = [new jx(this), new Yx(this), new hb(this)]),
            await Promise.all(
                this.scenes.map(t => (t.init ? t.init() : Promise.resolve())),
            ),
            this.showScene(new Kt()),
            (document.getElementById('loader').style.display = 'none'),
            (this.ui = new Xx(this)),
            this.ui.on('pointerdown', this.fullScrene),
            (this.ui.eventMode = 'static'),
            this.app.stage.addChildAt(this.ui, 1),
            this.ui.position.set(
                this.app.renderer.width / 2,
                this.app.renderer.height / 2,
            ),
            this.resize())
    }
    update() {
        const t = Yt.shared.elapsedMS
        this.currentScene?.update?.(t)
    }
}
Vi.Instance
;(function () {
    var s = document.createElement('script')
    ;((s.onload = function () {
        var t = new Stats()
        ;(document.body.appendChild(t.dom),
            requestAnimationFrame(function e() {
                ;(t.update(), requestAnimationFrame(e))
            }))
    }),
        (s.src = '//mrdoob.github.io/stats.js/build/stats.min.js'),
        document.head.appendChild(s))
})()
